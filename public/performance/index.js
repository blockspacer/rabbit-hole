(function () {
	'use strict';

	/**
	 * An enumeration of worker actions.
	 *
	 * @type {Object}
	 * @property {String} CONFIGURE - General configuration signal.
	 * @property {String} TEST - Test start signal.
	 */

	const Action = {

		CONFIGURE: "worker.config",
		TEST: "worker.test"

	};

	var workerCode = "(function () {\n\t'use strict';\n\n\t/**\r\n\t * The Serializable contract.\r\n\t *\r\n\t * Implemented by objects that can provide a flat representation of the data\r\n\t * they contain.\r\n\t *\r\n\t * @interface\r\n\t */\n\n\t/**\r\n\t * The Deserializable contract.\r\n\t *\r\n\t * Implemented by objects that can adopt serialised data.\r\n\t *\r\n\t * @interface\r\n\t */\n\n\t/**\r\n\t * The Disposable contract.\r\n\t *\r\n\t * Implemented by objects that can free internal resources.\r\n\t *\r\n\t * @interface\r\n\t */\n\n\t/**\r\n\t * The TransferableContainer contract.\r\n\t *\r\n\t * Implemented by objects that can list their internal transferable objects.\r\n\t *\r\n\t * @interface\r\n\t */\n\n\t/**\r\n\t * A FIFO queue.\r\n\t *\r\n\t * Elements are added to the end of the queue and removed from the front.\r\n\t *\r\n\t * Based on:\r\n\t *  http://code.stephenmorley.org/javascript/queues/\r\n\t */\n\n\t/**\r\n\t * A basic event.\r\n\t */\r\n\r\n\tclass Event {\r\n\r\n\t\t/**\r\n\t\t * Creates a new event.\r\n\t\t *\r\n\t\t * @param {String} type - The name of the event.\r\n\t\t */\r\n\r\n\t\tconstructor(type) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The name of the event.\r\n\t\t\t *\r\n\t\t\t * @type {String}\r\n\t\t\t */\r\n\r\n\t\t\tthis.type = type;\r\n\r\n\t\t\t/**\r\n\t\t\t * A reference to the target to which the event was originally dispatched.\r\n\t\t\t *\r\n\t\t\t * @type {Object}\r\n\t\t\t */\r\n\r\n\t\t\tthis.target = null;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A base class for objects that can receive events and may have listeners for\r\n\t * them.\r\n\t */\n\n\t/**\r\n\t * A collection of event classes.\r\n\t *\r\n\t * @module synthetic-event\r\n\t */\n\n\t/**\r\n\t * An enumeration of CSG operation types.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {String} UNION - Indicates a union of volume data.\r\n\t * @property {String} DIFFERENCE - Indicates a subtraction of volume data.\r\n\t * @property {String} INTERSECTION - Indicates an intersection of volume data.\r\n\t * @property {String} DENSITY_FUNCTION - Indicates volume data generation.\r\n\t */\r\n\r\n\tconst OperationType = {\r\n\r\n\t\tUNION: \"csg.union\",\r\n\t\tDIFFERENCE: \"csg.difference\",\r\n\t\tINTERSECTION: \"csg.intersection\",\r\n\t\tDENSITY_FUNCTION: \"csg.densityfunction\"\r\n\r\n\t};\n\n\t/**\r\n\t * A vector with three components.\r\n\t */\r\n\r\n\tclass Vector3 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new vector.\r\n\t\t *\r\n\t\t * @param {Number} [x=0] - The X component.\r\n\t\t * @param {Number} [y=0] - The Y component.\r\n\t\t * @param {Number} [z=0] - The Z component.\r\n\t\t */\r\n\r\n\t\tconstructor(x = 0, y = 0, z = 0) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The X component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.x = x;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Y component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Z component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.z = z;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this vector\r\n\t\t *\r\n\t\t * @param {Number} x - The X component.\r\n\t\t * @param {Number} y - The Y component.\r\n\t\t * @param {Number} z - The Z component.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tset(x, y, z) {\r\n\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of another vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tcopy(v) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} A clone of this vector.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor(this.x, this.y, this.z);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies values from an array.\r\n\t\t *\r\n\t\t * @param {Number[]} array - An array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tfromArray(array, offset = 0) {\r\n\r\n\t\t\tthis.x = array[offset];\r\n\t\t\tthis.y = array[offset + 1];\r\n\t\t\tthis.z = array[offset + 2];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores this vector in an array.\r\n\t\t *\r\n\t\t * @param {Array} [array] - A target array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Number[]} The array.\r\n\t\t */\r\n\r\n\t\ttoArray(array = [], offset = 0) {\r\n\r\n\t\t\tarray[offset] = this.x;\r\n\t\t\tarray[offset + 1] = this.y;\r\n\t\t\tarray[offset + 2] = this.z;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this vector based on a spherical description.\r\n\t\t *\r\n\t\t * @param {Spherical} s - A spherical description.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetFromSpherical(s) {\r\n\r\n\t\t\tconst sinPhiRadius = Math.sin(s.phi) * s.radius;\r\n\r\n\t\t\tthis.x = sinPhiRadius * Math.sin(s.theta);\r\n\t\t\tthis.y = Math.cos(s.phi) * s.radius;\r\n\t\t\tthis.z = sinPhiRadius * Math.cos(s.theta);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this vector based on a cylindrical description.\r\n\t\t *\r\n\t\t * @param {Cylindrical} c - A cylindrical description.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetFromCylindrical(c) {\r\n\r\n\t\t\tthis.x = c.radius * Math.sin(c.theta);\r\n\t\t\tthis.y = c.y;\r\n\t\t\tthis.z = c.radius * Math.cos(c.theta);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a matrix column.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A 4x4 matrix.\r\n\t\t * @param {Number} index - A column index of the range [0, 2].\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetFromMatrixColumn(m, index) {\r\n\r\n\t\t\treturn this.fromArray(m.elements, index * 4);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Extracts the position from a matrix.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A 4x4 matrix.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetFromMatrixPosition(m) {\r\n\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tthis.x = me[12];\r\n\t\t\tthis.y = me[13];\r\n\t\t\tthis.z = me[14];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Extracts the scale from a matrix.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A 4x4 matrix.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetFromMatrixScale(m) {\r\n\r\n\t\t\tconst sx = this.setFromMatrixColumn(m, 0).length();\r\n\t\t\tconst sy = this.setFromMatrixColumn(m, 1).length();\r\n\t\t\tconst sz = this.setFromMatrixColumn(m, 2).length();\r\n\r\n\t\t\tthis.x = sx;\r\n\t\t\tthis.y = sy;\r\n\t\t\tthis.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - The vector to add.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tadd(v) {\r\n\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scalar to this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to add.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\taddScalar(s) {\r\n\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the sum of two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector3} a - A vector.\r\n\t\t * @param {Vector3} b - Another vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\taddVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scaled vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - The vector to scale and add.\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\taddScaledVector(v, s) {\r\n\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a vector from this vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - The vector to subtract.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsub(v) {\r\n\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a scalar from this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to subtract.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsubScalar(s) {\r\n\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the difference between two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector3} a - A vector.\r\n\t\t * @param {Vector3} b - A second vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsubVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with another vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tmultiply(v) {\r\n\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\t\tthis.z *= v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tmultiplyScalar(s) {\r\n\r\n\t\t\tthis.x *= s;\r\n\t\t\tthis.y *= s;\r\n\t\t\tthis.z *= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the product of two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector3} a - A vector.\r\n\t\t * @param {Vector3} b - Another vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tmultiplyVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x * b.x;\r\n\t\t\tthis.y = a.y * b.y;\r\n\t\t\tthis.z = a.z * b.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by another vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tdivide(v) {\r\n\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\t\tthis.z /= v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tdivideScalar(s) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\t\t\tthis.z /= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the cross product of the given vectors.\r\n\t\t *\r\n\t\t * @param {Vector3} a - A vector.\r\n\t\t * @param {Vector3} b - Another vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tcrossVectors(a, b) {\r\n\r\n\t\t\tconst ax = a.x, ay = a.y, az = a.z;\r\n\t\t\tconst bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\t\tthis.x = ay * bz - az * by;\r\n\t\t\tthis.y = az * bx - ax * bz;\r\n\t\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the cross product of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tcross(v) {\r\n\r\n\t\t\treturn this.crossVectors(this, v);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies a matrix to this direction vector.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\ttransformDirection(m) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\t\tconst e = m.elements;\r\n\r\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z;\r\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z;\r\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies a matrix to this vector.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - A matrix.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tapplyMatrix3(m) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\t\tconst e = m.elements;\r\n\r\n\t\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\r\n\t\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\r\n\t\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies a matrix to this vector.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tapplyMatrix4(m) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\t\tconst e = m.elements;\r\n\r\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12];\r\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13];\r\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies a quaternion to this vector.\r\n\t\t *\r\n\t\t * @param {Quaternion} q - A quaternion.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tapplyQuaternion(q) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n\r\n\t\t\t// Calculate: quaternion * vector.\r\n\t\t\tconst ix = qw * x + qy * z - qz * y;\r\n\t\t\tconst iy = qw * y + qz * x - qx * z;\r\n\t\t\tconst iz = qw * z + qx * y - qy * x;\r\n\t\t\tconst iw = -qx * x - qy * y - qz * z;\r\n\r\n\t\t\t// Calculate: result * inverse quaternion.\r\n\t\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n\t\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n\t\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Negates this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tnegate() {\r\n\r\n\t\t\tthis.x = -this.x;\r\n\t\t\tthis.y = -this.y;\r\n\t\t\tthis.z = -this.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the dot product with another vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Number} The dot product.\r\n\t\t */\r\n\r\n\t\tdot(v) {\r\n\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Reflects this vector. The given plane normal is assumed to be normalized.\r\n\t\t *\r\n\t\t * @param {Vector3} n - A normal.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\treflect(n) {\r\n\r\n\t\t\tconst nx = n.x;\r\n\t\t\tconst ny = n.y;\r\n\t\t\tconst nz = n.z;\r\n\r\n\t\t\tthis.sub(n.multiplyScalar(2 * this.dot(n)));\r\n\r\n\t\t\t// Restore the normal.\r\n\t\t\tn.set(nx, ny, nz);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the angle to the given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Number} The angle in radians.\r\n\t\t */\r\n\r\n\t\tangleTo(v) {\r\n\r\n\t\t\tconst theta = this.dot(v) / (Math.sqrt(this.lengthSquared() * v.lengthSquared()));\r\n\r\n\t\t\t// Clamp to avoid numerical problems.\r\n\t\t\treturn Math.acos(Math.min(Math.max(theta, -1), 1));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tmanhattanLength() {\r\n\r\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The squared length.\r\n\t\t */\r\n\r\n\t\tlengthSquared() {\r\n\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tlength() {\r\n\r\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tmanhattanDistanceTo(v) {\r\n\r\n\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Number} The squared distance.\r\n\t\t */\r\n\r\n\t\tdistanceToSquared(v) {\r\n\r\n\t\t\tconst dx = this.x - v.x;\r\n\t\t\tconst dy = this.y - v.y;\r\n\t\t\tconst dz = this.z - v.z;\r\n\r\n\t\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tdistanceTo(v) {\r\n\r\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Normalizes this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tnormalize() {\r\n\r\n\t\t\treturn this.divideScalar(this.length());\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the length of this vector.\r\n\t\t *\r\n\t\t * @param {Number} length - The new length.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetLength(length) {\r\n\r\n\t\t\treturn this.normalize().multiplyScalar(length);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the min value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tmin(v) {\r\n\r\n\t\t\tthis.x = Math.min(this.x, v.x);\r\n\t\t\tthis.y = Math.min(this.y, v.y);\r\n\t\t\tthis.z = Math.min(this.z, v.z);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the max value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tmax(v) {\r\n\r\n\t\t\tthis.x = Math.max(this.x, v.x);\r\n\t\t\tthis.y = Math.max(this.y, v.y);\r\n\t\t\tthis.z = Math.max(this.z, v.z);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clamps this vector.\r\n\t\t *\r\n\t\t * @param {Vector3} min - The lower bounds. Assumed to be smaller than max.\r\n\t\t * @param {Vector3} max - The upper bounds. Assumed to be greater than min.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tclamp(min, max) {\r\n\r\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\r\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\r\n\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Floors this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tfloor() {\r\n\r\n\t\t\tthis.x = Math.floor(this.x);\r\n\t\t\tthis.y = Math.floor(this.y);\r\n\t\t\tthis.z = Math.floor(this.z);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Ceils this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tceil() {\r\n\r\n\t\t\tthis.x = Math.ceil(this.x);\r\n\t\t\tthis.y = Math.ceil(this.y);\r\n\t\t\tthis.z = Math.ceil(this.z);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rounds this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tround() {\r\n\r\n\t\t\tthis.x = Math.round(this.x);\r\n\t\t\tthis.y = Math.round(this.y);\r\n\t\t\tthis.z = Math.round(this.z);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Lerps towards the given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tlerp(v, alpha) {\r\n\r\n\t\t\tthis.x += (v.x - this.x) * alpha;\r\n\t\t\tthis.y += (v.y - this.y) * alpha;\r\n\t\t\tthis.z += (v.z - this.z) * alpha;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the lerp result of the given vectors.\r\n\t\t *\r\n\t\t * @param {Vector3} v1 - A base vector.\r\n\t\t * @param {Vector3} v2 - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tlerpVectors(v1, v2, alpha) {\r\n\r\n\t\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this vector equals the given one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Boolean} Whether this vector equals the given one.\r\n\t\t */\r\n\r\n\t\tequals(v) {\r\n\r\n\t\t\treturn (v.x === this.x && v.y === this.y && v.z === this.z);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v = new Vector3();\r\n\r\n\t/**\r\n\t * A 3D box.\r\n\t */\r\n\r\n\tclass Box3 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new box.\r\n\t\t *\r\n\t\t * @param {Vector3} [min] - The lower bounds.\r\n\t\t * @param {Vector3} [max] - The upper bounds.\r\n\t\t */\r\n\r\n\t\tconstructor(\r\n\t\t\tmin = new Vector3(Infinity, Infinity, Infinity),\r\n\t\t\tmax = new Vector3(-Infinity, -Infinity, -Infinity)\r\n\t\t) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The lower bounds.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.min = min;\r\n\r\n\t\t\t/**\r\n\t\t\t * The upper bounds.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.max = max;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this box.\r\n\t\t *\r\n\t\t * @param {Vector3} min - The lower bounds.\r\n\t\t * @param {Vector3} max - The upper bounds.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tset(min, max) {\r\n\r\n\t\t\tthis.min.copy(min);\r\n\t\t\tthis.max.copy(max);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a given box.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tcopy(b) {\r\n\r\n\t\t\tthis.min.copy(b.min);\r\n\t\t\tthis.max.copy(b.max);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this box.\r\n\t\t *\r\n\t\t * @return {Box3} A clone of this box.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().copy(this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Makes this box empty.\r\n\t\t *\r\n\t\t * The lower bounds are set to infinity and the upper bounds to negative\r\n\t\t * infinity to create an infinitely small box.\r\n\t\t *\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tmakeEmpty() {\r\n\r\n\t\t\tthis.min.x = this.min.y = this.min.z = Infinity;\r\n\t\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Indicates whether this box is truly empty.\r\n\t\t *\r\n\t\t * This is a more robust check for emptiness since the volume can get positive\r\n\t\t * with two negative axes.\r\n\t\t *\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tisEmpty() {\r\n\r\n\t\t\treturn (\r\n\t\t\t\tthis.max.x < this.min.x ||\r\n\t\t\t\tthis.max.y < this.min.y ||\r\n\t\t\t\tthis.max.z < this.min.z\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the center of this box.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the center of this box.\r\n\t\t */\r\n\r\n\t\tgetCenter(target = new Vector3()) {\r\n\r\n\t\t\treturn !this.isEmpty() ?\r\n\t\t\t\ttarget.addVectors(this.min, this.max).multiplyScalar(0.5) :\r\n\t\t\t\ttarget.set(0, 0, 0);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the size of this box.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the size of this box.\r\n\t\t */\r\n\r\n\t\tgetSize(target = new Vector3()) {\r\n\r\n\t\t\treturn !this.isEmpty() ?\r\n\t\t\t\ttarget.subVectors(this.max, this.min) :\r\n\t\t\t\ttarget.set(0, 0, 0);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the bounding box of the given sphere.\r\n\t\t *\r\n\t\t * @param {Sphere} sphere - A sphere.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tsetFromSphere(sphere) {\r\n\r\n\t\t\tthis.set(sphere.center, sphere.center);\r\n\t\t\tthis.expandByScalar(sphere.radius);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Expands this box by the given point.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\texpandByPoint(p) {\r\n\r\n\t\t\tthis.min.min(p);\r\n\t\t\tthis.max.max(p);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Expands this box by the given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\texpandByVector(v) {\r\n\r\n\t\t\tthis.min.sub(v);\r\n\t\t\tthis.max.add(v);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Expands this box by the given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\texpandByScalar(s) {\r\n\r\n\t\t\tthis.min.addScalar(-s);\r\n\t\t\tthis.max.addScalar(s);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Defines this box by the given points.\r\n\t\t *\r\n\t\t * @param {Vector3[]} points - The points.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tsetFromPoints(points) {\r\n\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tthis.min.set(0, 0, 0);\r\n\t\t\tthis.max.set(0, 0, 0);\r\n\r\n\t\t\tfor(i = 0, l = points.length; i < l; ++i) {\r\n\r\n\t\t\t\tthis.expandByPoint(points[i]);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Defines this box by the given center and size.\r\n\t\t *\r\n\t\t * @param {Vector3} center - The center.\r\n\t\t * @param {Number} size - The size.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tsetFromCenterAndSize(center, size) {\r\n\r\n\t\t\tconst halfSize = v.copy(size).multiplyScalar(0.5);\r\n\r\n\t\t\tthis.min.copy(center).sub(halfSize);\r\n\t\t\tthis.max.copy(center).add(halfSize);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clamps the given point to the boundaries of this box.\r\n\t\t *\r\n\t\t * @param {Vector3} point - A point.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The clamped point.\r\n\t\t */\r\n\r\n\t\tclampPoint(point, target = new Vector3()) {\r\n\r\n\t\t\treturn target.copy(point).clamp(this.min, this.max);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance from this box to the given point.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tdistanceToPoint(p) {\r\n\r\n\t\t\tconst clampedPoint = v.copy(p).clamp(this.min, this.max);\r\n\r\n\t\t\treturn clampedPoint.sub(p).length();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies the given matrix to this box.\r\n\t\t *\r\n\t\t * @param {Matrix4} matrix - The matrix.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tapplyMatrix4(matrix) {\r\n\r\n\t\t\tconst min = this.min;\r\n\t\t\tconst max = this.max;\r\n\r\n\t\t\tif(!this.isEmpty()) {\r\n\r\n\t\t\t\tconst me = matrix.elements;\r\n\r\n\t\t\t\tconst xax = me[0] * min.x;\r\n\t\t\t\tconst xay = me[1] * min.x;\r\n\t\t\t\tconst xaz = me[2] * min.x;\r\n\r\n\t\t\t\tconst xbx = me[0] * max.x;\r\n\t\t\t\tconst xby = me[1] * max.x;\r\n\t\t\t\tconst xbz = me[2] * max.x;\r\n\r\n\t\t\t\tconst yax = me[4] * min.y;\r\n\t\t\t\tconst yay = me[5] * min.y;\r\n\t\t\t\tconst yaz = me[6] * min.y;\r\n\r\n\t\t\t\tconst ybx = me[4] * max.y;\r\n\t\t\t\tconst yby = me[5] * max.y;\r\n\t\t\t\tconst ybz = me[6] * max.y;\r\n\r\n\t\t\t\tconst zax = me[8] * min.z;\r\n\t\t\t\tconst zay = me[9] * min.z;\r\n\t\t\t\tconst zaz = me[10] * min.z;\r\n\r\n\t\t\t\tconst zbx = me[8] * max.z;\r\n\t\t\t\tconst zby = me[9] * max.z;\r\n\t\t\t\tconst zbz = me[10] * max.z;\r\n\r\n\t\t\t\tmin.x = Math.min(xax, xbx) + Math.min(yax, ybx) + Math.min(zax, zbx) + me[12];\r\n\t\t\t\tmin.y = Math.min(xay, xby) + Math.min(yay, yby) + Math.min(zay, zby) + me[13];\r\n\t\t\t\tmin.z = Math.min(xaz, xbz) + Math.min(yaz, ybz) + Math.min(zaz, zbz) + me[14];\r\n\t\t\t\tmax.x = Math.max(xax, xbx) + Math.max(yax, ybx) + Math.max(zax, zbx) + me[12];\r\n\t\t\t\tmax.y = Math.max(xay, xby) + Math.max(yay, yby) + Math.max(zay, zby) + me[13];\r\n\t\t\t\tmax.z = Math.max(xaz, xbz) + Math.max(yaz, ybz) + Math.max(zaz, zbz) + me[14];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Translates this box.\r\n\t\t *\r\n\t\t * @param {Vector3} offset - The offset.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\ttranslate(offset) {\r\n\r\n\t\t\tthis.min.add(offset);\r\n\t\t\tthis.max.add(offset);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Intersects this box with the given one.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tintersect(b) {\r\n\r\n\t\t\tthis.min.max(b.min);\r\n\t\t\tthis.max.min(b.max);\r\n\r\n\t\t\t/* Ensure that if there is no overlap, the result is fully empty to prevent\r\n\t\t\tsubsequent intersections to erroneously return valid values. */\r\n\t\t\tif(this.isEmpty()) {\r\n\r\n\t\t\t\tthis.makeEmpty();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Expands this box by combining it with the given one.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tunion(b) {\r\n\r\n\t\t\tthis.min.min(b.min);\r\n\t\t\tthis.max.max(b.max);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if the given point lies inside this box.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @return {Boolean} Whether this box contains the point.\r\n\t\t */\r\n\r\n\t\tcontainsPoint(p) {\r\n\r\n\t\t\tconst min = this.min;\r\n\t\t\tconst max = this.max;\r\n\r\n\t\t\treturn (\r\n\t\t\t\tp.x >= min.x &&\r\n\t\t\t\tp.y >= min.y &&\r\n\t\t\t\tp.z >= min.z &&\r\n\t\t\t\tp.x <= max.x &&\r\n\t\t\t\tp.y <= max.y &&\r\n\t\t\t\tp.z <= max.z\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if the given box lies inside this box.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Boolean} Whether this box contains the given one.\r\n\t\t */\r\n\r\n\t\tcontainsBox(b) {\r\n\r\n\t\t\tconst tMin = this.min;\r\n\t\t\tconst tMax = this.max;\r\n\t\t\tconst bMin = b.min;\r\n\t\t\tconst bMax = b.max;\r\n\r\n\t\t\treturn (\r\n\t\t\t\ttMin.x <= bMin.x && bMax.x <= tMax.x &&\r\n\t\t\t\ttMin.y <= bMin.y && bMax.y <= tMax.y &&\r\n\t\t\t\ttMin.z <= bMin.z && bMax.z <= tMax.z\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this box intersects the given one.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Boolean} Whether the boxes intersect.\r\n\t\t */\r\n\r\n\t\tintersectsBox(b) {\r\n\r\n\t\t\tconst tMin = this.min;\r\n\t\t\tconst tMax = this.max;\r\n\t\t\tconst bMin = b.min;\r\n\t\t\tconst bMax = b.max;\r\n\r\n\t\t\treturn (\r\n\t\t\t\tbMax.x >= tMin.x &&\r\n\t\t\t\tbMax.y >= tMin.y &&\r\n\t\t\t\tbMax.z >= tMin.z &&\r\n\t\t\t\tbMin.x <= tMax.x &&\r\n\t\t\t\tbMin.y <= tMax.y &&\r\n\t\t\t\tbMin.z <= tMax.z\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this box intersects the given sphere.\r\n\t\t *\r\n\t\t * @param {Sphere} s - A sphere.\r\n\t\t * @return {Boolean} Whether the box intersects the sphere.\r\n\t\t */\r\n\r\n\t\tintersectsSphere(s) {\r\n\r\n\t\t\t// Find the point in this box that is closest to the sphere's center.\r\n\t\t\tconst closestPoint = this.clampPoint(s.center, v);\r\n\r\n\t\t\t// If that point is inside the sphere, it intersects this box.\r\n\t\t\treturn (closestPoint.distanceToSquared(s.center) <= (s.radius * s.radius));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this box intersects the given plane.\r\n\t\t *\r\n\t\t * Computes the minimum and maximum dot product values. If those values are on\r\n\t\t * the same side (back or front) of the plane, then there is no intersection.\r\n\t\t *\r\n\t\t * @param {Plane} p - A plane.\r\n\t\t * @return {Boolean} Whether the box intersects the plane.\r\n\t\t */\r\n\r\n\t\tintersectsPlane(p) {\r\n\r\n\t\t\tlet min, max;\r\n\r\n\t\t\tif(p.normal.x > 0) {\r\n\r\n\t\t\t\tmin = p.normal.x * this.min.x;\r\n\t\t\t\tmax = p.normal.x * this.max.x;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmin = p.normal.x * this.max.x;\r\n\t\t\t\tmax = p.normal.x * this.min.x;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(p.normal.y > 0) {\r\n\r\n\t\t\t\tmin += p.normal.y * this.min.y;\r\n\t\t\t\tmax += p.normal.y * this.max.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmin += p.normal.y * this.max.y;\r\n\t\t\t\tmax += p.normal.y * this.min.y;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(p.normal.z > 0) {\r\n\r\n\t\t\t\tmin += p.normal.z * this.min.z;\r\n\t\t\t\tmax += p.normal.z * this.max.z;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmin += p.normal.z * this.max.z;\r\n\t\t\t\tmax += p.normal.z * this.min.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn (min <= p.constant && max >= p.constant);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this box equals the given one.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Boolean} Whether this box equals the given one.\r\n\t\t */\r\n\r\n\t\tequals(b) {\r\n\r\n\t\t\treturn (b.min.equals(this.min) && b.max.equals(this.max));\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A vector with two components.\r\n\t */\r\n\r\n\tclass Vector2 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new vector.\r\n\t\t *\r\n\t\t * @param {Number} [x=0] - The X component.\r\n\t\t * @param {Number} [y=0] - The Y component.\r\n\t\t */\r\n\r\n\t\tconstructor(x = 0, y = 0) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The X component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.x = x;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Y component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.y = y;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The width. This is an alias for X.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tget width() {\r\n\r\n\t\t\treturn this.x;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the width.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tset width(value) {\r\n\r\n\t\t\treturn this.x = value;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The height. This is an alias for Y.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tget height() {\r\n\r\n\t\t\treturn this.y;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the height.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tset height(value) {\r\n\r\n\t\t\treturn this.y = value;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this vector\r\n\t\t *\r\n\t\t * @param {Number} x - The X component.\r\n\t\t * @param {Number} y - The Y component.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tset(x, y) {\r\n\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of another vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tcopy(v) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} A clone of this vector.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor(this.x, this.y);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies values from an array.\r\n\t\t *\r\n\t\t * @param {Number[]} array - An array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tfromArray(array, offset = 0) {\r\n\r\n\t\t\tthis.x = array[offset];\r\n\t\t\tthis.y = array[offset + 1];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores this vector in an array.\r\n\t\t *\r\n\t\t * @param {Array} [array] - A target array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Number[]} The array.\r\n\t\t */\r\n\r\n\t\ttoArray(array = [], offset = 0) {\r\n\r\n\t\t\tarray[offset] = this.x;\r\n\t\t\tarray[offset + 1] = this.y;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector2} v - The vector to add.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tadd(v) {\r\n\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scalar to this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to add.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\taddScalar(s) {\r\n\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the sum of two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector2} a - A vector.\r\n\t\t * @param {Vector2} b - Another vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\taddVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scaled vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector2} v - The vector to scale and add.\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\taddScaledVector(v, s) {\r\n\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a vector from this vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - The vector to subtract.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tsub(v) {\r\n\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a scalar from this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to subtract.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tsubScalar(s) {\r\n\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the difference between two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector2} a - A vector.\r\n\t\t * @param {Vector2} b - A second vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tsubVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with another vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tmultiply(v) {\r\n\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tmultiplyScalar(s) {\r\n\r\n\t\t\tthis.x *= s;\r\n\t\t\tthis.y *= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by another vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tdivide(v) {\r\n\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tdivideScalar(s) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies the given matrix to this vector.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - A matrix.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tapplyMatrix3(m) {\r\n\r\n\t\t\tconst x = this.x, y = this.y;\r\n\t\t\tconst e = m.elements;\r\n\r\n\t\t\tthis.x = e[0] * x + e[3] * y + e[6];\r\n\t\t\tthis.y = e[1] * x + e[4] * y + e[7];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the dot product with another vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Number} The dot product.\r\n\t\t */\r\n\r\n\t\tdot(v) {\r\n\r\n\t\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the cross product with another vector.\r\n\t\t *\r\n\t\t * This method calculates a scalar that would result from a regular 3D cross\r\n\t\t * product of the input vectors, while taking their Z values implicitly as 0.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Number} The cross product.\r\n\t\t */\r\n\r\n\t\tcross(v) {\r\n\r\n\t\t\treturn this.x * v.y - this.y * v.x;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tmanhattanLength() {\r\n\r\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The squared length.\r\n\t\t */\r\n\r\n\t\tlengthSquared() {\r\n\r\n\t\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tlength() {\r\n\r\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Number} The squared distance.\r\n\t\t */\r\n\r\n\t\tmanhattanDistanceTo(v) {\r\n\r\n\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Number} The squared distance.\r\n\t\t */\r\n\r\n\t\tdistanceToSquared(v) {\r\n\r\n\t\t\tconst dx = this.x - v.x;\r\n\t\t\tconst dy = this.y - v.y;\r\n\r\n\t\t\treturn dx * dx + dy * dy;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tdistanceTo(v) {\r\n\r\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Normalizes this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tnormalize() {\r\n\r\n\t\t\treturn this.divideScalar(this.length());\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the length of this vector.\r\n\t\t *\r\n\t\t * @param {Number} length - The new length.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tsetLength(length) {\r\n\r\n\t\t\treturn this.normalize().multiplyScalar(length);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the min value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tmin(v) {\r\n\r\n\t\t\tthis.x = Math.min(this.x, v.x);\r\n\t\t\tthis.y = Math.min(this.y, v.y);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * adopts the max value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tmax(v) {\r\n\r\n\t\t\tthis.x = Math.max(this.x, v.x);\r\n\t\t\tthis.y = Math.max(this.y, v.y);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clamps this vector.\r\n\t\t *\r\n\t\t * @param {Vector2} min - A vector, assumed to be smaller than max.\r\n\t\t * @param {Vector2} max - A vector, assumed to be greater than min.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tclamp(min, max) {\r\n\r\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\r\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Floors this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tfloor() {\r\n\r\n\t\t\tthis.x = Math.floor(this.x);\r\n\t\t\tthis.y = Math.floor(this.y);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Ceils this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tceil() {\r\n\r\n\t\t\tthis.x = Math.ceil(this.x);\r\n\t\t\tthis.y = Math.ceil(this.y);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rounds this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tround() {\r\n\r\n\t\t\tthis.x = Math.round(this.x);\r\n\t\t\tthis.y = Math.round(this.y);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Negates this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tnegate() {\r\n\r\n\t\t\tthis.x = -this.x;\r\n\t\t\tthis.y = -this.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the angle in radians with respect to the positive X-axis.\r\n\t\t *\r\n\t\t * @return {Number} The angle.\r\n\t\t */\r\n\r\n\t\tangle() {\r\n\r\n\t\t\tlet angle = Math.atan2(this.y, this.x);\r\n\r\n\t\t\tif(angle < 0) {\r\n\r\n\t\t\t\tangle += 2 * Math.PI;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn angle;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Lerps towards the given vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tlerp(v, alpha) {\r\n\r\n\t\t\tthis.x += (v.x - this.x) * alpha;\r\n\t\t\tthis.y += (v.y - this.y) * alpha;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the lerp result of the given vectors.\r\n\t\t *\r\n\t\t * @param {Vector2} v1 - A base vector.\r\n\t\t * @param {Vector2} v2 - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tlerpVectors(v1, v2, alpha) {\r\n\r\n\t\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rotates this vector around a given center.\r\n\t\t *\r\n\t\t * @param {Vector2} center - The center.\r\n\t\t * @param {Number} angle - The rotation in radians.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\trotateAround(center, angle) {\r\n\r\n\t\t\tconst c = Math.cos(angle), s = Math.sin(angle);\r\n\r\n\t\t\tconst x = this.x - center.x;\r\n\t\t\tconst y = this.y - center.y;\r\n\r\n\t\t\tthis.x = x * c - y * s + center.x;\r\n\t\t\tthis.y = x * s + y * c + center.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this vector equals the given one.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Boolean} Whether this vector equals the given one.\r\n\t\t */\r\n\r\n\t\tequals(v) {\r\n\r\n\t\t\treturn (v.x === this.x && v.y === this.y);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A cylindrical coordinate system.\r\n\t *\r\n\t * For details see: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\r\n\t */\n\n\t/**\r\n\t * A 3x3 matrix.\r\n\t */\r\n\r\n\tclass Matrix3 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new matrix.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\t/**\r\n\t\t\t * The matrix elements.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.elements = new Float32Array([\r\n\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t0, 1, 0,\r\n\t\t\t\t0, 0, 1\r\n\r\n\t\t\t]);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this matrix.\r\n\t\t *\r\n\t\t * @param {Number} m00 - The value of the first row, first column.\r\n\t\t * @param {Number} m01 - The value of the first row, second column.\r\n\t\t * @param {Number} m02 - The value of the first row, third column.\r\n\t\t * @param {Number} m10 - The value of the second row, first column.\r\n\t\t * @param {Number} m11 - The value of the second row, second column.\r\n\t\t * @param {Number} m12 - The value of the second row, third column.\r\n\t\t * @param {Number} m20 - The value of the third row, first column.\r\n\t\t * @param {Number} m21 - The value of the third row, second column.\r\n\t\t * @param {Number} m22 - The value of the third row, third column.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tset(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] = m00; te[3] = m01; te[6] = m02;\r\n\t\t\tte[1] = m10; te[4] = m11; te[7] = m12;\r\n\t\t\tte[2] = m20; te[5] = m21; te[8] = m22;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this matrix to the identity matrix.\r\n\t\t *\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tidentity() {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t0, 1, 0,\r\n\t\t\t\t0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a given matrix.\r\n\t\t *\r\n\t\t * @param {Matrix3} matrix - A matrix.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tcopy(matrix) {\r\n\r\n\t\t\tconst me = matrix.elements;\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] = me[0]; te[1] = me[1]; te[2] = me[2];\r\n\t\t\tte[3] = me[3]; te[4] = me[4]; te[5] = me[5];\r\n\t\t\tte[6] = me[6]; te[7] = me[7]; te[8] = me[8];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this matrix.\r\n\t\t *\r\n\t\t * @return {Matrix3} A clone of this matrix.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().fromArray(this.elements);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a given array.\r\n\t\t *\r\n\t\t * @param {Number[]} array - An array.\r\n\t\t * @param {Number} [offset=0] - An offset into the array.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tfromArray(array, offset = 0) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tlet i;\r\n\r\n\t\t\tfor(i = 0; i < 9; ++i) {\r\n\r\n\t\t\t\tte[i] = array[i + offset];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores this matrix in an array.\r\n\t\t *\r\n\t\t * @param {Number[]} [array] - A target array.\r\n\t\t * @param {Number} [offset=0] - An offset into the array.\r\n\t\t * @return {Number[]} The array.\r\n\t\t */\r\n\r\n\t\ttoArray(array = [], offset = 0) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tlet i;\r\n\r\n\t\t\tfor(i = 0; i < 9; ++i) {\r\n\r\n\t\t\t\tarray[i + offset] = te[i];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this matrix to the product of the given matrices.\r\n\t\t *\r\n\t\t * @param {Matrix3} a - A matrix.\r\n\t\t * @param {Matrix3} b - A matrix.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tmultiplyMatrices(a, b) {\r\n\r\n\t\t\tconst ae = a.elements;\r\n\t\t\tconst be = b.elements;\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst a11 = ae[0], a12 = ae[3], a13 = ae[6];\r\n\t\t\tconst a21 = ae[1], a22 = ae[4], a23 = ae[7];\r\n\t\t\tconst a31 = ae[2], a32 = ae[5], a33 = ae[8];\r\n\r\n\t\t\tconst b11 = be[0], b12 = be[3], b13 = be[6];\r\n\t\t\tconst b21 = be[1], b22 = be[4], b23 = be[7];\r\n\t\t\tconst b31 = be[2], b32 = be[5], b33 = be[8];\r\n\r\n\t\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31;\r\n\t\t\tte[3] = a11 * b12 + a12 * b22 + a13 * b32;\r\n\t\t\tte[6] = a11 * b13 + a12 * b23 + a13 * b33;\r\n\r\n\t\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31;\r\n\t\t\tte[4] = a21 * b12 + a22 * b22 + a23 * b32;\r\n\t\t\tte[7] = a21 * b13 + a22 * b23 + a23 * b33;\r\n\r\n\t\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31;\r\n\t\t\tte[5] = a31 * b12 + a32 * b22 + a33 * b32;\r\n\t\t\tte[8] = a31 * b13 + a32 * b23 + a33 * b33;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this matrix with a given one.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - A matrix.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tmultiply(m) {\r\n\r\n\t\t\treturn this.multiplyMatrices(this, m);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies a given matrix with this one.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - A matrix.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tpremultiply(m) {\r\n\r\n\t\t\treturn this.multiplyMatrices(m, this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this matrix with a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tmultiplyScalar(s) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] *= s; te[3] *= s; te[6] *= s;\r\n\t\t\tte[1] *= s; te[4] *= s; te[7] *= s;\r\n\t\t\tte[2] *= s; te[5] *= s; te[8] *= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the determinant of this matrix.\r\n\t\t *\r\n\t\t * @return {Number} The determinant.\r\n\t\t */\r\n\r\n\t\tdeterminant() {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst a = te[0], b = te[1], c = te[2];\r\n\t\t\tconst d = te[3], e = te[4], f = te[5];\r\n\t\t\tconst g = te[6], h = te[7], i = te[8];\r\n\r\n\t\t\treturn (\r\n\r\n\t\t\t\ta * e * i -\r\n\t\t\t\ta * f * h -\r\n\t\t\t\tb * d * i +\r\n\t\t\t\tb * f * g +\r\n\t\t\t\tc * d * h -\r\n\t\t\t\tc * e * g\r\n\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Inverts the given matrix and stores the result in this matrix.\r\n\t\t *\r\n\t\t * @param {Matrix3} matrix - The matrix that should be inverted.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tgetInverse(matrix) {\r\n\r\n\t\t\tconst me = matrix.elements;\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst n11 = me[0], n21 = me[1], n31 = me[2];\r\n\t\t\tconst n12 = me[3], n22 = me[4], n32 = me[5];\r\n\t\t\tconst n13 = me[6], n23 = me[7], n33 = me[8];\r\n\r\n\t\t\tconst t11 = n33 * n22 - n32 * n23;\r\n\t\t\tconst t12 = n32 * n13 - n33 * n12;\r\n\t\t\tconst t13 = n23 * n12 - n22 * n13;\r\n\r\n\t\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13;\r\n\r\n\t\t\tlet invDet;\r\n\r\n\t\t\tif(det !== 0) {\r\n\r\n\t\t\t\tinvDet = 1.0 / det;\r\n\r\n\t\t\t\tte[0] = t11 * invDet;\r\n\t\t\t\tte[1] = (n31 * n23 - n33 * n21) * invDet;\r\n\t\t\t\tte[2] = (n32 * n21 - n31 * n22) * invDet;\r\n\r\n\t\t\t\tte[3] = t12 * invDet;\r\n\t\t\t\tte[4] = (n33 * n11 - n31 * n13) * invDet;\r\n\t\t\t\tte[5] = (n31 * n12 - n32 * n11) * invDet;\r\n\r\n\t\t\t\tte[6] = t13 * invDet;\r\n\t\t\t\tte[7] = (n21 * n13 - n23 * n11) * invDet;\r\n\t\t\t\tte[8] = (n22 * n11 - n21 * n12) * invDet;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error(\"Can't invert matrix, determinant is zero\", matrix);\r\n\r\n\t\t\t\tthis.identity();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Transposes this matrix.\r\n\t\t *\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\ttranspose() {\r\n\r\n\t\t\tconst me = this.elements;\r\n\r\n\t\t\tlet t;\r\n\r\n\t\t\tt = me[1]; me[1] = me[3]; me[3] = t;\r\n\t\t\tt = me[2]; me[2] = me[6]; me[6] = t;\r\n\t\t\tt = me[5]; me[5] = me[7]; me[7] = t;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Scales this matrix.\r\n\t\t *\r\n\t\t * @param {Number} sx - The X scale.\r\n\t\t * @param {Number} sy - The Y scale.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tscale(sx, sy) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] *= sx; te[3] *= sx; te[6] *= sx;\r\n\t\t\tte[1] *= sy; te[4] *= sy; te[7] *= sy;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rotates this matrix.\r\n\t\t *\r\n\t\t * @param {Number} theta - The rotation.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\trotate(theta) {\r\n\r\n\t\t\tconst c = Math.cos(theta);\r\n\t\t\tconst s = Math.sin(theta);\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst a11 = te[0], a12 = te[3], a13 = te[6];\r\n\t\t\tconst a21 = te[1], a22 = te[4], a23 = te[7];\r\n\r\n\t\t\tte[0] = c * a11 + s * a21;\r\n\t\t\tte[3] = c * a12 + s * a22;\r\n\t\t\tte[6] = c * a13 + s * a23;\r\n\r\n\t\t\tte[1] = -s * a11 + c * a21;\r\n\t\t\tte[4] = -s * a12 + c * a22;\r\n\t\t\tte[7] = -s * a13 + c * a23;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Translates this matrix.\r\n\t\t *\r\n\t\t * @param {Number} tx - The X offset.\r\n\t\t * @param {Number} ty - The Y offset.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\ttranslate(tx, ty) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] += tx * te[2]; te[3] += tx * te[5]; te[6] += tx * te[8];\r\n\t\t\tte[1] += ty * te[2]; te[4] += ty * te[5]; te[7] += ty * te[8];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this matrix equals the given one.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - A matrix.\r\n\t\t * @return {Boolean} Whether the matrix are equal.\r\n\t\t */\r\n\r\n\t\tequals(m) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tlet result = true;\r\n\t\t\tlet i;\r\n\r\n\t\t\tfor(i = 0; result && i < 9; ++i) {\r\n\r\n\t\t\t\tif(te[i] !== me[i]) {\r\n\r\n\t\t\t\t\tresult = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An enumeration of Euler rotation orders.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {String} XYZ - X -> Y -> Z.\r\n\t * @property {String} YZX - Y -> Z -> X.\r\n\t * @property {String} ZXY - Z -> X -> Y.\r\n\t * @property {String} XZY - X -> Z -> Y.\r\n\t * @property {String} YXZ - Y -> X -> Z.\r\n\t * @property {String} ZYX - Z -> Y -> X.\r\n\t */\r\n\r\n\tconst RotationOrder = {\r\n\r\n\t\tXYZ: \"XYZ\",\r\n\t\tYZX: \"YZX\",\r\n\t\tZXY: \"ZXY\",\r\n\t\tXZY: \"XZY\",\r\n\t\tYXZ: \"YXZ\",\r\n\t\tZYX: \"ZYX\"\r\n\r\n\t};\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v$3 = new Vector3();\r\n\r\n\t/**\r\n\t * A quaternion.\r\n\t */\r\n\r\n\tclass Quaternion {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new quaternion.\r\n\t\t *\r\n\t\t * @param {Number} [x=0] - The X component.\r\n\t\t * @param {Number} [y=0] - The Y component.\r\n\t\t * @param {Number} [z=0] - The Z component.\r\n\t\t * @param {Number} [w=0] - The W component.\r\n\t\t */\r\n\r\n\t\tconstructor(x = 0, y = 0, z = 0, w = 0) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The X component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.x = x;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Y component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Z component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.z = z;\r\n\r\n\t\t\t/**\r\n\t\t\t * The W component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.w = w;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the components of this quaternion.\r\n\t\t *\r\n\t\t * @param {Number} x - The X component.\r\n\t\t * @param {Number} y - The Y component.\r\n\t\t * @param {Number} z - The Z component.\r\n\t\t * @param {Number} w - The W component.\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tset(x, y, z, w) {\r\n\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\t\tthis.w = w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the components of the given quaternion.\r\n\t\t *\r\n\t\t * @param {Quaternion} q - The quaternion.\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tcopy(q) {\r\n\r\n\t\t\tthis.x = q.x;\r\n\t\t\tthis.y = q.y;\r\n\t\t\tthis.z = q.z;\r\n\t\t\tthis.w = q.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this quaternion.\r\n\t\t *\r\n\t\t * @return {Quaternion} The cloned quaternion.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor(this.x, this.y, this.z, this.w);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies values from an array.\r\n\t\t *\r\n\t\t * @param {Number[]} array - An array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tfromArray(array, offset = 0) {\r\n\r\n\t\t\tthis.x = array[offset];\r\n\t\t\tthis.y = array[offset + 1];\r\n\t\t\tthis.z = array[offset + 2];\r\n\t\t\tthis.w = array[offset + 3];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores this quaternion in an array.\r\n\t\t *\r\n\t\t * @param {Array} [array] - A target array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Number[]} The array.\r\n\t\t */\r\n\r\n\t\ttoArray(array = [], offset = 0) {\r\n\r\n\t\t\tarray[offset] = this.x;\r\n\t\t\tarray[offset + 1] = this.y;\r\n\t\t\tarray[offset + 2] = this.z;\r\n\t\t\tarray[offset + 3] = this.w;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the components of this quaternion based on the given Euler angles.\r\n\t\t *\r\n\t\t * For more details see: https://goo.gl/XRD1kr\r\n\t\t *\r\n\t\t * @param {Euler} euler - The euler angles.\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tsetFromEuler(euler) {\r\n\r\n\t\t\tconst x = euler.x;\r\n\t\t\tconst y = euler.y;\r\n\t\t\tconst z = euler.z;\r\n\r\n\t\t\tconst cos = Math.cos;\r\n\t\t\tconst sin = Math.sin;\r\n\r\n\t\t\tconst c1 = cos(x / 2);\r\n\t\t\tconst c2 = cos(y / 2);\r\n\t\t\tconst c3 = cos(z / 2);\r\n\r\n\t\t\tconst s1 = sin(x / 2);\r\n\t\t\tconst s2 = sin(y / 2);\r\n\t\t\tconst s3 = sin(z / 2);\r\n\r\n\t\t\tswitch(euler.order) {\r\n\r\n\t\t\t\tcase RotationOrder.XYZ:\r\n\t\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase RotationOrder.YXZ:\r\n\t\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase RotationOrder.ZXY:\r\n\t\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase RotationOrder.ZYX:\r\n\t\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase RotationOrder.YZX:\r\n\t\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase RotationOrder.XZY:\r\n\t\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the components of this quaternion based on a given axis angle.\r\n\t\t *\r\n\t\t * For more information see:\r\n\t\t *  http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\t\t *\r\n\t\t * @param {Vector3} axis - The axis. Assumed to be normalized.\r\n\t\t * @param {Number} angle - The angle in radians.\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tsetFromAxisAngle(axis, angle) {\r\n\r\n\t\t\tconst halfAngle = angle / 2.0;\r\n\t\t\tconst s = Math.sin(halfAngle);\r\n\r\n\t\t\tthis.x = axis.x * s;\r\n\t\t\tthis.y = axis.y * s;\r\n\t\t\tthis.z = axis.z * s;\r\n\t\t\tthis.w = Math.cos(halfAngle);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the components of this quaternion based on a given rotation matrix.\r\n\t\t *\r\n\t\t * For more information see:\r\n\t\t *  http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\t\t *\r\n\t\t * @param {Matrix4} m - The rotation matrix. The upper 3x3 is assumed to be a pure rotation matrix (i.e. unscaled).\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tsetFromRotationMatrix(m) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\r\n\t\t\tconst m00 = te[0], m01 = te[4], m02 = te[8];\r\n\t\t\tconst m10 = te[1], m11 = te[5], m12 = te[9];\r\n\t\t\tconst m20 = te[2], m21 = te[6], m22 = te[10];\r\n\r\n\t\t\tconst trace = m00 + m11 + m22;\r\n\r\n\t\t\tlet s;\r\n\r\n\t\t\tif(trace > 0) {\r\n\r\n\t\t\t\ts = 0.5 / Math.sqrt(trace + 1.0);\r\n\r\n\t\t\t\tthis.w = 0.25 / s;\r\n\t\t\t\tthis.x = (m21 - m12) * s;\r\n\t\t\t\tthis.y = (m02 - m20) * s;\r\n\t\t\t\tthis.z = (m10 - m01) * s;\r\n\r\n\t\t\t} else if(m00 > m11 && m00 > m22) {\r\n\r\n\t\t\t\ts = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);\r\n\r\n\t\t\t\tthis.w = (m21 - m12) / s;\r\n\t\t\t\tthis.x = 0.25 * s;\r\n\t\t\t\tthis.y = (m01 + m10) / s;\r\n\t\t\t\tthis.z = (m02 + m20) / s;\r\n\r\n\t\t\t} else if(m11 > m22) {\r\n\r\n\t\t\t\ts = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);\r\n\r\n\t\t\t\tthis.w = (m02 - m20) / s;\r\n\t\t\t\tthis.x = (m01 + m10) / s;\r\n\t\t\t\tthis.y = 0.25 * s;\r\n\t\t\t\tthis.z = (m12 + m21) / s;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ts = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);\r\n\r\n\t\t\t\tthis.w = (m10 - m01) / s;\r\n\t\t\t\tthis.x = (m02 + m20) / s;\r\n\t\t\t\tthis.y = (m12 + m21) / s;\r\n\t\t\t\tthis.z = 0.25 * s;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the components of this quaternion based on unit vectors.\r\n\t\t *\r\n\t\t * @param {Vector3} vFrom - A unit vector. Assumed to be normalized.\r\n\t\t * @param {Vector3} vTo - A unit vector. Assumed to be normalized.\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tsetFromUnitVectors(vFrom, vTo) {\r\n\r\n\t\t\tlet r = vFrom.dot(vTo) + 1;\r\n\r\n\t\t\tif(r < 1e-6) {\r\n\r\n\t\t\t\tr = 0;\r\n\r\n\t\t\t\tif(Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\r\n\r\n\t\t\t\t\tv$3.set(-vFrom.y, vFrom.x, 0);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv$3.set(0, -vFrom.z, vFrom.y);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv$3.crossVectors(vFrom, vTo);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.x = v$3.x;\r\n\t\t\tthis.y = v$3.y;\r\n\t\t\tthis.z = v$3.z;\r\n\t\t\tthis.w = r;\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the angle to another quaternion.\r\n\t\t *\r\n\t\t * @param {Quaternion} q - A quaternion.\r\n\t\t * @return {Number} The angle in radians.\r\n\t\t */\r\n\r\n\t\tangleTo(q) {\r\n\r\n\t\t\treturn 2.0 * Math.acos(Math.abs(Math.min(Math.max(this.dot(q), -1.0), 1.0)));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rotates this quaternion towards the given one by a given step size.\r\n\t\t *\r\n\t\t * @param {Quaternion} q - The target quaternion.\r\n\t\t * @param {Number} step - The step size.\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\trotateTowards(q, step) {\r\n\r\n\t\t\tconst angle = this.angleTo(q);\r\n\r\n\t\t\tif(angle !== 0.0) {\r\n\r\n\t\t\t\tthis.slerp(q, Math.min(1.0, step / angle));\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Inverts this quaternion. The quaternion is assumed to have unit length.\r\n\t\t *\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tinvert() {\r\n\r\n\t\t\treturn this.conjugate();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Conjugates this quaternion.\r\n\t\t *\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tconjugate() {\r\n\r\n\t\t\tthis.x *= -1;\r\n\t\t\tthis.y *= -1;\r\n\t\t\tthis.z *= -1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared length of this quaternion.\r\n\t\t *\r\n\t\t * @return {Number} The squared length.\r\n\t\t */\r\n\r\n\t\tlengthSquared() {\r\n\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the length of this quaternion.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tlength() {\r\n\r\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Normalizes this quaternion.\r\n\t\t *\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tnormalize() {\r\n\r\n\t\t\tconst l = this.length();\r\n\r\n\t\t\tlet invLength;\r\n\r\n\t\t\tif(l === 0) {\r\n\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\t\t\tthis.w = 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tinvLength = 1.0 / l;\r\n\r\n\t\t\t\tthis.x = this.x * invLength;\r\n\t\t\t\tthis.y = this.y * invLength;\r\n\t\t\t\tthis.z = this.z * invLength;\r\n\t\t\t\tthis.w = this.w * invLength;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the dot product with a given vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Number} The dot product.\r\n\t\t */\r\n\r\n\t\tdot(v) {\r\n\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies the given quaternions and stores the result in this quaternion.\r\n\t\t *\r\n\t\t * For more details see:\r\n\t\t *  http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\t\t *\r\n\t\t * @param {Quaternion} a - A quaternion.\r\n\t\t * @param {Quaternion} b - Another quaternion.\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tmultiplyQuaternions(a, b) {\r\n\r\n\t\t\tconst qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;\r\n\t\t\tconst qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\r\n\r\n\t\t\tthis.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\t\tthis.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\t\tthis.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\t\tthis.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this quaternion with the given one and stores the result in\r\n\t\t * this quaternion.\r\n\t\t *\r\n\t\t * @param {Quaternion} q - A quaternion.\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tmultiply(q) {\r\n\r\n\t\t\treturn this.multiplyQuaternions(this, q);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies the given quaternion with this one and stores the result in\r\n\t\t * this quaternion.\r\n\t\t *\r\n\t\t * @param {Quaternion} q - A quaternion.\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tpremultiply(q) {\r\n\r\n\t\t\treturn this.multiplyQuaternions(q, this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Performs a spherical linear interpolation towards the given quaternion.\r\n\t\t *\r\n\t\t * For more details see:\r\n\t\t *  http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\t\t *\r\n\t\t * @param {Quaternion} q - A quaternion.\r\n\t\t * @param {Number} t - The slerp factor.\r\n\t\t * @return {Quaternion} This quaternion.\r\n\t\t */\r\n\r\n\t\tslerp(q, t) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\r\n\r\n\t\t\tlet cosHalfTheta, sinHalfThetaSquared, sinHalfTheta, halfTheta;\r\n\t\t\tlet s, ratioA, ratioB;\r\n\r\n\t\t\tif(t === 1) {\r\n\r\n\t\t\t\tthis.copy(q);\r\n\r\n\t\t\t} else if(t > 0) {\r\n\r\n\t\t\t\tcosHalfTheta = w * q.w + x * q.x + y * q.y + z * q.z;\r\n\r\n\t\t\t\tif(cosHalfTheta < 0.0) {\r\n\r\n\t\t\t\t\tthis.w = -q.w;\r\n\t\t\t\t\tthis.x = -q.x;\r\n\t\t\t\t\tthis.y = -q.y;\r\n\t\t\t\t\tthis.z = -q.z;\r\n\r\n\t\t\t\t\tcosHalfTheta = -cosHalfTheta;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.copy(q);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(cosHalfTheta >= 1.0) {\r\n\r\n\t\t\t\t\tthis.w = w;\r\n\t\t\t\t\tthis.x = x;\r\n\t\t\t\t\tthis.y = y;\r\n\t\t\t\t\tthis.z = z;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsinHalfThetaSquared = 1.0 - cosHalfTheta * cosHalfTheta;\r\n\t\t\t\t\ts = 1.0 - t;\r\n\r\n\t\t\t\t\tif(sinHalfThetaSquared <= Number.EPSILON) {\r\n\r\n\t\t\t\t\t\tthis.w = s * w + t * this.w;\r\n\t\t\t\t\t\tthis.x = s * x + t * this.x;\r\n\t\t\t\t\t\tthis.y = s * y + t * this.y;\r\n\t\t\t\t\t\tthis.z = s * z + t * this.z;\r\n\r\n\t\t\t\t\t\tthis.normalize();\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tsinHalfTheta = Math.sqrt(sinHalfThetaSquared);\r\n\t\t\t\t\t\thalfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\r\n\t\t\t\t\t\tratioA = Math.sin(s * halfTheta) / sinHalfTheta;\r\n\t\t\t\t\t\tratioB = Math.sin(t * halfTheta) / sinHalfTheta;\r\n\r\n\t\t\t\t\t\tthis.w = (w * ratioA + this.w * ratioB);\r\n\t\t\t\t\t\tthis.x = (x * ratioA + this.x * ratioB);\r\n\t\t\t\t\t\tthis.y = (y * ratioA + this.y * ratioB);\r\n\t\t\t\t\t\tthis.z = (z * ratioA + this.z * ratioB);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this quaternions equals the given one.\r\n\t\t *\r\n\t\t * @param {Quaternion} q - A quaternion.\r\n\t\t * @return {Boolean} Whether the quaternions are equal.\r\n\t\t */\r\n\r\n\t\tequals(q) {\r\n\r\n\t\t\treturn (q.x === this.x) && (q.y === this.y) && (q.z === this.z) && (q.w === this.w);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Performs a spherical linear interpolation.\r\n\t\t *\r\n\t\t * @param {Quaternion} qa - The base quaternion.\r\n\t\t * @param {Quaternion} qb - The target quaternion.\r\n\t\t * @param {Quaternion} qr - A quaternion to store the result in.\r\n\t\t * @param {Number} t - The slerp factor.\r\n\t\t * @return {Quaternion} The resulting quaternion.\r\n\t\t */\r\n\r\n\t\tstatic slerp(qa, qb, qr, t) {\r\n\r\n\t\t\treturn qr.copy(qa).slerp(qb, t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Performs an array-based spherical linear interpolation.\r\n\t\t *\r\n\t\t * @param {Number[]} dst - An array to store the result in.\r\n\t\t * @param {Number} dstOffset - An offset into the destination array.\r\n\t\t * @param {Number[]} src0 - An array that contains the base quaternion values.\r\n\t\t * @param {Number} srcOffset0 - An offset into the base array.\r\n\t\t * @param {Number[]} src1 - An array that contains the target quaternion values.\r\n\t\t * @param {Number} srcOffset1 - An offset into the target array.\r\n\t\t * @param {Number} t - The slerp factor.\r\n\t\t */\r\n\r\n\t\tstatic slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\r\n\r\n\t\t\tconst x1 = src1[srcOffset1];\r\n\t\t\tconst y1 = src1[srcOffset1 + 1];\r\n\t\t\tconst z1 = src1[srcOffset1 + 2];\r\n\t\t\tconst w1 = src1[srcOffset1 + 3];\r\n\r\n\t\t\tlet x0 = src0[srcOffset0];\r\n\t\t\tlet y0 = src0[srcOffset0 + 1];\r\n\t\t\tlet z0 = src0[srcOffset0 + 2];\r\n\t\t\tlet w0 = src0[srcOffset0 + 3];\r\n\r\n\t\t\tlet s, f;\r\n\t\t\tlet sin, cos, sqrSin;\r\n\t\t\tlet dir, len, tDir;\r\n\r\n\t\t\tif(w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\r\n\r\n\t\t\t\ts = 1.0 - t;\r\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;\r\n\r\n\t\t\t\tdir = (cos >= 0) ? 1 : -1;\r\n\t\t\t\tsqrSin = 1.0 - cos * cos;\r\n\r\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems.\r\n\t\t\t\tif(sqrSin > Number.EPSILON) {\r\n\r\n\t\t\t\t\tsin = Math.sqrt(sqrSin);\r\n\t\t\t\t\tlen = Math.atan2(sin, cos * dir);\r\n\r\n\t\t\t\t\ts = Math.sin(s * len) / sin;\r\n\t\t\t\t\tt = Math.sin(t * len) / sin;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttDir = t * dir;\r\n\r\n\t\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\t\tw0 = w0 * s + w1 * tDir;\r\n\r\n\t\t\t\t// Normalize in case a lerp has just been performed.\r\n\t\t\t\tif(s === 1.0 - t) {\r\n\r\n\t\t\t\t\tf = 1.0 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\r\n\r\n\t\t\t\t\tx0 *= f;\r\n\t\t\t\t\ty0 *= f;\r\n\t\t\t\t\tz0 *= f;\r\n\t\t\t\t\tw0 *= f;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdst[dstOffset] = x0;\r\n\t\t\tdst[dstOffset + 1] = y0;\r\n\t\t\tdst[dstOffset + 2] = z0;\r\n\t\t\tdst[dstOffset + 3] = w0;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst a$2 = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b$2 = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst c = new Vector3();\r\n\r\n\t/**\r\n\t * A 4x4 matrix.\r\n\t */\r\n\r\n\tclass Matrix4 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new matrix.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\t/**\r\n\t\t\t * The matrix elements.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.elements = new Float32Array([\r\n\r\n\t\t\t\t1, 0, 0, 0,\r\n\t\t\t\t0, 1, 0, 0,\r\n\t\t\t\t0, 0, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t]);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this matrix.\r\n\t\t *\r\n\t\t * @param {Number} n00 - The value of the first row, first column.\r\n\t\t * @param {Number} n01 - The value of the first row, second column.\r\n\t\t * @param {Number} n02 - The value of the first row, third column.\r\n\t\t * @param {Number} n03 - The value of the first row, fourth column.\r\n\t\t * @param {Number} n10 - The value of the second row, first column.\r\n\t\t * @param {Number} n11 - The value of the second row, second column.\r\n\t\t * @param {Number} n12 - The value of the second row, third column.\r\n\t\t * @param {Number} n13 - The value of the second row, fourth column.\r\n\t\t * @param {Number} n20 - The value of the third row, first column.\r\n\t\t * @param {Number} n21 - The value of the third row, second column.\r\n\t\t * @param {Number} n22 - The value of the third row, third column.\r\n\t\t * @param {Number} n23 - The value of the third row, fourth column.\r\n\t\t * @param {Number} n30 - The value of the fourth row, first column.\r\n\t\t * @param {Number} n31 - The value of the fourth row, second column.\r\n\t\t * @param {Number} n32 - The value of the fourth row, third column.\r\n\t\t * @param {Number} n33 - The value of the fourth row, fourth column.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tset(n00, n01, n02, n03, n10, n11, n12, n13, n20, n21, n22, n23, n30, n31, n32, n33) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] = n00; te[4] = n01; te[8] = n02; te[12] = n03;\r\n\t\t\tte[1] = n10; te[5] = n11; te[9] = n12; te[13] = n13;\r\n\t\t\tte[2] = n20; te[6] = n21; te[10] = n22; te[14] = n23;\r\n\t\t\tte[3] = n30; te[7] = n31; te[11] = n32; te[15] = n33;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this matrix to the identity matrix.\r\n\t\t *\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tidentity() {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, 0, 0, 0,\r\n\t\t\t\t0, 1, 0, 0,\r\n\t\t\t\t0, 0, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a given matrix.\r\n\t\t *\r\n\t\t * @param {Matrix4} matrix - A matrix.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tcopy(matrix) {\r\n\r\n\t\t\tconst me = matrix.elements;\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] = me[0]; te[1] = me[1]; te[2] = me[2]; te[3] = me[3];\r\n\t\t\tte[4] = me[4]; te[5] = me[5]; te[6] = me[6]; te[7] = me[7];\r\n\t\t\tte[8] = me[8]; te[9] = me[9]; te[10] = me[10]; te[11] = me[11];\r\n\t\t\tte[12] = me[12]; te[13] = me[13]; te[14] = me[14]; te[15] = me[15];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this matrix.\r\n\t\t *\r\n\t\t * @return {Matrix4} A clone of this matrix.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().fromArray(this.elements);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a given array.\r\n\t\t *\r\n\t\t * @param {Number[]} array - An array.\r\n\t\t * @param {Number} [offset=0] - An offset into the array.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tfromArray(array, offset = 0) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tlet i;\r\n\r\n\t\t\tfor(i = 0; i < 16; ++i) {\r\n\r\n\t\t\t\tte[i] = array[i + offset];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores this matrix in an array.\r\n\t\t *\r\n\t\t * @param {Number[]} [array] - A target array.\r\n\t\t * @param {Number} [offset=0] - An offset into the array.\r\n\t\t * @return {Number[]} The array.\r\n\t\t */\r\n\r\n\t\ttoArray(array = [], offset = 0) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tlet i;\r\n\r\n\t\t\tfor(i = 0; i < 16; ++i) {\r\n\r\n\t\t\t\tarray[i + offset] = te[i];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the largest scale.\r\n\t\t *\r\n\t\t * @return {Number} The largest scale of the three axes.\r\n\t\t */\r\n\r\n\t\tgetMaxScaleOnAxis() {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\r\n\t\t\tconst scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\r\n\t\t\tconst scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\r\n\r\n\t\t\treturn Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the position values of a given matrix.\r\n\t\t *\r\n\t\t * @param {Matrix4} matrix - A matrix.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tcopyPosition(matrix) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst me = matrix.elements;\r\n\r\n\t\t\tte[12] = me[12];\r\n\t\t\tte[13] = me[13];\r\n\t\t\tte[14] = me[14];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the position values of this matrix.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A position.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tsetPosition(p) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[12] = p.x;\r\n\t\t\tte[13] = p.y;\r\n\t\t\tte[14] = p.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Extracts the basis from this matrix.\r\n\t\t *\r\n\t\t * @param {Vector3} xAxis - A vector to store the X-axis column in.\r\n\t\t * @param {Vector3} yAxis - A vector to store the Y-axis column in.\r\n\t\t * @param {Vector3} zAxis - A vector to store the Z-axis column in.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\textractBasis(xAxis, yAxis, zAxis) {\r\n\r\n\t\t\txAxis.setFromMatrixColumn(this, 0);\r\n\t\t\tyAxis.setFromMatrixColumn(this, 1);\r\n\t\t\tzAxis.setFromMatrixColumn(this, 2);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the basis of this matrix.\r\n\t\t *\r\n\t\t * @param {Vector3} xAxis - The X-axis.\r\n\t\t * @param {Vector3} yAxis - The Y-axis.\r\n\t\t * @param {Vector3} zAxis - The Z-axis.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakeBasis(xAxis, yAxis, zAxis) {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Extracts the rotation from a given matrix.\r\n\t\t *\r\n\t\t * This method does not support reflection matrices.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\textractRotation(m) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tconst scaleX = 1.0 / a$2.setFromMatrixColumn(m, 0).length();\r\n\t\t\tconst scaleY = 1.0 / a$2.setFromMatrixColumn(m, 1).length();\r\n\t\t\tconst scaleZ = 1.0 / a$2.setFromMatrixColumn(m, 2).length();\r\n\r\n\t\t\tte[0] = me[0] * scaleX;\r\n\t\t\tte[1] = me[1] * scaleX;\r\n\t\t\tte[2] = me[2] * scaleX;\r\n\t\t\tte[3] = 0;\r\n\r\n\t\t\tte[4] = me[4] * scaleY;\r\n\t\t\tte[5] = me[5] * scaleY;\r\n\t\t\tte[6] = me[6] * scaleY;\r\n\t\t\tte[7] = 0;\r\n\r\n\t\t\tte[8] = me[8] * scaleZ;\r\n\t\t\tte[9] = me[9] * scaleZ;\r\n\t\t\tte[10] = me[10] * scaleZ;\r\n\t\t\tte[11] = 0;\r\n\r\n\t\t\tte[12] = 0;\r\n\t\t\tte[13] = 0;\r\n\t\t\tte[14] = 0;\r\n\t\t\tte[15] = 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the matrix rotation based on the given Euler angles.\r\n\t\t *\r\n\t\t * @param {Euler} euler - The euler angles.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakeRotationFromEuler(euler) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst x = euler.x;\r\n\t\t\tconst y = euler.y;\r\n\t\t\tconst z = euler.z;\r\n\r\n\t\t\tconst a = Math.cos(x), b = Math.sin(x);\r\n\t\t\tconst c = Math.cos(y), d = Math.sin(y);\r\n\t\t\tconst e = Math.cos(z), f = Math.sin(z);\r\n\r\n\t\t\tlet ae, af, be, bf;\r\n\t\t\tlet ce, cf, de, df;\r\n\t\t\tlet ac, ad, bc, bd;\r\n\r\n\t\t\tswitch(euler.order) {\r\n\r\n\t\t\t\tcase RotationOrder.XYZ: {\r\n\r\n\t\t\t\t\tae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\t\t\tte[0] = c * e;\r\n\t\t\t\t\tte[4] = -c * f;\r\n\t\t\t\t\tte[8] = d;\r\n\r\n\t\t\t\t\tte[1] = af + be * d;\r\n\t\t\t\t\tte[5] = ae - bf * d;\r\n\t\t\t\t\tte[9] = -b * c;\r\n\r\n\t\t\t\t\tte[2] = bf - ae * d;\r\n\t\t\t\t\tte[6] = be + af * d;\r\n\t\t\t\t\tte[10] = a * c;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase RotationOrder.YXZ: {\r\n\r\n\t\t\t\t\tce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\t\t\tte[0] = ce + df * b;\r\n\t\t\t\t\tte[4] = de * b - cf;\r\n\t\t\t\t\tte[8] = a * d;\r\n\r\n\t\t\t\t\tte[1] = a * f;\r\n\t\t\t\t\tte[5] = a * e;\r\n\t\t\t\t\tte[9] = -b;\r\n\r\n\t\t\t\t\tte[2] = cf * b - de;\r\n\t\t\t\t\tte[6] = df + ce * b;\r\n\t\t\t\t\tte[10] = a * c;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase RotationOrder.ZXY: {\r\n\r\n\t\t\t\t\tce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\t\t\tte[0] = ce - df * b;\r\n\t\t\t\t\tte[4] = -a * f;\r\n\t\t\t\t\tte[8] = de + cf * b;\r\n\r\n\t\t\t\t\tte[1] = cf + de * b;\r\n\t\t\t\t\tte[5] = a * e;\r\n\t\t\t\t\tte[9] = df - ce * b;\r\n\r\n\t\t\t\t\tte[2] = -a * d;\r\n\t\t\t\t\tte[6] = b;\r\n\t\t\t\t\tte[10] = a * c;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase RotationOrder.ZYX: {\r\n\r\n\t\t\t\t\tae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\t\t\tte[0] = c * e;\r\n\t\t\t\t\tte[4] = be * d - af;\r\n\t\t\t\t\tte[8] = ae * d + bf;\r\n\r\n\t\t\t\t\tte[1] = c * f;\r\n\t\t\t\t\tte[5] = bf * d + ae;\r\n\t\t\t\t\tte[9] = af * d - be;\r\n\r\n\t\t\t\t\tte[2] = -d;\r\n\t\t\t\t\tte[6] = b * c;\r\n\t\t\t\t\tte[10] = a * c;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase RotationOrder.YZX: {\r\n\r\n\t\t\t\t\tac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\t\t\tte[0] = c * e;\r\n\t\t\t\t\tte[4] = bd - ac * f;\r\n\t\t\t\t\tte[8] = bc * f + ad;\r\n\r\n\t\t\t\t\tte[1] = f;\r\n\t\t\t\t\tte[5] = a * e;\r\n\t\t\t\t\tte[9] = -b * e;\r\n\r\n\t\t\t\t\tte[2] = -d * e;\r\n\t\t\t\t\tte[6] = ad * f + bc;\r\n\t\t\t\t\tte[10] = ac - bd * f;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase RotationOrder.XZY: {\r\n\r\n\t\t\t\t\tac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\t\t\tte[0] = c * e;\r\n\t\t\t\t\tte[4] = -f;\r\n\t\t\t\t\tte[8] = d * e;\r\n\r\n\t\t\t\t\tte[1] = ac * f + bd;\r\n\t\t\t\t\tte[5] = a * e;\r\n\t\t\t\t\tte[9] = ad * f - bc;\r\n\r\n\t\t\t\t\tte[2] = bc * f - ad;\r\n\t\t\t\t\tte[6] = b * e;\r\n\t\t\t\t\tte[10] = bd * f + ac;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Bottom row.\r\n\t\t\tte[3] = 0;\r\n\t\t\tte[7] = 0;\r\n\t\t\tte[11] = 0;\r\n\r\n\t\t\t// Last column.\r\n\t\t\tte[12] = 0;\r\n\t\t\tte[13] = 0;\r\n\t\t\tte[14] = 0;\r\n\t\t\tte[15] = 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the matrix rotation based on the given quaternion.\r\n\t\t *\r\n\t\t * @param {Quaternion} q - The quaternion.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakeRotationFromQuaternion(q) {\r\n\r\n\t\t\treturn this.compose(a$2.set(0, 0, 0), q, b$2.set(1, 1, 1));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a rotation that looks at the given target.\r\n\t\t *\r\n\t\t * @param {Vector3} eye - The position of the eye.\r\n\t\t * @param {Vector3} target - The target to look at.\r\n\t\t * @param {Vector3} up - The up vector.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tlookAt(eye, target, up) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst x = a$2, y = b$2, z = c;\r\n\r\n\t\t\tz.subVectors(eye, target);\r\n\r\n\t\t\tif(z.lengthSquared() === 0) {\r\n\r\n\t\t\t\t// Eye and target are at the same position.\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tz.normalize();\r\n\t\t\tx.crossVectors(up, z);\r\n\r\n\t\t\tif(x.lengthSquared() === 0) {\r\n\r\n\t\t\t\t// Up and z are parallel.\r\n\t\t\t\tif(Math.abs(up.z) === 1) {\r\n\r\n\t\t\t\t\tz.x += 1e-4;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz.z += 1e-4;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tz.normalize();\r\n\t\t\t\tx.crossVectors(up, z);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.normalize();\r\n\t\t\ty.crossVectors(z, x);\r\n\r\n\t\t\tte[0] = x.x; te[4] = y.x; te[8] = z.x;\r\n\t\t\tte[1] = x.y; te[5] = y.y; te[9] = z.y;\r\n\t\t\tte[2] = x.z; te[6] = y.z; te[10] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this matrix to the product of the given matrices.\r\n\t\t *\r\n\t\t * @param {Matrix4} a - A matrix.\r\n\t\t * @param {Matrix4} b - A matrix.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmultiplyMatrices(a, b) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst ae = a.elements;\r\n\t\t\tconst be = b.elements;\r\n\r\n\t\t\tconst a00 = ae[0], a01 = ae[4], a02 = ae[8], a03 = ae[12];\r\n\t\t\tconst a10 = ae[1], a11 = ae[5], a12 = ae[9], a13 = ae[13];\r\n\t\t\tconst a20 = ae[2], a21 = ae[6], a22 = ae[10], a23 = ae[14];\r\n\t\t\tconst a30 = ae[3], a31 = ae[7], a32 = ae[11], a33 = ae[15];\r\n\r\n\t\t\tconst b00 = be[0], b01 = be[4], b02 = be[8], b03 = be[12];\r\n\t\t\tconst b10 = be[1], b11 = be[5], b12 = be[9], b13 = be[13];\r\n\t\t\tconst b20 = be[2], b21 = be[6], b22 = be[10], b23 = be[14];\r\n\t\t\tconst b30 = be[3], b31 = be[7], b32 = be[11], b33 = be[15];\r\n\r\n\t\t\tte[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\r\n\t\t\tte[4] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\r\n\t\t\tte[8] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\r\n\t\t\tte[12] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\r\n\r\n\t\t\tte[1] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\r\n\t\t\tte[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\r\n\t\t\tte[9] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\r\n\t\t\tte[13] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\r\n\r\n\t\t\tte[2] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\r\n\t\t\tte[6] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\r\n\t\t\tte[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\r\n\t\t\tte[14] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\r\n\r\n\t\t\tte[3] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\r\n\t\t\tte[7] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\r\n\t\t\tte[11] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\r\n\t\t\tte[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this matrix with the given one.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmultiply(m) {\r\n\r\n\t\t\treturn this.multiplyMatrices(this, m);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies a given matrix with this one.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tpremultiply(m) {\r\n\r\n\t\t\treturn this.multiplyMatrices(m, this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this matrix with a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmultiplyScalar(s) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;\r\n\t\t\tte[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;\r\n\t\t\tte[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;\r\n\t\t\tte[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the determinant of this matrix.\r\n\t\t *\r\n\t\t * For more details see:\r\n\t\t *  http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\t *\r\n\t\t * @return {Number} The determinant.\r\n\t\t */\r\n\r\n\t\tdeterminant() {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst n00 = te[0], n01 = te[4], n02 = te[8], n03 = te[12];\r\n\t\t\tconst n10 = te[1], n11 = te[5], n12 = te[9], n13 = te[13];\r\n\t\t\tconst n20 = te[2], n21 = te[6], n22 = te[10], n23 = te[14];\r\n\t\t\tconst n30 = te[3], n31 = te[7], n32 = te[11], n33 = te[15];\r\n\r\n\t\t\tconst n00n11 = n00 * n11, n00n12 = n00 * n12, n00n13 = n00 * n13;\r\n\t\t\tconst n01n10 = n01 * n10, n01n12 = n01 * n12, n01n13 = n01 * n13;\r\n\t\t\tconst n02n10 = n02 * n10, n02n11 = n02 * n11, n02n13 = n02 * n13;\r\n\t\t\tconst n03n10 = n03 * n10, n03n11 = n03 * n11, n03n12 = n03 * n12;\r\n\r\n\t\t\treturn (\r\n\r\n\t\t\t\tn30 * (\r\n\t\t\t\t\tn03n12 * n21 -\r\n\t\t\t\t\tn02n13 * n21 -\r\n\t\t\t\t\tn03n11 * n22 +\r\n\t\t\t\t\tn01n13 * n22 +\r\n\t\t\t\t\tn02n11 * n23 -\r\n\t\t\t\t\tn01n12 * n23\r\n\t\t\t\t) +\r\n\r\n\t\t\t\tn31 * (\r\n\t\t\t\t\tn00n12 * n23 -\r\n\t\t\t\t\tn00n13 * n22 +\r\n\t\t\t\t\tn03n10 * n22 -\r\n\t\t\t\t\tn02n10 * n23 +\r\n\t\t\t\t\tn02n13 * n20 -\r\n\t\t\t\t\tn03n12 * n20\r\n\t\t\t\t) +\r\n\r\n\t\t\t\tn32 * (\r\n\t\t\t\t\tn00n13 * n21 -\r\n\t\t\t\t\tn00n11 * n23 -\r\n\t\t\t\t\tn03n10 * n21 +\r\n\t\t\t\t\tn01n10 * n23 +\r\n\t\t\t\t\tn03n11 * n20 -\r\n\t\t\t\t\tn01n13 * n20\r\n\t\t\t\t) +\r\n\r\n\t\t\t\tn33 * (\r\n\t\t\t\t\t-n02n11 * n20 -\r\n\t\t\t\t\tn00n12 * n21 +\r\n\t\t\t\t\tn00n11 * n22 +\r\n\t\t\t\t\tn02n10 * n21 -\r\n\t\t\t\t\tn01n10 * n22 +\r\n\t\t\t\t\tn01n12 * n20\r\n\t\t\t\t)\r\n\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Inverts the given matrix and stores the result in this matrix.\r\n\t\t *\r\n\t\t * For details see:\r\n\t\t *  http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\t *\r\n\t\t * @param {Matrix4} matrix - The matrix that should be inverted.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tgetInverse(matrix) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst me = matrix.elements;\r\n\r\n\t\t\tconst n00 = me[0], n10 = me[1], n20 = me[2], n30 = me[3];\r\n\t\t\tconst n01 = me[4], n11 = me[5], n21 = me[6], n31 = me[7];\r\n\t\t\tconst n02 = me[8], n12 = me[9], n22 = me[10], n32 = me[11];\r\n\t\t\tconst n03 = me[12], n13 = me[13], n23 = me[14], n33 = me[15];\r\n\r\n\t\t\tconst t00 = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\t\t\tconst t01 = n03 * n22 * n31 - n02 * n23 * n31 - n03 * n21 * n32 + n01 * n23 * n32 + n02 * n21 * n33 - n01 * n22 * n33;\r\n\t\t\tconst t02 = n02 * n13 * n31 - n03 * n12 * n31 + n03 * n11 * n32 - n01 * n13 * n32 - n02 * n11 * n33 + n01 * n12 * n33;\r\n\t\t\tconst t03 = n03 * n12 * n21 - n02 * n13 * n21 - n03 * n11 * n22 + n01 * n13 * n22 + n02 * n11 * n23 - n01 * n12 * n23;\r\n\r\n\t\t\tconst det = n00 * t00 + n10 * t01 + n20 * t02 + n30 * t03;\r\n\r\n\t\t\tlet invDet;\r\n\r\n\t\t\tif(det !== 0) {\r\n\r\n\t\t\t\tinvDet = 1.0 / det;\r\n\r\n\t\t\t\tte[0] = t00 * invDet;\r\n\t\t\t\tte[1] = (n13 * n22 * n30 - n12 * n23 * n30 - n13 * n20 * n32 + n10 * n23 * n32 + n12 * n20 * n33 - n10 * n22 * n33) * invDet;\r\n\t\t\t\tte[2] = (n11 * n23 * n30 - n13 * n21 * n30 + n13 * n20 * n31 - n10 * n23 * n31 - n11 * n20 * n33 + n10 * n21 * n33) * invDet;\r\n\t\t\t\tte[3] = (n12 * n21 * n30 - n11 * n22 * n30 - n12 * n20 * n31 + n10 * n22 * n31 + n11 * n20 * n32 - n10 * n21 * n32) * invDet;\r\n\r\n\t\t\t\tte[4] = t01 * invDet;\r\n\t\t\t\tte[5] = (n02 * n23 * n30 - n03 * n22 * n30 + n03 * n20 * n32 - n00 * n23 * n32 - n02 * n20 * n33 + n00 * n22 * n33) * invDet;\r\n\t\t\t\tte[6] = (n03 * n21 * n30 - n01 * n23 * n30 - n03 * n20 * n31 + n00 * n23 * n31 + n01 * n20 * n33 - n00 * n21 * n33) * invDet;\r\n\t\t\t\tte[7] = (n01 * n22 * n30 - n02 * n21 * n30 + n02 * n20 * n31 - n00 * n22 * n31 - n01 * n20 * n32 + n00 * n21 * n32) * invDet;\r\n\r\n\t\t\t\tte[8] = t02 * invDet;\r\n\t\t\t\tte[9] = (n03 * n12 * n30 - n02 * n13 * n30 - n03 * n10 * n32 + n00 * n13 * n32 + n02 * n10 * n33 - n00 * n12 * n33) * invDet;\r\n\t\t\t\tte[10] = (n01 * n13 * n30 - n03 * n11 * n30 + n03 * n10 * n31 - n00 * n13 * n31 - n01 * n10 * n33 + n00 * n11 * n33) * invDet;\r\n\t\t\t\tte[11] = (n02 * n11 * n30 - n01 * n12 * n30 - n02 * n10 * n31 + n00 * n12 * n31 + n01 * n10 * n32 - n00 * n11 * n32) * invDet;\r\n\r\n\t\t\t\tte[12] = t03 * invDet;\r\n\t\t\t\tte[13] = (n02 * n13 * n20 - n03 * n12 * n20 + n03 * n10 * n22 - n00 * n13 * n22 - n02 * n10 * n23 + n00 * n12 * n23) * invDet;\r\n\t\t\t\tte[14] = (n03 * n11 * n20 - n01 * n13 * n20 - n03 * n10 * n21 + n00 * n13 * n21 + n01 * n10 * n23 - n00 * n11 * n23) * invDet;\r\n\t\t\t\tte[15] = (n01 * n12 * n20 - n02 * n11 * n20 + n02 * n10 * n21 - n00 * n12 * n21 - n01 * n10 * n22 + n00 * n11 * n22) * invDet;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error(\"Can't invert matrix, determinant is zero\", matrix);\r\n\r\n\t\t\t\tthis.identity();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Transposes this matrix.\r\n\t\t *\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\ttranspose() {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tlet t;\r\n\r\n\t\t\tt = te[1]; te[1] = te[4]; te[4] = t;\r\n\t\t\tt = te[2]; te[2] = te[8]; te[8] = t;\r\n\t\t\tt = te[6]; te[6] = te[9]; te[9] = t;\r\n\r\n\t\t\tt = te[3]; te[3] = te[12]; te[12] = t;\r\n\t\t\tt = te[7]; te[7] = te[13]; te[13] = t;\r\n\t\t\tt = te[11]; te[11] = te[14]; te[14] = t;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Scales this matrix.\r\n\t\t *\r\n\t\t * @param {Number} sx - The X scale.\r\n\t\t * @param {Number} sy - The Y scale.\r\n\t\t * @param {Number} sz - The Z scale.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tscale(sx, sy, sz) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] *= sx; te[4] *= sy; te[8] *= sz;\r\n\t\t\tte[1] *= sx; te[5] *= sy; te[9] *= sz;\r\n\t\t\tte[2] *= sx; te[6] *= sy; te[10] *= sz;\r\n\t\t\tte[3] *= sx; te[7] *= sy; te[11] *= sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Makes this matrix a scale matrix.\r\n\t\t *\r\n\t\t * @param {Number} x - The X scale.\r\n\t\t * @param {Number} y - The Y scale.\r\n\t\t * @param {Number} z - The Z scale.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakeScale(x, y, z) {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\tx, 0, 0, 0,\r\n\t\t\t\t0, y, 0, 0,\r\n\t\t\t\t0, 0, z, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Makes this matrix a translation matrix.\r\n\t\t *\r\n\t\t * @param {Number} x - The X offset.\r\n\t\t * @param {Number} y - The Y offset.\r\n\t\t * @param {Number} z - The Z offset.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakeTranslation(x, y, z) {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, 0, 0, x,\r\n\t\t\t\t0, 1, 0, y,\r\n\t\t\t\t0, 0, 1, z,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Makes this matrix a rotation matrix.\r\n\t\t *\r\n\t\t * @param {Number} theta - The angle in radians.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakeRotationX(theta) {\r\n\r\n\t\t\tconst c = Math.cos(theta), s = Math.sin(theta);\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, 0, 0, 0,\r\n\t\t\t\t0, c, -s, 0,\r\n\t\t\t\t0, s, c, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Makes this matrix a rotation matrix with respect to the Y-axis.\r\n\t\t *\r\n\t\t * @param {Number} theta - The angle in radians.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakeRotationY(theta) {\r\n\r\n\t\t\tconst c = Math.cos(theta), s = Math.sin(theta);\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\tc, 0, s, 0,\r\n\t\t\t\t0, 1, 0, 0,\r\n\t\t\t\t-s, 0, c, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Makes this matrix a rotation matrix with respect to the Z-axis.\r\n\t\t *\r\n\t\t * @param {Number} theta - The angle in radians.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakeRotationZ(theta) {\r\n\r\n\t\t\tconst c = Math.cos(theta), s = Math.sin(theta);\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\tc, -s, 0, 0,\r\n\t\t\t\ts, c, 0, 0,\r\n\t\t\t\t0, 0, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Makes this matrix a translation matrix with respect to a specific axis.\r\n\t\t *\r\n\t\t * For mor einformation see:\r\n\t\t *  http://www.gamedev.net/reference/articles/article1199.asp\r\n\t\t *\r\n\t\t * @param {Vector3} axis - The axis. Assumed to be normalized.\r\n\t\t * @param {Number} angle - The angle in radians.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakeRotationAxis(axis, angle) {\r\n\r\n\t\t\tconst c = Math.cos(angle);\r\n\t\t\tconst s = Math.sin(angle);\r\n\r\n\t\t\tconst t = 1.0 - c;\r\n\r\n\t\t\tconst x = axis.x, y = axis.y, z = axis.z;\r\n\t\t\tconst tx = t * x, ty = t * y;\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Makes this matrix a shear matrix.\r\n\t\t *\r\n\t\t * @param {Number} x - The X shear value.\r\n\t\t * @param {Number} y - The Y shear value.\r\n\t\t * @param {Number} z - The Z shear value.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakeShear(x, y, z) {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, y, z, 0,\r\n\t\t\t\tx, 1, z, 0,\r\n\t\t\t\tx, y, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this matrix based on the given position, rotation and scale.\r\n\t\t *\r\n\t\t * @param {Vector3} position - The position.\r\n\t\t * @param {Quaternion} quaternion - The rotation.\r\n\t\t * @param {Vector3} scale - The scale.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tcompose(position, quaternion, scale) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;\r\n\t\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\r\n\t\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\r\n\r\n\t\t\tte[0] = (1 - (yy + zz)) * sx;\r\n\t\t\tte[1] = (xy + wz) * sx;\r\n\t\t\tte[2] = (xz - wy) * sx;\r\n\t\t\tte[3] = 0;\r\n\r\n\t\t\tte[4] = (xy - wz) * sy;\r\n\t\t\tte[5] = (1 - (xx + zz)) * sy;\r\n\t\t\tte[6] = (yz + wx) * sy;\r\n\t\t\tte[7] = 0;\r\n\r\n\t\t\tte[8] = (xz + wy) * sz;\r\n\t\t\tte[9] = (yz - wx) * sz;\r\n\t\t\tte[10] = (1 - (xx + yy)) * sz;\r\n\t\t\tte[11] = 0;\r\n\r\n\t\t\tte[12] = position.x;\r\n\t\t\tte[13] = position.y;\r\n\t\t\tte[14] = position.z;\r\n\t\t\tte[15] = 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Decomposes this matrix into a position, rotation and scale vector.\r\n\t\t *\r\n\t\t * @param {Vector3} position - The target position.\r\n\t\t * @param {Quaternion} quaternion - The target rotation.\r\n\t\t * @param {Vector3} scale - The target scale.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tdecompose(position, quaternion, scale) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst n00 = te[0], n10 = te[1], n20 = te[2];\r\n\t\t\tconst n01 = te[4], n11 = te[5], n21 = te[6];\r\n\t\t\tconst n02 = te[8], n12 = te[9], n22 = te[10];\r\n\r\n\t\t\tconst det = this.determinant();\r\n\r\n\t\t\t// If the determinant is negative, one scale must be inverted.\r\n\t\t\tconst sx = a$2.set(n00, n10, n20).length() * ((det < 0) ? -1 : 1);\r\n\t\t\tconst sy = a$2.set(n01, n11, n21).length();\r\n\t\t\tconst sz = a$2.set(n02, n12, n22).length();\r\n\r\n\t\t\tconst invSX = 1.0 / sx;\r\n\t\t\tconst invSY = 1.0 / sy;\r\n\t\t\tconst invSZ = 1.0 / sz;\r\n\r\n\t\t\t// Export the position.\r\n\t\t\tposition.x = te[12];\r\n\t\t\tposition.y = te[13];\r\n\t\t\tposition.z = te[14];\r\n\r\n\t\t\t// Scale the rotation part.\r\n\t\t\tte[0] *= invSX; te[1] *= invSX; te[2] *= invSX;\r\n\t\t\tte[4] *= invSY; te[5] *= invSY; te[6] *= invSY;\r\n\t\t\tte[8] *= invSZ; te[9] *= invSZ; te[10] *= invSZ;\r\n\r\n\t\t\t// Export the rotation.\r\n\t\t\tquaternion.setFromRotationMatrix(this);\r\n\r\n\t\t\t// Restore the original values.\r\n\t\t\tte[0] = n00; te[1] = n10; te[2] = n20;\r\n\t\t\tte[4] = n01; te[5] = n11; te[6] = n21;\r\n\t\t\tte[8] = n02; te[9] = n12; te[10] = n22;\r\n\r\n\t\t\t// Export the scale.\r\n\t\t\tscale.x = sx;\r\n\t\t\tscale.y = sy;\r\n\t\t\tscale.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a perspective matrix.\r\n\t\t *\r\n\t\t * @param {Number} left - The distance to the left plane.\r\n\t\t * @param {Number} right - The distance to the right plane.\r\n\t\t * @param {Number} top - The distance to the top plane.\r\n\t\t * @param {Number} bottom - The distance to the bottom plane.\r\n\t\t * @param {Number} near - The distance to the near plane.\r\n\t\t * @param {Number} far - The distance to the far plane.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakePerspective(left, right, top, bottom, near, far) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst x = 2 * near / (right - left);\r\n\t\t\tconst y = 2 * near / (top - bottom);\r\n\r\n\t\t\tconst a = (right + left) / (right - left);\r\n\t\t\tconst b = (top + bottom) / (top - bottom);\r\n\t\t\tconst c = -(far + near) / (far - near);\r\n\t\t\tconst d = -2 * far * near / (far - near);\r\n\r\n\t\t\tte[0] = x; te[4] = 0; te[8] = a; te[12] = 0;\r\n\t\t\tte[1] = 0; te[5] = y; te[9] = b; te[13] = 0;\r\n\t\t\tte[2] = 0; te[6] = 0; te[10] = c; te[14] = d;\r\n\t\t\tte[3] = 0; te[7] = 0; te[11] = -1; te[15] = 0;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates an orthographic matrix.\r\n\t\t *\r\n\t\t * @param {Number} left - The distance to the left plane.\r\n\t\t * @param {Number} right - The distance to the right plane.\r\n\t\t * @param {Number} top - The distance to the top plane.\r\n\t\t * @param {Number} bottom - The distance to the bottom plane.\r\n\t\t * @param {Number} near - The distance to the near plane.\r\n\t\t * @param {Number} far - The distance to the far plane.\r\n\t\t * @return {Matrix4} This matrix.\r\n\t\t */\r\n\r\n\t\tmakeOrthographic(left, right, top, bottom, near, far) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst w = 1.0 / (right - left);\r\n\t\t\tconst h = 1.0 / (top - bottom);\r\n\t\t\tconst p = 1.0 / (far - near);\r\n\r\n\t\t\tconst x = (right + left) * w;\r\n\t\t\tconst y = (top + bottom) * h;\r\n\t\t\tconst z = (far + near) * p;\r\n\r\n\t\t\tte[0] = 2 * w; te[4] = 0; te[8] = 0; te[12] = -x;\r\n\t\t\tte[1] = 0; te[5] = 2 * h; te[9] = 0; te[13] = -y;\r\n\t\t\tte[2] = 0; te[6] = 0; te[10] = -2 * p; te[14] = -z;\r\n\t\t\tte[3] = 0; te[7] = 0; te[11] = 0; te[15] = 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this matrix equals the given one.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Boolean} Whether the matrix are equal.\r\n\t\t */\r\n\r\n\t\tequals(m) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tlet result = true;\r\n\t\t\tlet i;\r\n\r\n\t\t\tfor(i = 0; result && i < 16; ++i) {\r\n\r\n\t\t\t\tif(te[i] !== me[i]) {\r\n\r\n\t\t\t\t\tresult = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A list of vectors.\r\n\t *\r\n\t * @type {Vector3[]}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v$5 = [\r\n\t\tnew Vector3(),\r\n\t\tnew Vector3(),\r\n\t\tnew Vector3(),\r\n\t\tnew Vector3()\r\n\t];\r\n\r\n\t/**\r\n\t * A ray.\r\n\t */\r\n\r\n\tclass Ray {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new ray.\r\n\t\t *\r\n\t\t * @param {Vector3} [origin] - The origin.\r\n\t\t * @param {Vector3} [direction] - The direction.\r\n\t\t */\r\n\r\n\t\tconstructor(origin = new Vector3(), direction = new Vector3()) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The origin.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.origin = origin;\r\n\r\n\t\t\t/**\r\n\t\t\t * The direction.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.direction = direction;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the origin and the direction.\r\n\t\t *\r\n\t\t * @param {Vector3} origin - The origin.\r\n\t\t * @param {Vector3} direction - The direction. Should be normalized.\r\n\t\t * @return {Ray} This ray.\r\n\t\t */\r\n\r\n\t\tset(origin, direction) {\r\n\r\n\t\t\tthis.origin.copy(origin);\r\n\t\t\tthis.direction.copy(direction);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the given ray.\r\n\t\t *\r\n\t\t * @param {Ray} r - A ray.\r\n\t\t * @return {Ray} This ray.\r\n\t\t */\r\n\r\n\t\tcopy(r) {\r\n\r\n\t\t\tthis.origin.copy(r.origin);\r\n\t\t\tthis.direction.copy(r.direction);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this ray.\r\n\t\t *\r\n\t\t * @return {Ray} The cloned ray.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().copy(this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes a point along the ray based on a given scalar t.\r\n\t\t *\r\n\t\t * @param {Number} t - The scalar.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point.\r\n\t\t */\r\n\r\n\t\tat(t, target = new Vector3()) {\r\n\r\n\t\t\treturn target.copy(this.direction).multiplyScalar(t).add(this.origin);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rotates this ray to look at the given target.\r\n\t\t *\r\n\t\t * @param {Vector3} target - A point to look at.\r\n\t\t * @return {Ray} This ray.\r\n\t\t */\r\n\r\n\t\tlookAt(target) {\r\n\r\n\t\t\tthis.direction.copy(target).sub(this.origin).normalize();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Moves the origin along the ray by a given scalar t.\r\n\t\t *\r\n\t\t * @param {Number} t - The scalar.\r\n\t\t * @return {Ray} This ray.\r\n\t\t */\r\n\r\n\t\trecast(t) {\r\n\r\n\t\t\tthis.origin.copy(this.at(t, v$5[0]));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the closest point along this ray to a given point.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point.\r\n\t\t */\r\n\r\n\t\tclosestPointToPoint(p, target = new Vector3()) {\r\n\r\n\t\t\tconst directionDistance = target.subVectors(p, this.origin).dot(this.direction);\r\n\r\n\t\t\treturn (directionDistance >= 0.0) ?\r\n\t\t\t\ttarget.copy(this.direction).multiplyScalar(directionDistance).add(this.origin) :\r\n\t\t\t\ttarget.copy(this.origin);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared distance from this ray to the given point.\r\n\t\t *\r\n\t\t * @param {Vector3} p - The point.\r\n\t\t * @return {Number} The squared distance.\r\n\t\t */\r\n\r\n\t\tdistanceSquaredToPoint(p) {\r\n\r\n\t\t\tconst directionDistance = v$5[0].subVectors(p, this.origin).dot(this.direction);\r\n\r\n\t\t\t// Check if the point is behind the ray.\r\n\t\t\treturn (directionDistance < 0.0) ?\r\n\t\t\t\tthis.origin.distanceToSquared(p) :\r\n\t\t\t\tv$5[0].copy(this.direction).multiplyScalar(directionDistance).add(this.origin).distanceToSquared(p);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance from this ray to the given point.\r\n\t\t *\r\n\t\t * @param {Vector3} p - The point.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tdistanceToPoint(p) {\r\n\r\n\t\t\treturn Math.sqrt(this.distanceSquaredToPoint(p));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance from this ray to the given plane.\r\n\t\t *\r\n\t\t * @param {Plane} p - The plane.\r\n\t\t * @return {Number} The distance, or null if the denominator is zero.\r\n\t\t */\r\n\r\n\t\tdistanceToPlane(p) {\r\n\r\n\t\t\tconst denominator = p.normal.dot(this.direction);\r\n\r\n\t\t\tconst t = (denominator !== 0.0) ?\r\n\t\t\t\t-(this.origin.dot(p.normal) + p.constant) / denominator :\r\n\t\t\t\t((p.distanceToPoint(this.origin) === 0.0) ? 0.0 : -1.0);\r\n\r\n\t\t\treturn (t >= 0.0) ? t : null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance from this ray to a given line segment.\r\n\t\t *\r\n\t\t * Based on:\r\n\t\t *  http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\r\n\t\t *\r\n\t\t * @param {Vector3} v0 - The start of the segment.\r\n\t\t * @param {Vector3} v1 - The end of the segment.\r\n\t\t * @param {Vector3} [pointOnRay] - If provided, the point on this Ray that is closest to the segment will be stored in this vector.\r\n\t\t * @param {Vector3} [pointOnSegment] - If provided, the point on the line segment that is closest to this ray will be stored in this vector.\r\n\t\t * @return {Number} The smallest distance between the ray and the segment defined by v0 and v1.\r\n\t\t */\r\n\r\n\t\tdistanceSquaredToSegment(v0, v1, pointOnRay, pointOnSegment) {\r\n\r\n\t\t\tconst segCenter = v$5[0].copy(v0).add(v1).multiplyScalar(0.5);\r\n\t\t\tconst segDir = v$5[1].copy(v1).sub(v0).normalize();\r\n\t\t\tconst diff = v$5[2].copy(this.origin).sub(segCenter);\r\n\r\n\t\t\tconst segExtent = v0.distanceTo(v1) * 0.5;\r\n\t\t\tconst a01 = -this.direction.dot(segDir);\r\n\t\t\tconst b0 = diff.dot(this.direction);\r\n\t\t\tconst b1 = -diff.dot(segDir);\r\n\t\t\tconst c = diff.lengthSq();\r\n\t\t\tconst det = Math.abs(1.0 - a01 * a01);\r\n\r\n\t\t\tlet s0, s1, extDet, invDet, sqrDist;\r\n\r\n\t\t\tif(det > 0.0) {\r\n\r\n\t\t\t\t// The ray and segment are not parallel.\r\n\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\textDet = segExtent * det;\r\n\r\n\t\t\t\tif(s0 >= 0.0) {\r\n\r\n\t\t\t\t\tif(s1 >= -extDet) {\r\n\r\n\t\t\t\t\t\tif(s1 <= extDet) {\r\n\r\n\t\t\t\t\t\t\t// Region 0.\r\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\t\t\t\t\t\t\tinvDet = 1.0 / det;\r\n\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\tsqrDist = s0 * (s0 + a01 * s1 + 2.0 * b0) + s1 * (a01 * s0 + s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// Region 1.\r\n\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max(0.0, -(a01 * s1 + b0));\r\n\t\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// Region 5.\r\n\t\t\t\t\t\ts1 = -segExtent;\r\n\t\t\t\t\t\ts0 = Math.max(0.0, -(a01 * s1 + b0));\r\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif(s1 <= -extDet) {\r\n\r\n\t\t\t\t\t\t// Region 4.\r\n\t\t\t\t\t\ts0 = Math.max(0.0, -(-a01 * segExtent + b0));\r\n\t\t\t\t\t\ts1 = (s0 > 0.0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\r\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t} else if(s1 <= extDet) {\r\n\r\n\t\t\t\t\t\t// Region 3.\r\n\t\t\t\t\t\ts0 = 0.0;\r\n\t\t\t\t\t\ts1 = Math.min(Math.max(-segExtent, -b1), segExtent);\r\n\t\t\t\t\t\tsqrDist = s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// Region 2.\r\n\t\t\t\t\t\ts0 = Math.max(0.0, -(a01 * segExtent + b0));\r\n\t\t\t\t\t\ts1 = (s0 > 0.0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\r\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Ray and segment are parallel.\r\n\t\t\t\ts1 = (a01 > 0.0) ? -segExtent : segExtent;\r\n\t\t\t\ts0 = Math.max(0.0, -(a01 * s1 + b0));\r\n\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(pointOnRay !== undefined) {\r\n\r\n\t\t\t\tpointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(pointOnSegment !== undefined) {\r\n\r\n\t\t\t\tpointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn sqrDist;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the point where this ray intersects the given sphere.\r\n\t\t *\r\n\t\t * @param {Sphere} s - A sphere.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t\t */\r\n\r\n\t\tintersectSphere(s, target = new Vector3()) {\r\n\r\n\t\t\tconst ab = v$5[0].subVectors(s.center, this.origin);\r\n\t\t\tconst tca = ab.dot(this.direction);\r\n\t\t\tconst d2 = ab.dot(ab) - tca * tca;\r\n\t\t\tconst radius2 = s.radius * s.radius;\r\n\r\n\t\t\tlet result = null;\r\n\t\t\tlet thc, t0, t1;\r\n\r\n\t\t\tif(d2 <= radius2) {\r\n\r\n\t\t\t\tthc = Math.sqrt(radius2 - d2);\r\n\r\n\t\t\t\t// t0 = first intersection point - entrance on front of sphere.\r\n\t\t\t\tt0 = tca - thc;\r\n\r\n\t\t\t\t// t1 = second intersection point - exit point on back of sphere.\r\n\t\t\t\tt1 = tca + thc;\r\n\r\n\t\t\t\t// Check if both t0 and t1 are behind the ray - if so, return null.\r\n\t\t\t\tif(t0 >= 0.0 || t1 >= 0.0) {\r\n\r\n\t\t\t\t\t/* Check if t0 is behind the ray. If it is, the ray is inside the\r\n\t\t\t\t\tsphere, so return the second exit point scaled by t1 in order to always\r\n\t\t\t\t\treturn an intersection point that is in front of the ray. If t0 is in\r\n\t\t\t\t\tfront of the ray, return the first collision point scaled by t0. */\r\n\t\t\t\t\tresult = (t0 < 0.0) ? this.at(t1, target) : this.at(t0, target);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Determines whether this ray intersects the given sphere.\r\n\t\t *\r\n\t\t * @param {Sphere} s - A sphere.\r\n\t\t * @return {Boolean} Whether this ray intersects the given sphere.\r\n\t\t */\r\n\r\n\t\tintersectsSphere(s) {\r\n\r\n\t\t\treturn (this.distanceToPoint(s.center) <= s.radius);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the point where this ray intersects the given plane.\r\n\t\t *\r\n\t\t * @param {Plane} p - A plane.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t\t */\r\n\r\n\t\tintersectPlane(p, target = new Vector3()) {\r\n\r\n\t\t\tconst t = this.distanceToPlane(p);\r\n\r\n\t\t\treturn (t === null) ? null : this.at(t, target);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Determines whether this ray intersects the given plane.\r\n\t\t *\r\n\t\t * @param {Plane} p - A plane.\r\n\t\t * @return {Boolean} Whether this ray intersects the given plane.\r\n\t\t */\r\n\r\n\t\tintersectsPlane(p) {\r\n\r\n\t\t\tconst distanceToPoint = p.distanceToPoint(this.origin);\r\n\r\n\t\t\treturn (distanceToPoint === 0.0 || p.normal.dot(this.direction) * distanceToPoint < 0.0);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the point where this ray intersects the given box.\r\n\t\t *\r\n\t\t * @param {Plane} b - A box.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t\t */\r\n\r\n\t\tintersectBox(b, target = new Vector3()) {\r\n\r\n\t\t\tconst origin = this.origin;\r\n\t\t\tconst direction = this.direction;\r\n\t\t\tconst min = b.min;\r\n\t\t\tconst max = b.max;\r\n\r\n\t\t\tconst invDirX = 1.0 / direction.x;\r\n\t\t\tconst invDirY = 1.0 / direction.y;\r\n\t\t\tconst invDirZ = 1.0 / direction.z;\r\n\r\n\t\t\tlet result = null;\r\n\t\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n\t\t\tif(invDirX >= 0.0) {\r\n\r\n\t\t\t\ttmin = (min.x - origin.x) * invDirX;\r\n\t\t\t\ttmax = (max.x - origin.x) * invDirX;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttmin = (max.x - origin.x) * invDirX;\r\n\t\t\t\ttmax = (min.x - origin.x) * invDirX;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(invDirY >= 0.0) {\r\n\r\n\t\t\t\ttymin = (min.y - origin.y) * invDirY;\r\n\t\t\t\ttymax = (max.y - origin.y) * invDirY;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttymin = (max.y - origin.y) * invDirY;\r\n\t\t\t\ttymax = (min.y - origin.y) * invDirY;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(tmin <= tymax && tymin <= tmax) {\r\n\r\n\t\t\t\t/* Handle the case where tmin or tmax is NaN (result of 0 * Infinity).\r\n\t\t\t\tNote: x !== x returns true if x is NaN. */\r\n\t\t\t\tif(tymin > tmin || tmin !== tmin) {\r\n\r\n\t\t\t\t\ttmin = tymin;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(tymax < tmax || tmax !== tmax) {\r\n\r\n\t\t\t\t\ttmax = tymax;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(invDirZ >= 0.0) {\r\n\r\n\t\t\t\t\ttzmin = (min.z - origin.z) * invDirZ;\r\n\t\t\t\t\ttzmax = (max.z - origin.z) * invDirZ;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttzmin = (max.z - origin.z) * invDirZ;\r\n\t\t\t\t\ttzmax = (min.z - origin.z) * invDirZ;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(tmin <= tzmax && tzmin <= tmax) {\r\n\r\n\t\t\t\t\tif(tzmin > tmin || tmin !== tmin) {\r\n\r\n\t\t\t\t\t\ttmin = tzmin;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(tzmax < tmax || tmax !== tmax) {\r\n\r\n\t\t\t\t\t\ttmax = tzmax;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Return the closest point (positive side).\r\n\t\t\t\t\tif(tmax >= 0.0) {\r\n\r\n\t\t\t\t\t\tresult = this.at((tmin >= 0.0) ? tmin : tmax, target);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Determines whether this ray intersects the given box.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Boolean} Whether this ray intersects the given box.\r\n\t\t */\r\n\r\n\t\tintersectsBox(b) {\r\n\r\n\t\t\treturn (this.intersectBox(b, v$5[0]) !== null);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the point where this ray intersects the given triangle.\r\n\t\t *\r\n\t\t * Based on:\r\n\t\t *  http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\r\n\t\t *\r\n\t\t * @param {Vector3} a - A triangle vertex.\r\n\t\t * @param {Vector3} b - A triangle vertex.\r\n\t\t * @param {Vector3} c - A triangle vertex.\r\n\t\t * @param {Boolean} [backfaceCulling=false] - Whether backface culling should be considered.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t\t */\r\n\r\n\t\tintersectTriangle(a, b, c, backfaceCulling, target) {\r\n\r\n\t\t\tconst direction = this.direction;\r\n\r\n\t\t\t// Compute the offset origin, edges, and normal.\r\n\t\t\tconst diff = v$5[0];\r\n\t\t\tconst edge1 = v$5[1];\r\n\t\t\tconst edge2 = v$5[2];\r\n\t\t\tconst normal = v$5[3];\r\n\r\n\t\t\tlet result = null;\r\n\t\t\tlet DdN, sign, DdQxE2, DdE1xQ, QdN;\r\n\r\n\t\t\tedge1.subVectors(b, a);\r\n\t\t\tedge2.subVectors(c, a);\r\n\t\t\tnormal.crossVectors(edge1, edge2);\r\n\r\n\t\t\t/* Solve Q + t * D = b1 * E1 + b2 * E2\r\n\t\t\t * (Q = kDiff, D = ray direction, E1 = kEdge1, E2 = kEdge2,\r\n\t\t\t * N = Cross(E1, E2)):\r\n\t\t\t *\r\n\t\t\t *   | Dot(D, N) | * b1 = sign(Dot(D, N)) * Dot(D, Cross(Q, E2))\r\n\t\t\t *   | Dot(D, N) | * b2 = sign(Dot(D, N)) * Dot(D, Cross(E1, Q))\r\n\t\t\t *   | Dot(D, N) | * t = -sign(Dot(D, N)) * Dot(Q, N)\r\n\t\t\t */\r\n\r\n\t\t\tDdN = direction.dot(normal);\r\n\r\n\t\t\t// Discard coplanar constellations and cull backfaces.\r\n\t\t\tif(DdN !== 0.0 && !(backfaceCulling && DdN > 0.0)) {\r\n\r\n\t\t\t\tif(DdN > 0.0) {\r\n\r\n\t\t\t\t\tsign = 1.0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsign = -1.0;\r\n\t\t\t\t\tDdN = -DdN;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdiff.subVectors(this.origin, a);\r\n\t\t\t\tDdQxE2 = sign * direction.dot(edge2.crossVectors(diff, edge2));\r\n\r\n\t\t\t\t// b1 < 0, no intersection.\r\n\t\t\t\tif(DdQxE2 >= 0.0) {\r\n\r\n\t\t\t\t\tDdE1xQ = sign * direction.dot(edge1.cross(diff));\r\n\r\n\t\t\t\t\t// b2 < 0, or b1 + b2 > 1, no intersection.\r\n\t\t\t\t\tif(DdE1xQ >= 0.0 && DdQxE2 + DdE1xQ <= DdN) {\r\n\r\n\t\t\t\t\t\t// The line intersects the triangle, check if the ray does.\r\n\t\t\t\t\t\tQdN = -sign * diff.dot(normal);\r\n\r\n\t\t\t\t\t\t// t < 0, no intersection.\r\n\t\t\t\t\t\tif(QdN >= 0.0) {\r\n\r\n\t\t\t\t\t\t\t// Ray intersects triangle.\r\n\t\t\t\t\t\t\tresult = this.at(QdN / DdN, target);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies the given matrix to this ray.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Ray} This ray.\r\n\t\t */\r\n\r\n\t\tapplyMatrix4(m) {\r\n\r\n\t\t\tthis.origin.applyMatrix4(m);\r\n\t\t\tthis.direction.transformDirection(m);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this ray equals the given one.\r\n\t\t *\r\n\t\t * @param {Ray} r - A ray.\r\n\t\t * @return {Boolean} Whether the rays are equal.\r\n\t\t */\r\n\r\n\t\tequals(r) {\r\n\r\n\t\t\treturn (r.origin.equals(this.origin) && r.direction.equals(this.direction));\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A spherical coordinate system.\r\n\t *\r\n\t * For details see: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n\t *\r\n\t * The poles (phi) are at the positive and negative Y-axis. The equator starts\r\n\t * at positive Z.\r\n\t */\n\n\t/**\r\n\t * A symmetric 3x3 matrix.\r\n\t */\r\n\r\n\tclass SymmetricMatrix3 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new symmetric matrix.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\t/**\r\n\t\t\t * The matrix elements.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.elements = new Float32Array([\r\n\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t1, 0,\r\n\t\t\t\t1\r\n\r\n\t\t\t]);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this matrix.\r\n\t\t *\r\n\t\t * @param {Number} m00 - The value of the first row, first column.\r\n\t\t * @param {Number} m01 - The value of the first row, second column and the second row, first column.\r\n\t\t * @param {Number} m02 - The value of the first row, third column and the third row, first column.\r\n\t\t * @param {Number} m11 - The value of the second row, second column.\r\n\t\t * @param {Number} m12 - The value of the second row, third column and third row, second column.\r\n\t\t * @param {Number} m22 - The value of the third row, third column.\r\n\t\t * @return {SymmetricMatrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tset(m00, m01, m02, m11, m12, m22) {\r\n\r\n\t\t\tconst e = this.elements;\r\n\r\n\t\t\te[0] = m00;\r\n\t\t\te[1] = m01; e[3] = m11;\r\n\t\t\te[2] = m02; e[4] = m12; e[5] = m22;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this matrix to the identity matrix.\r\n\t\t *\r\n\t\t * @return {SymmetricMatrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tidentity() {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t1, 0,\r\n\t\t\t\t1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a given symmetric matrix.\r\n\t\t *\r\n\t\t * @param {SymmetricMatrix3} m - A matrix.\r\n\t\t * @return {SymmetricMatrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tcopy(m) {\r\n\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\tme[0], me[1], me[2],\r\n\t\t\t\tme[3], me[4],\r\n\t\t\t\tme[5]\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this matrix.\r\n\t\t *\r\n\t\t * @return {SymmetricMatrix3} A clone of this matrix.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().copy(this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies this symmetric matrix into a given 3x3 matrix.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - The target matrix.\r\n\t\t */\r\n\r\n\t\ttoMatrix3(m) {\r\n\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tm.set(\r\n\r\n\t\t\t\tme[0], me[1], me[2],\r\n\t\t\t\tme[1], me[3], me[4],\r\n\t\t\t\tme[2], me[4], me[5]\r\n\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds the values of a given symmetric matrix to this one.\r\n\t\t *\r\n\t\t * @param {SymmetricMatrix3} m - A matrix.\r\n\t\t * @return {SymmetricMatrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tadd(m) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tte[0] += me[0];\r\n\t\t\tte[1] += me[1]; te[3] += me[3];\r\n\t\t\tte[2] += me[2]; te[4] += me[4]; te[5] += me[5];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Frobenius norm of this matrix.\r\n\t\t *\r\n\t\t * @return {Number} The norm of this matrix.\r\n\t\t */\r\n\r\n\t\tnorm() {\r\n\r\n\t\t\tconst e = this.elements;\r\n\r\n\t\t\tconst m01m01 = e[1] * e[1];\r\n\t\t\tconst m02m02 = e[2] * e[2];\r\n\t\t\tconst m12m12 = e[4] * e[4];\r\n\r\n\t\t\treturn Math.sqrt(\r\n\r\n\t\t\t\te[0] * e[0] + m01m01 + m02m02 +\r\n\t\t\t\tm01m01 + e[3] * e[3] + m12m12 +\r\n\t\t\t\tm02m02 + m12m12 + e[5] * e[5]\r\n\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the absolute sum of all matrix components except for the main\r\n\t\t * diagonal.\r\n\t\t *\r\n\t\t * @return {Number} The offset of this matrix.\r\n\t\t */\r\n\r\n\t\toff() {\r\n\r\n\t\t\tconst e = this.elements;\r\n\r\n\t\t\treturn Math.sqrt(2 * (\r\n\r\n\t\t\t\t// Diagonal = [0, 3, 5].\r\n\t\t\t\te[1] * e[1] + e[2] * e[2] + e[4] * e[4]\r\n\r\n\t\t\t));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies this symmetric matrix to a vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - The vector to modify.\r\n\t\t * @return {Vector3} The modified vector.\r\n\t\t */\r\n\r\n\t\tapplyToVector3(v) {\r\n\r\n\t\t\tconst x = v.x, y = v.y, z = v.z;\r\n\t\t\tconst e = this.elements;\r\n\r\n\t\t\tv.x = e[0] * x + e[1] * y + e[2] * z;\r\n\t\t\tv.y = e[1] * x + e[3] * y + e[4] * z;\r\n\t\t\tv.z = e[2] * x + e[4] * y + e[5] * z;\r\n\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this matrix equals the given one.\r\n\t\t *\r\n\t\t * @param {SymmetricMatrix3} m - A matrix.\r\n\t\t * @return {Boolean} Whether the matrices are equal.\r\n\t\t */\r\n\r\n\t\tequals(m) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tlet result = true;\r\n\t\t\tlet i;\r\n\r\n\t\t\tfor(i = 0; result && i < 6; ++i) {\r\n\r\n\t\t\t\tif(te[i] !== me[i]) {\r\n\r\n\t\t\t\t\tresult = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the linear index of an element from this matrix.\r\n\t\t *\r\n\t\t * Let N be the dimension of the symmetric matrix:\r\n\t\t *\r\n\t\t *     index = N * (N - 1) / 2 - (N - i) * (N - i - 1) / 2 + j\r\n\t\t *\r\n\t\t * @param {Number} i - The row.\r\n\t\t * @param {Number} j - The column.\r\n\t\t * @return {Number} The index into the elements of this matrix.\r\n\t\t */\r\n\r\n\t\tstatic calculateIndex(i, j) {\r\n\r\n\t\t\treturn (3 - (3 - i) * (2 - i) / 2 + j);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A vector with four components.\r\n\t */\r\n\r\n\tclass Vector4 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new vector.\r\n\t\t *\r\n\t\t * @param {Number} [x=0] - The X component.\r\n\t\t * @param {Number} [y=0] - The Y component.\r\n\t\t * @param {Number} [z=0] - The Z component.\r\n\t\t * @param {Number} [w=0] - The W component.\r\n\t\t */\r\n\r\n\t\tconstructor(x = 0, y = 0, z = 0, w = 0) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The X component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.x = x;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Y component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Z component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.z = z;\r\n\r\n\t\t\t/**\r\n\t\t\t * The W component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.w = w;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this vector\r\n\t\t *\r\n\t\t * @param {Number} x - The X component.\r\n\t\t * @param {Number} y - The Y component.\r\n\t\t * @param {Number} z - The Z component.\r\n\t\t * @param {Number} w - The W component.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tset(x, y, z, w) {\r\n\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\t\tthis.w = w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of another vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tcopy(v) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} A clone of this vector.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor(this.x, this.y, this.z, this.w);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies values from an array.\r\n\t\t *\r\n\t\t * @param {Number[]} array - An array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tfromArray(array, offset = 0) {\r\n\r\n\t\t\tthis.x = array[offset];\r\n\t\t\tthis.y = array[offset + 1];\r\n\t\t\tthis.z = array[offset + 2];\r\n\t\t\tthis.w = array[offset + 3];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores this vector in an array.\r\n\t\t *\r\n\t\t * @param {Array} [array] - A target array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Number[]} The array.\r\n\t\t */\r\n\r\n\t\ttoArray(array = [], offset = 0) {\r\n\r\n\t\t\tarray[offset] = this.x;\r\n\t\t\tarray[offset + 1] = this.y;\r\n\t\t\tarray[offset + 2] = this.z;\r\n\t\t\tarray[offset + 3] = this.w;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores the axis angle from the given quaternion in this vector.\r\n\t\t *\r\n\t\t * For more details see:\r\n\t\t *  http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\t\t *\r\n\t\t * @param {Quaternion} q - A quaternion. Assumed to be normalized\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsetAxisAngleFromQuaternion(q) {\r\n\r\n\t\t\tthis.w = 2 * Math.acos(q.w);\r\n\r\n\t\t\tconst s = Math.sqrt(1 - q.w * q.w);\r\n\r\n\t\t\tif(s < 1e-4) {\r\n\r\n\t\t\t\tthis.x = 1;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = q.x / s;\r\n\t\t\t\tthis.y = q.y / s;\r\n\t\t\t\tthis.z = q.z / s;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores the axis angle from the given rotation matrix in this vector.\r\n\t\t *\r\n\t\t * For more details see:\r\n\t\t *  http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix. The upper 3x3 must be a pure rotation matrix (i.e. unscaled).\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsetAxisAngleFromRotationMatrix(m) {\r\n\r\n\t\t\t// Margin to allow for rounding errors.\r\n\t\t\tconst E = 0.01;\r\n\t\t\t// Margin to distinguish between 0 and 180 degrees.\r\n\t\t\tconst H = 0.1;\r\n\r\n\t\t\tconst me = m.elements;\r\n\t\t\tconst m00 = me[0], m01 = me[4], m02 = me[8];\r\n\t\t\tconst m10 = me[1], m11 = me[5], m12 = me[9];\r\n\t\t\tconst m20 = me[2], m21 = me[6], m22 = me[10];\r\n\r\n\t\t\tlet angle;\r\n\t\t\tlet x, y, z;\r\n\t\t\tlet xx, yy, zz;\r\n\t\t\tlet xy, xz, yz;\r\n\t\t\tlet s;\r\n\r\n\t\t\tif((Math.abs(m01 - m10) < E) && (Math.abs(m02 - m20) < E) && (Math.abs(m12 - m21) < E)) {\r\n\r\n\t\t\t\t/* Singularity found. First, check for identity matrix which must have +1\r\n\t\t\t\tfor all terms in the leading diagonal and zero in other terms. */\r\n\t\t\t\tif((Math.abs(m01 + m10) < H) && (Math.abs(m02 + m20) < H) && (Math.abs(m12 + m21) < H) && (Math.abs(m00 + m11 + m22 - 3) < H)) {\r\n\r\n\t\t\t\t\t// This singularity is the identity matrix. The angle is zero.\r\n\t\t\t\t\tthis.set(1, 0, 0, 0);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// The angle is 180.\r\n\t\t\t\t\tangle = Math.PI;\r\n\r\n\t\t\t\t\txx = (m00 + 1) / 2;\r\n\t\t\t\t\tyy = (m11 + 1) / 2;\r\n\t\t\t\t\tzz = (m22 + 1) / 2;\r\n\t\t\t\t\txy = (m01 + m10) / 4;\r\n\t\t\t\t\txz = (m02 + m20) / 4;\r\n\t\t\t\t\tyz = (m12 + m21) / 4;\r\n\r\n\t\t\t\t\tif((xx > yy) && (xx > zz)) {\r\n\r\n\t\t\t\t\t\t// m00 is the largest diagonal term.\r\n\t\t\t\t\t\tif(xx < E) {\r\n\r\n\t\t\t\t\t\t\tx = 0;\r\n\t\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tx = Math.sqrt(xx);\r\n\t\t\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if(yy > zz) {\r\n\r\n\t\t\t\t\t\t// m11 is the largest diagonal term.\r\n\t\t\t\t\t\tif(yy < E) {\r\n\r\n\t\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\t\ty = 0;\r\n\t\t\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ty = Math.sqrt(yy);\r\n\t\t\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// m22 is the largest diagonal term.\r\n\t\t\t\t\t\tif(zz < E) {\r\n\r\n\t\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tz = Math.sqrt(zz);\r\n\t\t\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.set(x, y, z, angle);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// There are no singularities.\r\n\t\t\t\ts = Math.sqrt(\r\n\t\t\t\t\t(m21 - m12) * (m21 - m12) +\r\n\t\t\t\t\t(m02 - m20) * (m02 - m20) +\r\n\t\t\t\t\t(m10 - m01) * (m10 - m01)\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Prevent division by zero.\r\n\t\t\t\tif(Math.abs(s) < 0.001) {\r\n\r\n\t\t\t\t\ts = 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.x = (m21 - m12) / s;\r\n\t\t\t\tthis.y = (m02 - m20) / s;\r\n\t\t\t\tthis.z = (m10 - m01) / s;\r\n\t\t\t\tthis.w = Math.acos((m00 + m11 + m22 - 1) / 2);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector4} v - The vector to add.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tadd(v) {\r\n\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\t\tthis.w += v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scalar to this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to add.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\taddScalar(s) {\r\n\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\t\tthis.w += s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the sum of two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector4} a - A vector.\r\n\t\t * @param {Vector4} b - Another vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\taddVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\t\tthis.w = a.w + b.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scaled vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector4} v - The vector to scale and add.\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\taddScaledVector(v, s) {\r\n\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\t\t\tthis.w += v.w * s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a vector from this vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - The vector to subtract.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsub(v) {\r\n\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\t\tthis.w -= v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a scalar from this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to subtract.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsubScalar(s) {\r\n\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\t\tthis.w -= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the difference between two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector4} a - A vector.\r\n\t\t * @param {Vector4} b - A second vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsubVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\t\tthis.w = a.w - b.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with another vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tmultiply(v) {\r\n\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\t\tthis.z *= v.z;\r\n\t\t\tthis.w *= v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tmultiplyScalar(s) {\r\n\r\n\t\t\tthis.x *= s;\r\n\t\t\tthis.y *= s;\r\n\t\t\tthis.z *= s;\r\n\t\t\tthis.w *= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the product of two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector4} a - A vector.\r\n\t\t * @param {Vector4} b - Another vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tmultiplyVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x * b.x;\r\n\t\t\tthis.y = a.y * b.y;\r\n\t\t\tthis.z = a.z * b.z;\r\n\t\t\tthis.w = a.w * b.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by another vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tdivide(v) {\r\n\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\t\tthis.z /= v.z;\r\n\t\t\tthis.w /= v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tdivideScalar(s) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\t\t\tthis.z /= s;\r\n\t\t\tthis.w /= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies a matrix to this vector.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tapplyMatrix4(m) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\r\n\t\t\tconst e = m.elements;\r\n\r\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\r\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\r\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\r\n\t\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Negates this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tnegate() {\r\n\r\n\t\t\tthis.x = -this.x;\r\n\t\t\tthis.y = -this.y;\r\n\t\t\tthis.z = -this.z;\r\n\t\t\tthis.w = -this.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the dot product with another vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Number} The dot product.\r\n\t\t */\r\n\r\n\t\tdot(v) {\r\n\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tmanhattanLength() {\r\n\r\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The squared length.\r\n\t\t */\r\n\r\n\t\tlengthSquared() {\r\n\r\n\t\t\treturn (\r\n\t\t\t\tthis.x * this.x +\r\n\t\t\t\tthis.y * this.y +\r\n\t\t\t\tthis.z * this.z +\r\n\t\t\t\tthis.w * this.w\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tlength() {\r\n\r\n\t\t\treturn Math.sqrt(\r\n\t\t\t\tthis.x * this.x +\r\n\t\t\t\tthis.y * this.y +\r\n\t\t\t\tthis.z * this.z +\r\n\t\t\t\tthis.w * this.w\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tmanhattanDistanceTo(v) {\r\n\r\n\t\t\treturn (\r\n\t\t\t\tMath.abs(this.x - v.x) +\r\n\t\t\t\tMath.abs(this.y - v.y) +\r\n\t\t\t\tMath.abs(this.z - v.z) +\r\n\t\t\t\tMath.abs(this.w - v.w)\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Number} The squared distance.\r\n\t\t */\r\n\r\n\t\tdistanceToSquared(v) {\r\n\r\n\t\t\tconst dx = this.x - v.x;\r\n\t\t\tconst dy = this.y - v.y;\r\n\t\t\tconst dz = this.z - v.z;\r\n\t\t\tconst dw = this.w - v.w;\r\n\r\n\t\t\treturn dx * dx + dy * dy + dz * dz + dw * dw;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tdistanceTo(v) {\r\n\r\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Normalizes this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tnormalize() {\r\n\r\n\t\t\treturn this.divideScalar(this.length());\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the length of this vector.\r\n\t\t *\r\n\t\t * @param {Number} length - The new length.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsetLength(length) {\r\n\r\n\t\t\treturn this.normalize().multiplyScalar(length);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the min value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tmin(v) {\r\n\r\n\t\t\tthis.x = Math.min(this.x, v.x);\r\n\t\t\tthis.y = Math.min(this.y, v.y);\r\n\t\t\tthis.z = Math.min(this.z, v.z);\r\n\t\t\tthis.w = Math.min(this.w, v.w);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the max value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tmax(v) {\r\n\r\n\t\t\tthis.x = Math.max(this.x, v.x);\r\n\t\t\tthis.y = Math.max(this.y, v.y);\r\n\t\t\tthis.z = Math.max(this.z, v.z);\r\n\t\t\tthis.w = Math.max(this.w, v.w);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clamps this vector.\r\n\t\t *\r\n\t\t * @param {Vector4} min - The lower bounds. Assumed to be smaller than max.\r\n\t\t * @param {Vector4} max - The upper bounds. Assumed to be greater than min.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tclamp(min, max) {\r\n\r\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\r\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\r\n\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\r\n\t\t\tthis.w = Math.max(min.w, Math.min(max.w, this.w));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Floors this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tfloor() {\r\n\r\n\t\t\tthis.x = Math.floor(this.x);\r\n\t\t\tthis.y = Math.floor(this.y);\r\n\t\t\tthis.z = Math.floor(this.z);\r\n\t\t\tthis.w = Math.floor(this.w);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Ceils this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tceil() {\r\n\r\n\t\t\tthis.x = Math.ceil(this.x);\r\n\t\t\tthis.y = Math.ceil(this.y);\r\n\t\t\tthis.z = Math.ceil(this.z);\r\n\t\t\tthis.w = Math.ceil(this.w);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rounds this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tround() {\r\n\r\n\t\t\tthis.x = Math.round(this.x);\r\n\t\t\tthis.y = Math.round(this.y);\r\n\t\t\tthis.z = Math.round(this.z);\r\n\t\t\tthis.w = Math.round(this.w);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Lerps towards the given vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tlerp(v, alpha) {\r\n\r\n\t\t\tthis.x += (v.x - this.x) * alpha;\r\n\t\t\tthis.y += (v.y - this.y) * alpha;\r\n\t\t\tthis.z += (v.z - this.z) * alpha;\r\n\t\t\tthis.w += (v.w - this.w) * alpha;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the lerp result of the given vectors.\r\n\t\t *\r\n\t\t * @param {Vector4} v1 - A base vector.\r\n\t\t * @param {Vector4} v2 - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tlerpVectors(v1, v2, alpha) {\r\n\r\n\t\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this vector equals the given one.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Boolean} Whether this vector equals the given one.\r\n\t\t */\r\n\r\n\t\tequals(v) {\r\n\r\n\t\t\treturn (v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Mathematical data structures.\r\n\t *\r\n\t * @module math-ds\r\n\t */\n\n\t/**\r\n\t * An enumeration of material constants.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {Number} AIR - Indicates empty space.\r\n\t * @property {Number} SOLID - Indicates solid material.\r\n\t */\r\n\r\n\tconst Material = {\r\n\r\n\t\tAIR: 0,\r\n\t\tSOLID: 1\r\n\r\n\t};\n\n\t/**\r\n\t * A CSG operation.\r\n\t */\r\n\r\n\tclass Operation {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new operation.\r\n\t\t *\r\n\t\t * @param {OperationType} type - The type of this operation.\r\n\t\t * @param {Operation} ...children - Child operations.\r\n\t\t */\r\n\r\n\t\tconstructor(type, ...children) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The type of this operation.\r\n\t\t\t *\r\n\t\t\t * @type {OperationType}\r\n\t\t\t */\r\n\r\n\t\t\tthis.type = type;\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of operations.\r\n\t\t\t *\r\n\t\t\t * Right-hand side operands have precedence, meaning that the result of the\r\n\t\t\t * first item in the list will be dominated by the result of the second one,\r\n\t\t\t * etc.\r\n\t\t\t *\r\n\t\t\t * @type {Operation[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.children = children;\r\n\r\n\t\t\t/**\r\n\t\t\t * The bounding box of this operation.\r\n\t\t\t *\r\n\t\t\t * @type {Box3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.boundingBox = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the complete bounding box of this CSG operation if it doesn't\r\n\t\t * exist yet and returns it.\r\n\t\t *\r\n\t\t * @return {Box3} The bounding box.\r\n\t\t */\r\n\r\n\t\tgetBoundingBox() {\r\n\r\n\t\t\tif(this.boundingBox === null) {\r\n\r\n\t\t\t\tthis.boundingBox = this.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.boundingBox;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the bounding box of this CSG operation while taking all child\r\n\t\t * operations into account.\r\n\t\t *\r\n\t\t * @return {Box3} The bounding box.\r\n\t\t */\r\n\r\n\t\tcomputeBoundingBox() {\r\n\r\n\t\t\tconst children = this.children;\r\n\t\t\tconst boundingBox = new Box3();\r\n\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\tboundingBox.union(children[i].getBoundingBox());\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn boundingBox;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A union operation.\r\n\t */\r\n\r\n\tclass Union extends Operation {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new union operation.\r\n\t\t *\r\n\t\t * @param {...Operation} children - Child operations.\r\n\t\t */\r\n\r\n\t\tconstructor(...children) {\r\n\r\n\t\t\tsuper(OperationType.UNION, ...children);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Updates the specified material index.\r\n\t\t *\r\n\t\t * @param {Number} index - The index of the material index that needs to be updated.\r\n\t\t * @param {HermiteData} data0 - The target volume data.\r\n\t\t * @param {HermiteData} data1 - Predominant volume data.\r\n\t\t */\r\n\r\n\t\tupdateMaterialIndex(index, data0, data1) {\r\n\r\n\t\t\tconst materialIndex = data1.materialIndices[index];\r\n\r\n\t\t\tif(materialIndex !== Material.AIR) {\r\n\r\n\t\t\t\tdata0.setMaterialIndex(index, materialIndex);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Selects the edge that is closer to the non-solid grid point.\r\n\t\t *\r\n\t\t * @param {Edge} edge0 - An existing edge.\r\n\t\t * @param {Edge} edge1 - A predominant edge.\r\n\t\t * @param {Boolean} s - Whether the starting point of the edge is solid.\r\n\t\t * @return {Edge} The selected edge.\r\n\t\t */\r\n\r\n\t\tselectEdge(edge0, edge1, s) {\r\n\r\n\t\t\treturn s ?\r\n\t\t\t\t((edge0.t > edge1.t) ? edge0 : edge1) :\r\n\t\t\t\t((edge0.t < edge1.t) ? edge0 : edge1);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A difference operation.\r\n\t */\r\n\r\n\tclass Difference extends Operation {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new difference operation.\r\n\t\t *\r\n\t\t * @param {Operation} ...children - Child operations.\r\n\t\t */\r\n\r\n\t\tconstructor(...children) {\r\n\r\n\t\t\tsuper(OperationType.DIFFERENCE, ...children);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Updates the specified material index.\r\n\t\t *\r\n\t\t * @param {Number} index - The index of the material index that needs to be updated.\r\n\t\t * @param {HermiteData} data0 - The target volume data.\r\n\t\t * @param {HermiteData} data1 - Predominant volume data.\r\n\t\t */\r\n\r\n\t\tupdateMaterialIndex(index, data0, data1) {\r\n\r\n\t\t\tif(data1.materialIndices[index] !== Material.AIR) {\r\n\r\n\t\t\t\tdata0.setMaterialIndex(index, Material.AIR);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Selects the edge that is closer to the solid grid point.\r\n\t\t *\r\n\t\t * @param {Edge} edge0 - An existing edge.\r\n\t\t * @param {Edge} edge1 - A predominant edge.\r\n\t\t * @param {Boolean} s - Whether the starting point of the edge is solid.\r\n\t\t * @return {Edge} The selected edge.\r\n\t\t */\r\n\r\n\t\tselectEdge(edge0, edge1, s) {\r\n\r\n\t\t\treturn s ?\r\n\t\t\t\t((edge0.t < edge1.t) ? edge0 : edge1) :\r\n\t\t\t\t((edge0.t > edge1.t) ? edge0 : edge1);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An intersection operation.\r\n\t */\r\n\r\n\tclass Intersection extends Operation {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new intersection operation.\r\n\t\t *\r\n\t\t * @param {...Operation} children - Child operations.\r\n\t\t */\r\n\r\n\t\tconstructor(...children) {\r\n\r\n\t\t\tsuper(OperationType.INTERSECTION, ...children);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Updates the specified material index.\r\n\t\t *\r\n\t\t * @param {Number} index - The index of the material index that needs to be updated.\r\n\t\t * @param {HermiteData} data0 - The target volume data.\r\n\t\t * @param {HermiteData} data1 - Predominant volume data.\r\n\t\t */\r\n\r\n\t\tupdateMaterialIndex(index, data0, data1) {\r\n\r\n\t\t\tconst materialIndex = data1.materialIndices[index];\r\n\r\n\t\t\tdata0.setMaterialIndex(index, (data0.materialIndices[index] !== Material.AIR && materialIndex !== Material.AIR) ? materialIndex : Material.AIR);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Selects the edge that is closer to the solid grid point.\r\n\t\t *\r\n\t\t * @param {Edge} edge0 - An existing edge.\r\n\t\t * @param {Edge} edge1 - A predominant edge.\r\n\t\t * @param {Boolean} s - Whether the starting point of the edge is solid.\r\n\t\t * @return {Edge} The selected edge.\r\n\t\t */\r\n\r\n\t\tselectEdge(edge0, edge1, s) {\r\n\r\n\t\t\treturn s ?\r\n\t\t\t\t((edge0.t < edge1.t) ? edge0 : edge1) :\r\n\t\t\t\t((edge0.t > edge1.t) ? edge0 : edge1);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Run-Length Encoding for numerical data.\r\n\t */\r\n\r\n\tclass RunLengthEncoding {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new container for Run-Length encoded data.\r\n\t\t *\r\n\t\t * @param {Number[]} [runLengths=null] - The run lengths.\r\n\t\t * @param {Number[]} [data=null] - The encoded data.\r\n\t\t */\r\n\r\n\t\tconstructor(runLengths = null, data = null) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The run lengths.\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.runLengths = runLengths;\r\n\r\n\t\t\t/**\r\n\t\t\t * The encoded data.\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = data;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Encodes the given data.\r\n\t\t *\r\n\t\t * @param {Number[]} array - The data to encode.\r\n\t\t * @return {RunLengthEncoding} The run-lengths and the encoded data.\r\n\t\t */\r\n\r\n\t\tstatic encode(array) {\r\n\r\n\t\t\tconst runLengths = [];\r\n\t\t\tconst data = [];\r\n\r\n\t\t\tlet previous = array[0];\r\n\t\t\tlet count = 1;\r\n\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 1, l = array.length; i < l; ++i) {\r\n\r\n\t\t\t\tif(previous !== array[i]) {\r\n\r\n\t\t\t\t\trunLengths.push(count);\r\n\t\t\t\t\tdata.push(previous);\r\n\r\n\t\t\t\t\tprevious = array[i];\r\n\t\t\t\t\tcount = 1;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t++count;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\trunLengths.push(count);\r\n\t\t\tdata.push(previous);\r\n\r\n\t\t\treturn new RunLengthEncoding(runLengths, data);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Decodes the given data.\r\n\t\t *\r\n\t\t * @param {Number[]} runLengths - The run-lengths.\r\n\t\t * @param {Number[]} data - The data to decode.\r\n\t\t * @param {Array} [array] - An optional target.\r\n\t\t * @return {Array} The decoded data.\r\n\t\t */\r\n\r\n\t\tstatic decode(runLengths, data, array = []) {\r\n\r\n\t\t\tlet element;\r\n\r\n\t\t\tlet i, j, il, jl;\r\n\t\t\tlet k = 0;\r\n\r\n\t\t\tfor(i = 0, il = data.length; i < il; ++i) {\r\n\r\n\t\t\t\telement = data[i];\r\n\r\n\t\t\t\tfor(j = 0, jl = runLengths[i]; j < jl; ++j) {\r\n\r\n\t\t\t\t\tarray[k++] = element;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A basic iterator result.\r\n\t *\r\n\t * The next method of an iterator always has to return an object with\r\n\t * appropriate properties including done and value.\r\n\t */\r\n\r\n\tclass IteratorResult {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new iterator result.\r\n\t\t *\r\n\t\t * @param {Vector3} [value=null] - A value.\r\n\t\t * @param {Vector3} [done=false] - Whether this result is past the end of the iterated sequence.\r\n\t\t */\r\n\r\n\t\tconstructor(value = null, done = false) {\r\n\r\n\t\t\t/**\r\n\t\t\t * An arbitrary value returned by the iterator.\r\n\t\t\t *\r\n\t\t\t * @type {Object}\r\n\t\t\t */\r\n\r\n\t\t\tthis.value = value;\r\n\r\n\t\t\t/**\r\n\t\t\t * Whether this result is past the end of the iterated sequence.\r\n\t\t\t *\r\n\t\t\t * @type {Boolean}\r\n\t\t\t */\r\n\r\n\t\t\tthis.done = done;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets this iterator result.\r\n\t\t */\r\n\r\n\t\treset() {\r\n\r\n\t\t\tthis.value = null;\r\n\t\t\tthis.done = false;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A compilation of the library components.\r\n\t *\r\n\t * @module iterator-result\r\n\t */\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst c$1 = new Vector3();\r\n\r\n\t/**\r\n\t * An octant.\r\n\t */\r\n\r\n\tclass Octant {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [min] - The lower bounds.\r\n\t\t * @param {Vector3} [max] - The upper bounds.\r\n\t\t */\r\n\r\n\t\tconstructor(min = new Vector3(), max = new Vector3()) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The lower bounds of this octant.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.min = min;\r\n\r\n\t\t\t/**\r\n\t\t\t * The upper bounds of the octant.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.max = max;\r\n\r\n\t\t\t/**\r\n\t\t\t * The children of this octant.\r\n\t\t\t *\r\n\t\t\t * @type {Octant[]}\r\n\t\t\t * @default null\r\n\t\t\t */\r\n\r\n\t\t\tthis.children = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the center of this octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the center of this octant.\r\n\t\t */\r\n\r\n\t\tgetCenter(target = new Vector3()) {\r\n\r\n\t\t\treturn target.addVectors(this.min, this.max).multiplyScalar(0.5);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the size of this octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the size of this octant.\r\n\t\t */\r\n\r\n\t\tgetDimensions(target = new Vector3()) {\r\n\r\n\t\t\treturn target.subVectors(this.max, this.min);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Splits this octant into eight smaller ones.\r\n\t\t */\r\n\r\n\t\tsplit() {\r\n\r\n\t\t\tconst min = this.min;\r\n\t\t\tconst max = this.max;\r\n\t\t\tconst mid = this.getCenter(c$1);\r\n\r\n\t\t\tconst children = this.children = [\r\n\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null\r\n\r\n\t\t\t];\r\n\r\n\t\t\tlet i, combination;\r\n\r\n\t\t\tfor(i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\tcombination = pattern[i];\r\n\r\n\t\t\t\tchildren[i] = new this.constructor(\r\n\r\n\t\t\t\t\tnew Vector3(\r\n\t\t\t\t\t\t(combination[0] === 0) ? min.x : mid.x,\r\n\t\t\t\t\t\t(combination[1] === 0) ? min.y : mid.y,\r\n\t\t\t\t\t\t(combination[2] === 0) ? min.z : mid.z\r\n\t\t\t\t\t),\r\n\r\n\t\t\t\t\tnew Vector3(\r\n\t\t\t\t\t\t(combination[0] === 0) ? mid.x : max.x,\r\n\t\t\t\t\t\t(combination[1] === 0) ? mid.y : max.y,\r\n\t\t\t\t\t\t(combination[2] === 0) ? mid.z : max.z\r\n\t\t\t\t\t)\r\n\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A binary pattern that describes the standard octant layout:\r\n\t *\r\n\t * ```text\r\n\t *    3____7\r\n\t *  2/___6/|\r\n\t *  | 1__|_5\r\n\t *  0/___4/\r\n\t * ```\r\n\t *\r\n\t * This common layout is crucial for positional assumptions.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t */\r\n\r\n\tconst pattern = [\r\n\r\n\t\tnew Uint8Array([0, 0, 0]),\r\n\t\tnew Uint8Array([0, 0, 1]),\r\n\t\tnew Uint8Array([0, 1, 0]),\r\n\t\tnew Uint8Array([0, 1, 1]),\r\n\r\n\t\tnew Uint8Array([1, 0, 0]),\r\n\t\tnew Uint8Array([1, 0, 1]),\r\n\t\tnew Uint8Array([1, 1, 0]),\r\n\t\tnew Uint8Array([1, 1, 1])\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * Describes all possible octant corner connections.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t */\r\n\r\n\tconst edges = [\r\n\r\n\t\t// X-Axis.\r\n\t\tnew Uint8Array([0, 4]),\r\n\t\tnew Uint8Array([1, 5]),\r\n\t\tnew Uint8Array([2, 6]),\r\n\t\tnew Uint8Array([3, 7]),\r\n\r\n\t\t// Y-Axis.\r\n\t\tnew Uint8Array([0, 2]),\r\n\t\tnew Uint8Array([1, 3]),\r\n\t\tnew Uint8Array([4, 6]),\r\n\t\tnew Uint8Array([5, 7]),\r\n\r\n\t\t// Z-Axis.\r\n\t\tnew Uint8Array([0, 1]),\r\n\t\tnew Uint8Array([2, 3]),\r\n\t\tnew Uint8Array([4, 5]),\r\n\t\tnew Uint8Array([6, 7])\r\n\r\n\t];\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst c$2 = new Vector3();\r\n\r\n\t/**\r\n\t * A cubic octant.\r\n\t */\r\n\r\n\tclass CubicOctant {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new cubic octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [min] - The lower bounds.\r\n\t\t * @param {Number} [size=0] - The size of the octant.\r\n\t\t */\r\n\r\n\t\tconstructor(min = new Vector3(), size = 0) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The lower bounds of this octant.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.min = min;\r\n\r\n\t\t\t/**\r\n\t\t\t * The size of this octant.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.size = size;\r\n\r\n\t\t\t/**\r\n\t\t\t * The children of this octant.\r\n\t\t\t *\r\n\t\t\t * @type {CubicOctant[]}\r\n\t\t\t * @default null\r\n\t\t\t */\r\n\r\n\t\t\tthis.children = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The upper bounds of this octant.\r\n\t\t *\r\n\t\t * Accessing this property always creates a new vector.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tget max() {\r\n\r\n\t\t\treturn this.min.clone().addScalar(this.size);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the center of this octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the center of this octant.\r\n\t\t */\r\n\r\n\t\tgetCenter(target = new Vector3()) {\r\n\r\n\t\t\treturn target.copy(this.min).addScalar(this.size * 0.5);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the size of this octant as a vector.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the size of this octant.\r\n\t\t */\r\n\r\n\t\tgetDimensions(target = new Vector3()) {\r\n\r\n\t\t\treturn target.set(this.size, this.size, this.size);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Splits this octant into eight smaller ones.\r\n\t\t */\r\n\r\n\t\tsplit() {\r\n\r\n\t\t\tconst min = this.min;\r\n\t\t\tconst mid = this.getCenter(c$2);\r\n\t\t\tconst halfSize = this.size * 0.5;\r\n\r\n\t\t\tconst children = this.children = [\r\n\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null\r\n\r\n\t\t\t];\r\n\r\n\t\t\tlet i, combination;\r\n\r\n\t\t\tfor(i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\tcombination = pattern[i];\r\n\r\n\t\t\t\tchildren[i] = new this.constructor(\r\n\r\n\t\t\t\t\tnew Vector3(\r\n\t\t\t\t\t\t(combination[0] === 0) ? min.x : mid.x,\r\n\t\t\t\t\t\t(combination[1] === 0) ? min.y : mid.y,\r\n\t\t\t\t\t\t(combination[2] === 0) ? min.z : mid.z\r\n\t\t\t\t\t),\r\n\r\n\t\t\t\t\thalfSize\r\n\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A 3D box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b$3 = new Box3();\r\n\r\n\t/**\r\n\t * An octant iterator.\r\n\t *\r\n\t * @implements {Iterator}\r\n\t * @implements {Iterable}\r\n\t */\r\n\r\n\tclass OctantIterator {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new octant iterator.\r\n\t\t *\r\n\t\t * @param {Octree} octree - An octree.\r\n\t\t * @param {Frustum|Box3} [region=null] - A cull region.\r\n\t\t */\r\n\r\n\t\tconstructor(octree, region = null) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The octree.\r\n\t\t\t *\r\n\t\t\t * @type {Octree}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.octree = octree;\r\n\r\n\t\t\t/**\r\n\t\t\t * A region used for octree culling.\r\n\t\t\t *\r\n\t\t\t * @type {Frustum|Box3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.region = region;\r\n\r\n\t\t\t/**\r\n\t\t\t * Whether this iterator should respect the cull region.\r\n\t\t\t *\r\n\t\t\t * @type {Boolean}\r\n\t\t\t */\r\n\r\n\t\t\tthis.cull = (region !== null);\r\n\r\n\t\t\t/**\r\n\t\t\t * An iterator result.\r\n\t\t\t *\r\n\t\t\t * @type {IteratorResult}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.result = new IteratorResult();\r\n\r\n\t\t\t/**\r\n\t\t\t * An octant trace.\r\n\t\t\t *\r\n\t\t\t * @type {Octant[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.trace = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * Iteration indices.\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.indices = null;\r\n\r\n\t\t\tthis.reset();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets this iterator.\r\n\t\t *\r\n\t\t * @return {OctantIterator} This iterator.\r\n\t\t */\r\n\r\n\t\treset() {\r\n\r\n\t\t\tconst root = this.octree.root;\r\n\r\n\t\t\tthis.trace = [];\r\n\t\t\tthis.indices = [];\r\n\r\n\t\t\tif(root !== null) {\r\n\r\n\t\t\t\tb$3.min = root.min;\r\n\t\t\t\tb$3.max = root.max;\r\n\r\n\t\t\t\tif(!this.cull || this.region.intersectsBox(b$3)) {\r\n\r\n\t\t\t\t\tthis.trace.push(root);\r\n\t\t\t\t\tthis.indices.push(0);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.result.reset();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Iterates over the leaf octants.\r\n\t\t *\r\n\t\t * @return {IteratorResult} The next leaf octant.\r\n\t\t */\r\n\r\n\t\tnext() {\r\n\r\n\t\t\tconst cull = this.cull;\r\n\t\t\tconst region = this.region;\r\n\t\t\tconst indices = this.indices;\r\n\t\t\tconst trace = this.trace;\r\n\r\n\t\t\tlet octant = null;\r\n\t\t\tlet depth = trace.length - 1;\r\n\r\n\t\t\tlet index, children, child;\r\n\r\n\t\t\twhile(octant === null && depth >= 0) {\r\n\r\n\t\t\t\tindex = indices[depth]++;\r\n\t\t\t\tchildren = trace[depth].children;\r\n\r\n\t\t\t\tif(index < 8) {\r\n\r\n\t\t\t\t\tif(children !== null) {\r\n\r\n\t\t\t\t\t\tchild = children[index];\r\n\r\n\t\t\t\t\t\tif(cull) {\r\n\r\n\t\t\t\t\t\t\tb$3.min = child.min;\r\n\t\t\t\t\t\t\tb$3.max = child.max;\r\n\r\n\t\t\t\t\t\t\tif(!region.intersectsBox(b$3)) {\r\n\r\n\t\t\t\t\t\t\t\t// Cull this octant.\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttrace.push(child);\r\n\t\t\t\t\t\tindices.push(0);\r\n\r\n\t\t\t\t\t\t++depth;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\toctant = trace.pop();\r\n\t\t\t\t\t\tindices.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttrace.pop();\r\n\t\t\t\t\tindices.pop();\r\n\r\n\t\t\t\t\t--depth;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.result.value = octant;\r\n\t\t\tthis.result.done = (octant === null);\r\n\r\n\t\t\treturn this.result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Called when this iterator will no longer be run to completion.\r\n\t\t *\r\n\t\t * @param {Object} value - An interator result value.\r\n\t\t * @return {IteratorResult} - A premature completion result.\r\n\t\t */\r\n\r\n\t\treturn(value) {\r\n\r\n\t\t\tthis.result.value = value;\r\n\t\t\tthis.result.done = true;\r\n\r\n\t\t\treturn this.result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns this iterator.\r\n\t\t *\r\n\t\t * @return {OctantIterator} An iterator.\r\n\t\t */\r\n\r\n\t\t[Symbol.iterator]() {\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A list of vectors.\r\n\t *\r\n\t * @type {Vector3[]}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst v$6 = [\r\n\t\tnew Vector3(),\r\n\t\tnew Vector3(),\r\n\t\tnew Vector3()\r\n\t];\r\n\r\n\t/**\r\n\t * A box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst b$4 = new Box3();\r\n\r\n\t/**\r\n\t * A ray.\r\n\t *\r\n\t * @type {Ray}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst r = new Ray();\r\n\r\n\t/**\r\n\t * A lookup-table containing octant ids. Used to determine the exit plane from\r\n\t * an octant.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst octantTable = [\r\n\r\n\t\tnew Uint8Array([4, 2, 1]),\r\n\t\tnew Uint8Array([5, 3, 8]),\r\n\t\tnew Uint8Array([6, 8, 3]),\r\n\t\tnew Uint8Array([7, 8, 8]),\r\n\t\tnew Uint8Array([8, 6, 5]),\r\n\t\tnew Uint8Array([8, 7, 8]),\r\n\t\tnew Uint8Array([8, 8, 7]),\r\n\t\tnew Uint8Array([8, 8, 8])\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * A byte that stores raycasting flags.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tlet flags = 0;\r\n\r\n\t/**\r\n\t * Finds the entry plane of the first octant that a ray travels through.\r\n\t *\r\n\t * Determining the first octant requires knowing which of the t0s is the\r\n\t * largest. The tms of the other axes must also be compared against that\r\n\t * largest t0.\r\n\t *\r\n\t * @private\r\n\t * @param {Number} tx0 - Ray projection parameter.\r\n\t * @param {Number} ty0 - Ray projection parameter.\r\n\t * @param {Number} tz0 - Ray projection parameter.\r\n\t * @param {Number} txm - Ray projection parameter mean.\r\n\t * @param {Number} tym - Ray projection parameter mean.\r\n\t * @param {Number} tzm - Ray projection parameter mean.\r\n\t * @return {Number} The index of the first octant that the ray travels through.\r\n\t */\r\n\r\n\tfunction findEntryOctant(tx0, ty0, tz0, txm, tym, tzm) {\r\n\r\n\t\tlet entry = 0;\r\n\r\n\t\t// Find the entry plane.\r\n\t\tif(tx0 > ty0 && tx0 > tz0) {\r\n\r\n\t\t\t// YZ-plane.\r\n\t\t\tif(tym < tx0) {\r\n\r\n\t\t\t\tentry |= 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(tzm < tx0) {\r\n\r\n\t\t\t\tentry |= 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if(ty0 > tz0) {\r\n\r\n\t\t\t// XZ-plane.\r\n\t\t\tif(txm < ty0) {\r\n\r\n\t\t\t\tentry |= 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(tzm < ty0) {\r\n\r\n\t\t\t\tentry |= 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// XY-plane.\r\n\t\t\tif(txm < tz0) {\r\n\r\n\t\t\t\tentry |= 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(tym < tz0) {\r\n\r\n\t\t\t\tentry |= 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn entry;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finds the next octant that intersects with the ray based on the exit plane of\r\n\t * the current one.\r\n\t *\r\n\t * @private\r\n\t * @param {Number} currentOctant - The index of the current octant.\r\n\t * @param {Number} tx1 - Ray projection parameter.\r\n\t * @param {Number} ty1 - Ray projection parameter.\r\n\t * @param {Number} tz1 - Ray projection parameter.\r\n\t * @return {Number} The index of the next octant that the ray travels through.\r\n\t */\r\n\r\n\tfunction findNextOctant(currentOctant, tx1, ty1, tz1) {\r\n\r\n\t\tlet min;\r\n\t\tlet exit = 0;\r\n\r\n\t\t// Find the exit plane.\r\n\t\tif(tx1 < ty1) {\r\n\r\n\t\t\tmin = tx1;\r\n\t\t\texit = 0; // YZ-plane.\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin = ty1;\r\n\t\t\texit = 1; // XZ-plane.\r\n\r\n\t\t}\r\n\r\n\t\tif(tz1 < min) {\r\n\r\n\t\t\texit = 2; // XY-plane.\r\n\r\n\t\t}\r\n\r\n\t\treturn octantTable[currentOctant][exit];\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finds all octants that intersect with the given ray.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - The current octant.\r\n\t * @param {Number} tx0 - Ray projection parameter. Initial tx0 = (minX - rayOriginX) / rayDirectionX.\r\n\t * @param {Number} ty0 - Ray projection parameter. Initial ty0 = (minY - rayOriginY) / rayDirectionY.\r\n\t * @param {Number} tz0 - Ray projection parameter. Initial tz0 = (minZ - rayOriginZ) / rayDirectionZ.\r\n\t * @param {Number} tx1 - Ray projection parameter. Initial tx1 = (maxX - rayOriginX) / rayDirectionX.\r\n\t * @param {Number} ty1 - Ray projection parameter. Initial ty1 = (maxY - rayOriginY) / rayDirectionY.\r\n\t * @param {Number} tz1 - Ray projection parameter. Initial tz1 = (maxZ - rayOriginZ) / rayDirectionZ.\r\n\t * @param {Raycaster} raycaster - The raycaster.\r\n\t * @param {Array} intersects - An array to be filled with the intersecting octants.\r\n\t */\r\n\r\n\tfunction raycastOctant(octant, tx0, ty0, tz0, tx1, ty1, tz1, raycaster, intersects) {\r\n\r\n\t\tconst children = octant.children;\r\n\r\n\t\tlet currentOctant;\r\n\t\tlet txm, tym, tzm;\r\n\r\n\t\tif(tx1 >= 0.0 && ty1 >= 0.0 && tz1 >= 0.0) {\r\n\r\n\t\t\tif(children === null) {\r\n\r\n\t\t\t\t// Leaf.\r\n\t\t\t\tintersects.push(octant);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Compute means.\r\n\t\t\t\ttxm = 0.5 * (tx0 + tx1);\r\n\t\t\t\ttym = 0.5 * (ty0 + ty1);\r\n\t\t\t\ttzm = 0.5 * (tz0 + tz1);\r\n\r\n\t\t\t\tcurrentOctant = findEntryOctant(tx0, ty0, tz0, txm, tym, tzm);\r\n\r\n\t\t\t\tdo {\r\n\r\n\t\t\t\t\t/* The possibilities for the next node are passed in the same respective\r\n\t\t\t\t\t * order as the t-values. Hence, if the first value is found to be the\r\n\t\t\t\t\t * greatest, the fourth one will be returned. If the second value is the\r\n\t\t\t\t\t * greatest, the fifth one will be returned, etc.\r\n\t\t\t\t\t */\r\n\r\n\t\t\t\t\tswitch(currentOctant) {\r\n\r\n\t\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\t\traycastOctant(children[flags], tx0, ty0, tz0, txm, tym, tzm, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, txm, tym, tzm);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 1], tx0, ty0, tzm, txm, tym, tz1, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, txm, tym, tz1);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 2], tx0, tym, tz0, txm, ty1, tzm, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, txm, ty1, tzm);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 3], tx0, tym, tzm, txm, ty1, tz1, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, txm, ty1, tz1);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 4], txm, ty0, tz0, tx1, tym, tzm, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, tx1, tym, tzm);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 5], txm, ty0, tzm, tx1, tym, tz1, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, tx1, tym, tz1);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 6], txm, tym, tz0, tx1, ty1, tzm, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, tx1, ty1, tzm);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 7:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 7], txm, tym, tzm, tx1, ty1, tz1, raycaster, intersects);\r\n\t\t\t\t\t\t\t// Far top right octant. No other octants can be reached from here.\r\n\t\t\t\t\t\t\tcurrentOctant = 8;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} while(currentOctant < 8);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * An octree raycaster.\r\n\t *\r\n\t * Based on:\r\n\t *  \"An Efficient Parametric Algorithm for Octree Traversal\"\r\n\t *  by J. Revelles et al. (2000).\r\n\t */\r\n\r\n\tclass OctreeRaycaster {\r\n\r\n\t\t/**\r\n\t\t * Finds the octants that intersect with the given ray. The intersecting\r\n\t\t * octants are sorted by distance, closest first.\r\n\t\t *\r\n\t\t * @param {Octree} octree - An octree.\r\n\t\t * @param {Raycaster} raycaster - A raycaster.\r\n\t\t * @param {Array} intersects - A list to be filled with intersecting octants.\r\n\t\t */\r\n\r\n\t\tstatic intersectOctree(octree, raycaster, intersects) {\r\n\r\n\t\t\t// Translate the octree extents to the scene origin.\r\n\t\t\tconst min = b$4.min.set(0, 0, 0);\r\n\t\t\tconst max = b$4.max.subVectors(octree.max, octree.min);\r\n\r\n\t\t\tconst dimensions = octree.getDimensions(v$6[0]);\r\n\t\t\tconst halfDimensions = v$6[1].copy(dimensions).multiplyScalar(0.5);\r\n\r\n\t\t\tconst origin = r.origin.copy(raycaster.ray.origin);\r\n\t\t\tconst direction = r.direction.copy(raycaster.ray.direction);\r\n\r\n\t\t\tlet invDirX, invDirY, invDirZ;\r\n\t\t\tlet tx0, tx1, ty0, ty1, tz0, tz1;\r\n\r\n\t\t\t// Translate the ray to the center of the octree.\r\n\t\t\torigin.sub(octree.getCenter(v$6[2])).add(halfDimensions);\r\n\r\n\t\t\t// Reset all flags.\r\n\t\t\tflags = 0;\r\n\r\n\t\t\t// Handle rays with negative directions.\r\n\t\t\tif(direction.x < 0.0) {\r\n\r\n\t\t\t\torigin.x = dimensions.x - origin.x;\r\n\t\t\t\tdirection.x = -direction.x;\r\n\t\t\t\tflags |= 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(direction.y < 0.0) {\r\n\r\n\t\t\t\torigin.y = dimensions.y - origin.y;\r\n\t\t\t\tdirection.y = -direction.y;\r\n\t\t\t\tflags |= 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(direction.z < 0.0) {\r\n\r\n\t\t\t\torigin.z = dimensions.z - origin.z;\r\n\t\t\t\tdirection.z = -direction.z;\r\n\t\t\t\tflags |= 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Improve IEEE double stability.\r\n\t\t\tinvDirX = 1.0 / direction.x;\r\n\t\t\tinvDirY = 1.0 / direction.y;\r\n\t\t\tinvDirZ = 1.0 / direction.z;\r\n\r\n\t\t\t// Project the ray to the root's boundaries.\r\n\t\t\ttx0 = (min.x - origin.x) * invDirX;\r\n\t\t\ttx1 = (max.x - origin.x) * invDirX;\r\n\t\t\tty0 = (min.y - origin.y) * invDirY;\r\n\t\t\tty1 = (max.y - origin.y) * invDirY;\r\n\t\t\ttz0 = (min.z - origin.z) * invDirZ;\r\n\t\t\ttz1 = (max.z - origin.z) * invDirZ;\r\n\r\n\t\t\t// Check if the ray hits the octree.\r\n\t\t\tif(Math.max(Math.max(tx0, ty0), tz0) < Math.min(Math.min(tx1, ty1), tz1)) {\r\n\r\n\t\t\t\t// Find the intersecting octants.\r\n\t\t\t\traycastOctant(octree.root, tx0, ty0, tz0, tx1, ty1, tz1, raycaster, intersects);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A 3D box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b$5 = new Box3();\r\n\r\n\t/**\r\n\t * Recursively calculates the depth of the given octree.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - An octant.\r\n\t * @return {Number} The depth.\r\n\t */\r\n\r\n\tfunction getDepth(octant) {\r\n\r\n\t\tconst children = octant.children;\r\n\r\n\t\tlet result = 0;\r\n\t\tlet i, l, d;\r\n\r\n\t\tif(children !== null) {\r\n\r\n\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\td = 1 + getDepth(children[i]);\r\n\r\n\t\t\t\tif(d > result) {\r\n\r\n\t\t\t\t\tresult = d;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Recursively collects octants that lie inside the specified region.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - An octant.\r\n\t * @param {Frustum|Box3} region - A region.\r\n\t * @param {Octant[]} result - A list to be filled with octants that intersect with the region.\r\n\t */\r\n\r\n\tfunction cull(octant, region, result) {\r\n\r\n\t\tconst children = octant.children;\r\n\r\n\t\tlet i, l;\r\n\r\n\t\tb$5.min = octant.min;\r\n\t\tb$5.max = octant.max;\r\n\r\n\t\tif(region.intersectsBox(b$5)) {\r\n\r\n\t\t\tif(children !== null) {\r\n\r\n\t\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\t\tcull(children[i], region, result);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult.push(octant);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Recursively fetches all octants with the specified depth level.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - An octant.\r\n\t * @param {Number} level - The target depth level.\r\n\t * @param {Number} depth - The current depth level.\r\n\t * @param {Octant[]} result - A list to be filled with the identified octants.\r\n\t */\r\n\r\n\tfunction findOctantsByLevel(octant, level, depth, result) {\r\n\r\n\t\tconst children = octant.children;\r\n\r\n\t\tlet i, l;\r\n\r\n\t\tif(depth === level) {\r\n\r\n\t\t\tresult.push(octant);\r\n\r\n\t\t} else if(children !== null) {\r\n\r\n\t\t\t++depth;\r\n\r\n\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\tfindOctantsByLevel(children[i], level, depth, result);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * An octree that subdivides space for fast spatial searches.\r\n\t *\r\n\t * @implements {Iterable}\r\n\t */\r\n\r\n\tclass Octree {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new octree.\r\n\t\t *\r\n\t\t * @param {Vector3} [min] - The lower bounds of the tree. If not provided, the octree will not create a root node.\r\n\t\t * @param {Vector3} [max] - The upper bounds of the tree. If not provided, the octree will not create a root node.\r\n\t\t */\r\n\r\n\t\tconstructor(min, max) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The root octant.\r\n\t\t\t *\r\n\t\t\t * @type {Octant}\r\n\t\t\t * @default null\r\n\t\t\t */\r\n\r\n\t\t\tthis.root = (min !== undefined && max !== undefined) ? new Octant(min, max) : null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The lower bounds of the root octant.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tget min() {\r\n\r\n\t\t\treturn this.root.min;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The upper bounds of the root octant.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tget max() {\r\n\r\n\t\t\treturn this.root.max;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The children of the root octant.\r\n\t\t *\r\n\t\t * @type {Octant[]}\r\n\t\t */\r\n\r\n\t\tget children() {\r\n\r\n\t\t\treturn this.root.children;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the center of this octree.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the center of this octree.\r\n\t\t */\r\n\r\n\t\tgetCenter(target) {\r\n\r\n\t\t\treturn this.root.getCenter(target);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the size of this octree.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the size of this octree.\r\n\t\t */\r\n\r\n\t\tgetDimensions(target) {\r\n\r\n\t\t\treturn this.root.getDimensions(target);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the current depth of this octree.\r\n\t\t *\r\n\t\t * @return {Number} The depth.\r\n\t\t */\r\n\r\n\t\tgetDepth() {\r\n\r\n\t\t\treturn getDepth(this.root);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Recursively collects octants that intersect with the specified region.\r\n\t\t *\r\n\t\t * @param {Frustum|Box3} region - A region.\r\n\t\t * @return {Octant[]} The octants.\r\n\t\t */\r\n\r\n\t\tcull(region) {\r\n\r\n\t\t\tconst result = [];\r\n\r\n\t\t\tcull(this.root, region, result);\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Fetches all octants with the specified depth level.\r\n\t\t *\r\n\t\t * @param {Number} level - The depth level.\r\n\t\t * @return {Octant[]} The octants.\r\n\t\t */\r\n\r\n\t\tfindOctantsByLevel(level) {\r\n\r\n\t\t\tconst result = [];\r\n\r\n\t\t\tfindOctantsByLevel(this.root, level, 0, result);\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the octants that intersect with the given ray. The intersecting\r\n\t\t * octants are sorted by distance, closest first.\r\n\t\t *\r\n\t\t * @param {Raycaster} raycaster - A raycaster.\r\n\t\t * @param {Octant[]} [intersects] - An optional target list to be filled with the intersecting octants.\r\n\t\t * @return {Octant[]} The intersecting octants.\r\n\t\t */\r\n\r\n\t\traycast(raycaster, intersects = []) {\r\n\r\n\t\t\tOctreeRaycaster.intersectOctree(this, raycaster, intersects);\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns an iterator that traverses the octree and returns leaf nodes.\r\n\t\t *\r\n\t\t * When a cull region is provided, the iterator will only return leaves that\r\n\t\t * intersect with that region.\r\n\t\t *\r\n\t\t * @param {Frustum|Box3} [region] - A cull region.\r\n\t\t * @return {OctantIterator} An iterator.\r\n\t\t */\r\n\r\n\t\tleaves(region) {\r\n\r\n\t\t\treturn new OctantIterator(this, region);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns an iterator that traverses the octree and returns all leaf nodes.\r\n\t\t *\r\n\t\t * @return {OctantIterator} An iterator.\r\n\t\t */\r\n\r\n\t\t[Symbol.iterator]() {\r\n\r\n\t\t\treturn new OctantIterator(this);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Core components.\r\n\t *\r\n\t * @module sparse-octree/core\r\n\t */\n\n\t/**\r\n\t * A collection of ray-point intersection data.\r\n\t */\n\n\t/**\r\n\t * Point-oriented octree components.\r\n\t *\r\n\t * @module sparse-octree/points\r\n\t */\n\n\t/**\r\n\t * Octree utilities.\r\n\t *\r\n\t * @module sparse-octree/utils\r\n\t */\n\n\t/**\r\n\t * Exposure of the library components.\r\n\t *\r\n\t * @module sparse-octree\r\n\t */\n\n\t/**\r\n\t * An isovalue bias for the Zero Crossing approximation.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst ISOVALUE_BIAS = 1e-4;\r\n\r\n\t/**\r\n\t * An error threshold for the Zero Crossing approximation.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst INTERVAL_THRESHOLD = 1e-6;\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst ab = new Vector3();\r\n\r\n\t/**\r\n\t * A point.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst p$1 = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v$8 = new Vector3();\r\n\r\n\t/**\r\n\t * An edge between two material grid points.\r\n\t */\r\n\r\n\tclass Edge {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new edge.\r\n\t\t *\r\n\t\t * @param {Vector3} [a] - A starting point. If none is provided, a new vector will be created.\r\n\t\t * @param {Vector3} [b] - An ending point. If none is provided, a new vector will be created.\r\n\t\t */\r\n\r\n\t\tconstructor(a = new Vector3(), b = new Vector3()) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The starting point of the edge.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.a = a;\r\n\r\n\t\t\t/**\r\n\t\t\t * The ending point of the edge.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.b = b;\r\n\r\n\t\t\t/**\r\n\t\t\t * The index of the starting material grid point.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.index = -1;\r\n\r\n\t\t\t/**\r\n\t\t\t * The local grid coordinates of the starting point.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.coordinates = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * The Zero Crossing interpolation value.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.t = 0.0;\r\n\r\n\t\t\t/**\r\n\t\t\t * The surface normal at the Zero Crossing position.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.n = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Approximates the smallest density along the edge.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - A density field.\r\n\t\t * @param {Number} [steps=8] - The maximum number of interpolation steps. Cannot be smaller than 2.\r\n\t\t */\r\n\r\n\t\tapproximateZeroCrossing(sdf, steps = 8) {\r\n\r\n\t\t\tconst s = Math.max(1, steps - 1);\r\n\r\n\t\t\tlet a = 0.0;\r\n\t\t\tlet b = 1.0;\r\n\t\t\tlet c = 0.0;\r\n\t\t\tlet i = 0;\r\n\r\n\t\t\tlet densityA, densityC;\r\n\r\n\t\t\t// Compute the vector from a to b.\r\n\t\t\tab.subVectors(this.b, this.a);\r\n\r\n\t\t\t// Use bisection to find the root of the SDF.\r\n\t\t\twhile(i <= s) {\r\n\r\n\t\t\t\tc = (a + b) / 2;\r\n\r\n\t\t\t\tp$1.addVectors(this.a, v$8.copy(ab).multiplyScalar(c));\r\n\t\t\t\tdensityC = sdf.sample(p$1);\r\n\r\n\t\t\t\tif(Math.abs(densityC) <= ISOVALUE_BIAS || (b - a) / 2 <= INTERVAL_THRESHOLD) {\r\n\r\n\t\t\t\t\t// Solution found.\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tp$1.addVectors(this.a, v$8.copy(ab).multiplyScalar(a));\r\n\t\t\t\t\tdensityA = sdf.sample(p$1);\r\n\r\n\t\t\t\t\tif(Math.sign(densityC) === Math.sign(densityA)) {\r\n\r\n\t\t\t\t\t\ta = c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tb = c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++i;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.t = c;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Zero Crossing position.\r\n\t\t *\r\n\t\t * @param {Vector3} target - A target for the Zero Crossing position. If none is provided, a new vector will be created.\r\n\t\t * @return {Vector3} The Zero Crossing position.\r\n\t\t */\r\n\r\n\t\tcomputeZeroCrossingPosition(target = new Vector3()) {\r\n\r\n\t\t\treturn target.subVectors(this.b, this.a).multiplyScalar(this.t).add(this.a);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the normal of the surface at the edge intersection.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - A density field.\r\n\t\t * @return {Vector3} The normal.\r\n\t\t * @todo Use analytical derivation instead of finite differences.\r\n\t\t */\r\n\r\n\t\tcomputeSurfaceNormal(sdf) {\r\n\r\n\t\t\tconst position = this.computeZeroCrossingPosition(ab);\r\n\t\t\tconst E = 1e-3;\r\n\r\n\t\t\tconst dx = sdf.sample(p$1.addVectors(position, v$8.set(E, 0, 0))) - sdf.sample(p$1.subVectors(position, v$8.set(E, 0, 0)));\r\n\t\t\tconst dy = sdf.sample(p$1.addVectors(position, v$8.set(0, E, 0))) - sdf.sample(p$1.subVectors(position, v$8.set(0, E, 0)));\r\n\t\t\tconst dz = sdf.sample(p$1.addVectors(position, v$8.set(0, 0, E))) - sdf.sample(p$1.subVectors(position, v$8.set(0, 0, E)));\r\n\r\n\t\t\tthis.n.set(dx, dy, dz).normalize();\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An edge.\r\n\t *\r\n\t * @type {Edge}\r\n\t * @private\r\n\t */\r\n\r\n\tconst edge = new Edge();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst offsetA = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst offsetB = new Vector3();\r\n\r\n\t/**\r\n\t * An edge iterator.\r\n\t *\r\n\t * @implements {Iterator}\r\n\t * @implements {Iterable}\r\n\t */\r\n\r\n\tclass EdgeIterator {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new edge iterator.\r\n\t\t *\r\n\t\t * @param {EdgeData} edgeData - A set of edge data.\r\n\t\t * @param {Vector3} cellPosition - The position of the data cell.\r\n\t\t * @param {Number} cellSize - The size of the data cell.\r\n\t\t * @param {Number} [c=0] - The dimension index to start at.\r\n\t\t * @param {Number} [d=3] - The dimension limit.\r\n\t\t */\r\n\r\n\t\tconstructor(edgeData, cellPosition, cellSize, c = 0, d = 3) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The edge data.\r\n\t\t\t *\r\n\t\t\t * @type {EdgeData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.edgeData = edgeData;\r\n\r\n\t\t\t/**\r\n\t\t\t * The data cell position.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellPosition = cellPosition;\r\n\r\n\t\t\t/**\r\n\t\t\t * The data cell size.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellSize = cellSize;\r\n\r\n\t\t\t/**\r\n\t\t\t * The edges.\r\n\t\t\t *\r\n\t\t\t * @type {Uint32Array[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.indices = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Zero Crossings.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.zeroCrossings = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The intersection normals.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.normals = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The axes of the existing edges.\r\n\t\t\t *\r\n\t\t\t * @type {Uint8Array[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.axes = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The amount of edges for each internal set of edges (X -> Y -> Z).\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.lengths = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * An iterator result.\r\n\t\t\t *\r\n\t\t\t * @type {IteratorResult}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.result = new IteratorResult();\r\n\r\n\t\t\t/**\r\n\t\t\t * The initial dimension index.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.initialC = c;\r\n\r\n\t\t\t/**\r\n\t\t\t * The current dimension index.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.c = c;\r\n\r\n\t\t\t/**\r\n\t\t\t * The initial dimension limit.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.initialD = d;\r\n\r\n\t\t\t/**\r\n\t\t\t * The dimension limit.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.d = d;\r\n\r\n\t\t\t/**\r\n\t\t\t * The current iteration index.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.i = 0;\r\n\r\n\t\t\t/**\r\n\t\t\t * The current iteration limit.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.l = 0;\r\n\r\n\t\t\tthis.reset();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets this iterator.\r\n\t\t *\r\n\t\t * @return {EdgeIterator} This iterator.\r\n\t\t */\r\n\r\n\t\treset() {\r\n\r\n\t\t\tconst edgeData = this.edgeData;\r\n\t\t\tconst indices = [];\r\n\t\t\tconst zeroCrossings = [];\r\n\t\t\tconst normals = [];\r\n\t\t\tconst axes = [];\r\n\t\t\tconst lengths = [];\r\n\r\n\t\t\tlet a, c, d, l;\r\n\r\n\t\t\tthis.i = 0;\r\n\t\t\tthis.c = 0;\r\n\t\t\tthis.d = 0;\r\n\r\n\t\t\t// Create a collection of edges without empty arrays.\r\n\t\t\tfor(c = this.initialC, a = 4 >> c, d = this.initialD; c < d; ++c, a >>= 1) {\r\n\r\n\t\t\t\tl = edgeData.indices[c].length;\r\n\r\n\t\t\t\tif(l > 0) {\r\n\r\n\t\t\t\t\tindices.push(edgeData.indices[c]);\r\n\t\t\t\t\tzeroCrossings.push(edgeData.zeroCrossings[c]);\r\n\t\t\t\t\tnormals.push(edgeData.normals[c]);\r\n\t\t\t\t\taxes.push(pattern[a]);\r\n\t\t\t\t\tlengths.push(l);\r\n\r\n\t\t\t\t\t++this.d;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.l = (lengths.length > 0) ? lengths[0] : 0;\r\n\r\n\t\t\tthis.indices = indices;\r\n\t\t\tthis.zeroCrossings = zeroCrossings;\r\n\t\t\tthis.normals = normals;\r\n\t\t\tthis.axes = axes;\r\n\t\t\tthis.lengths = lengths;\r\n\r\n\t\t\tthis.result.reset();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Iterates over the edges.\r\n\t\t *\r\n\t\t * @return {IteratorResult} The next edge.\r\n\t\t */\r\n\r\n\t\tnext() {\r\n\r\n\t\t\tconst s = this.cellSize;\r\n\t\t\tconst n = this.edgeData.resolution;\r\n\t\t\tconst m = n + 1;\r\n\t\t\tconst mm = m * m;\r\n\r\n\t\t\tconst result = this.result;\r\n\t\t\tconst base = this.cellPosition;\r\n\r\n\t\t\tlet axis, index;\r\n\t\t\tlet x, y, z;\r\n\t\t\tlet c, i;\r\n\r\n\t\t\t// Has the end been reached?\r\n\t\t\tif(this.i === this.l) {\r\n\r\n\t\t\t\t// Move on to the next set of edges (X -> Y -> Z).\r\n\t\t\t\tthis.l = (++this.c < this.d) ? this.lengths[this.c] : 0;\r\n\t\t\t\tthis.i = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Are there any edges left?\r\n\t\t\tif(this.i < this.l) {\r\n\r\n\t\t\t\tc = this.c;\r\n\t\t\t\ti = this.i;\r\n\r\n\t\t\t\taxis = this.axes[c];\r\n\r\n\t\t\t\t// Each edge is uniquely described by its starting grid point index.\r\n\t\t\t\tindex = this.indices[c][i];\r\n\t\t\t\tedge.index = index;\r\n\r\n\t\t\t\t// Calculate the local grid coordinates from the one-dimensional index.\r\n\t\t\t\tx = index % m;\r\n\t\t\t\ty = Math.trunc((index % mm) / m);\r\n\t\t\t\tz = Math.trunc(index / mm);\r\n\r\n\t\t\t\tedge.coordinates.set(x, y, z);\r\n\r\n\t\t\t\toffsetA.set(\r\n\t\t\t\t\tx * s / n,\r\n\t\t\t\t\ty * s / n,\r\n\t\t\t\t\tz * s / n\r\n\t\t\t\t);\r\n\r\n\t\t\t\toffsetB.set(\r\n\t\t\t\t\t(x + axis[0]) * s / n,\r\n\t\t\t\t\t(y + axis[1]) * s / n,\r\n\t\t\t\t\t(z + axis[2]) * s / n\r\n\t\t\t\t);\r\n\r\n\t\t\t\tedge.a.addVectors(base, offsetA);\r\n\t\t\t\tedge.b.addVectors(base, offsetB);\r\n\r\n\t\t\t\tedge.t = this.zeroCrossings[c][i];\r\n\t\t\t\tedge.n.fromArray(this.normals[c], i * 3);\r\n\r\n\t\t\t\tresult.value = edge;\r\n\r\n\t\t\t\t++this.i;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// There are no more edges left.\r\n\t\t\t\tresult.value = null;\r\n\t\t\t\tresult.done = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Called when this iterator will no longer be run to completion.\r\n\t\t *\r\n\t\t * @param {Object} value - An interator result value.\r\n\t\t * @return {IteratorResult} - A premature completion result.\r\n\t\t */\r\n\r\n\t\treturn(value) {\r\n\r\n\t\t\tthis.result.value = value;\r\n\t\t\tthis.result.done = true;\r\n\r\n\t\t\treturn this.result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns this iterator.\r\n\t\t *\r\n\t\t * @return {EdteIterator} An iterator.\r\n\t\t */\r\n\r\n\t\t[Symbol.iterator]() {\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Stores edge data separately for each dimension.\r\n\t *\r\n\t * With a grid resolution N, there are `3 * (N + 1)² * N` edges in total, but\r\n\t * the number of edges that actually contain the volume's surface is usually\r\n\t * much lower.\r\n\t *\r\n\t * @implements {Serializable}\r\n\t * @implements {Deserializable}\r\n\t * @implements {TransferableContainer}\r\n\t */\r\n\r\n\tclass EdgeData {\r\n\r\n\t\t/**\r\n\t\t * Constructs new edge data.\r\n\t\t *\r\n\t\t * @param {Number} n - The material grid resolution.\r\n\t\t * @param {Number} [x=0] - The amount of edges along the X-axis. If <= 0, no memory will be allocated.\r\n\t\t * @param {Number} [y=x] - The amount of edges along the Y-axis. If omitted, this will be the same as x.\r\n\t\t * @param {Number} [z=x] - The amount of edges along the Z-axis. If omitted, this will be the same as x.\r\n\t\t */\r\n\r\n\t\tconstructor(n, x = 0, y = x, z = x) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The material grid resolution.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.resolution = n;\r\n\r\n\t\t\t/**\r\n\t\t\t * The edges.\r\n\t\t\t *\r\n\t\t\t * Edges are stored as starting grid point indices in ascending order. The\r\n\t\t\t * ending point indices are implicitly defined through the dimension split:\r\n\t\t\t *\r\n\t\t\t * Given a starting point index A, the ending point index B for the X-, Y-\r\n\t\t\t * and Z-axis is defined as `A + 1`, `A + N` and `A + N²` respectively where\r\n\t\t\t * N is the grid resolution + 1.\r\n\t\t\t *\r\n\t\t\t * @type {Uint32Array[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.indices = (x <= 0) ? null : [\r\n\t\t\t\tnew Uint32Array(x),\r\n\t\t\t\tnew Uint32Array(y),\r\n\t\t\t\tnew Uint32Array(z)\r\n\t\t\t];\r\n\r\n\t\t\t/**\r\n\t\t\t * The Zero Crossing interpolation values.\r\n\t\t\t *\r\n\t\t\t * Each value describes the relative surface intersection position on the\r\n\t\t\t * respective edge. The values correspond to the order of the edges.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.zeroCrossings = (x <= 0) ? null : [\r\n\t\t\t\tnew Float32Array(x),\r\n\t\t\t\tnew Float32Array(y),\r\n\t\t\t\tnew Float32Array(z)\r\n\t\t\t];\r\n\r\n\t\t\t/**\r\n\t\t\t * The surface intersection normals.\r\n\t\t\t *\r\n\t\t\t * The vectors are stored as [x, y, z] float triples and correspond to the\r\n\t\t\t * order of the edges.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.normals = (x <= 0) ? null : [\r\n\t\t\t\tnew Float32Array(x * 3),\r\n\t\t\t\tnew Float32Array(y * 3),\r\n\t\t\t\tnew Float32Array(z * 3)\r\n\t\t\t];\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Serialises this data.\r\n\t\t *\r\n\t\t * @param {Boolean} [deflate=false] - Whether the data should be compressed if possible.\r\n\t\t * @return {Object} The serialised data.\r\n\t\t */\r\n\r\n\t\tserialize(deflate = false) {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tresolution: this.resolution,\r\n\t\t\t\tedges: this.edges,\r\n\t\t\t\tzeroCrossings: this.zeroCrossings,\r\n\t\t\t\tnormals: this.normals\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the given serialised data.\r\n\t\t *\r\n\t\t * @param {Object} object - Serialised edge data. Can be null.\r\n\t\t * @return {Deserializable} This object or null if the given serialised data was null.\r\n\t\t */\r\n\r\n\t\tdeserialize(object) {\r\n\r\n\t\t\tlet result = this;\r\n\r\n\t\t\tif(object !== null) {\r\n\r\n\t\t\t\tthis.resolution = object.resolution;\r\n\t\t\t\tthis.edges = object.edges;\r\n\t\t\t\tthis.zeroCrossings = object.zeroCrossings;\r\n\t\t\t\tthis.normals = object.normals;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a list of transferable items.\r\n\t\t *\r\n\t\t * @param {Array} [transferList] - An optional target list. The transferable items will be added to this list.\r\n\t\t * @return {Transferable[]} The transfer list.\r\n\t\t */\r\n\r\n\t\tcreateTransferList(transferList = []) {\r\n\r\n\t\t\tconst arrays = [\r\n\r\n\t\t\t\tthis.edges[0],\r\n\t\t\t\tthis.edges[1],\r\n\t\t\t\tthis.edges[2],\r\n\r\n\t\t\t\tthis.zeroCrossings[0],\r\n\t\t\t\tthis.zeroCrossings[1],\r\n\t\t\t\tthis.zeroCrossings[2],\r\n\r\n\t\t\t\tthis.normals[0],\r\n\t\t\t\tthis.normals[1],\r\n\t\t\t\tthis.normals[2]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tlet array;\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 0, l = arrays.length; i < l; ++i) {\r\n\r\n\t\t\t\tarray = arrays[i];\r\n\r\n\t\t\t\tif(array !== null) {\r\n\r\n\t\t\t\t\ttransferList.push(array.buffer);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn transferList;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns a new edge iterator.\r\n\t\t *\r\n\t\t * @param {Vector3} cellPosition - The position of the volume data cell.\r\n\t\t * @param {Number} cellSize - The size of the volume data cell.\r\n\t\t * @return {EdgeIterator} An iterator.\r\n\t\t */\r\n\r\n\t\tedges(cellPosition, cellSize) {\r\n\r\n\t\t\treturn new EdgeIterator(this, cellPosition, cellSize);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a new edge iterator that only returns edges along the X-axis.\r\n\t\t *\r\n\t\t * @param {Vector3} cellPosition - The position of the volume data cell.\r\n\t\t * @param {Number} cellSize - The size of the volume data cell.\r\n\t\t * @return {EdgeIterator} An iterator.\r\n\t\t */\r\n\r\n\t\tedgesX(cellPosition, cellSize) {\r\n\r\n\t\t\treturn new EdgeIterator(this, cellPosition, cellSize, 0, 1);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a new edge iterator that only returns edges along the Y-axis.\r\n\t\t *\r\n\t\t * @param {Vector3} cellPosition - The position of the volume data cell.\r\n\t\t * @param {Number} cellSize - The size of the volume data cell.\r\n\t\t * @return {EdgeIterator} An iterator.\r\n\t\t */\r\n\r\n\t\tedgesY(cellPosition, cellSize) {\r\n\r\n\t\t\treturn new EdgeIterator(this, cellPosition, cellSize, 1, 2);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a new edge iterator that only returns edges along the Z-axis.\r\n\t\t *\r\n\t\t * @param {Vector3} cellPosition - The position of the volume data cell.\r\n\t\t * @param {Number} cellSize - The size of the volume data cell.\r\n\t\t * @return {EdgeIterator} An iterator.\r\n\t\t */\r\n\r\n\t\tedgesZ(cellPosition, cellSize) {\r\n\r\n\t\t\treturn new EdgeIterator(this, cellPosition, cellSize, 2, 3);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the amount of edges for one axis based on a given resolution.\r\n\t\t *\r\n\t\t * @param {Number} n - The grid resolution.\r\n\t\t * @return {Number} The amount of edges for a single dimension.\r\n\t\t */\r\n\r\n\t\tstatic calculate1DEdgeCount(n) {\r\n\r\n\t\t\treturn Math.pow((n + 1), 2) * n;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * The isovalue.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tlet isovalue = 0.0;\r\n\r\n\t/**\r\n\t * The material grid resolution.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tlet resolution = 0;\r\n\r\n\t/**\r\n\t * The total amount of grid point indices.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tlet indexCount = 0;\r\n\r\n\t/**\r\n\t * Hermite data.\r\n\t *\r\n\t * @implements {Serializable}\r\n\t * @implements {Deserializable}\r\n\t * @implements {TransferableContainer}\r\n\t */\r\n\r\n\tclass HermiteData {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new set of Hermite data.\r\n\t\t *\r\n\t\t * @param {Boolean} [initialize=true] - Whether the data should be initialised immediately.\r\n\t\t */\r\n\r\n\t\tconstructor(initialize = true) {\r\n\r\n\t\t\t/**\r\n\t\t\t * Describes how many material indices are currently solid:\r\n\t\t\t *\r\n\t\t\t * - The chunk lies outside the volume if there are no solid grid points.\r\n\t\t\t * - The chunk lies completely inside the volume if all points are solid.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.materials = 0;\r\n\r\n\t\t\t/**\r\n\t\t\t * The grid points.\r\n\t\t\t *\r\n\t\t\t * @type {Uint8Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.materialIndices = initialize ? new Uint8Array(indexCount) : null;\r\n\r\n\t\t\t/**\r\n\t\t\t * Run-length compression data.\r\n\t\t\t *\r\n\t\t\t * @type {Uint32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.runLengths = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The edge data.\r\n\t\t\t *\r\n\t\t\t * @type {EdgeData}\r\n\t\t\t */\r\n\r\n\t\t\tthis.edgeData = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Indicates whether this data container is empty.\r\n\t\t *\r\n\t\t * @type {Boolean}\r\n\t\t */\r\n\r\n\t\tget empty() {\r\n\r\n\t\t\treturn (this.materials === 0);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Indicates whether this data container is full.\r\n\t\t *\r\n\t\t * @type {Boolean}\r\n\t\t */\r\n\r\n\t\tget full() {\r\n\r\n\t\t\treturn (this.materials === indexCount);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Indicates whether this data is currently compressed.\r\n\t\t *\r\n\t\t * @type {Boolean}\r\n\t\t */\r\n\r\n\t\tget compressed() {\r\n\r\n\t\t\treturn (this.runLengths !== null);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Indicates whether this data is currently gone.\r\n\t\t *\r\n\t\t * @type {Boolean}\r\n\t\t */\r\n\r\n\t\tget neutered() {\r\n\r\n\t\t\treturn (!this.empty && this.materialIndices === null);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the given data.\r\n\t\t *\r\n\t\t * @param {HermiteData} data - The data to adopt.\r\n\t\t * @return {HermiteData} This data.\r\n\t\t */\r\n\r\n\t\tset(data) {\r\n\r\n\t\t\tthis.materials = data.materials;\r\n\t\t\tthis.materialIndices = data.materialIndices;\r\n\t\t\tthis.runLengths = data.runLengths;\r\n\t\t\tthis.edgeData = data.edgeData;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Removes all data.\r\n\t\t *\r\n\t\t * @return {HermiteData} This data.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.materials = 0;\r\n\t\t\tthis.materialIndices = null;\r\n\t\t\tthis.runLengths = null;\r\n\t\t\tthis.edgeData = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the specified material index.\r\n\t\t *\r\n\t\t * @param {Number} index - The index of the material index that should be updated.\r\n\t\t * @param {Number} value - The new material index.\r\n\t\t */\r\n\r\n\t\tsetMaterialIndex(index, value) {\r\n\r\n\t\t\t// Keep track of how many material indices are solid.\r\n\t\t\tif(this.materialIndices[index] === Material.AIR) {\r\n\r\n\t\t\t\tif(value !== Material.AIR) {\r\n\r\n\t\t\t\t\t++this.materials;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if(value === Material.AIR) {\r\n\r\n\t\t\t\t--this.materials;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.materialIndices[index] = value;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Compresses this data.\r\n\t\t *\r\n\t\t * @param {HermiteData} [target=this] - A target data set. The compressed data will be assigned to this set.\r\n\t\t * @return {HermiteData} The target data set.\r\n\t\t */\r\n\r\n\t\tcompress(target = this) {\r\n\r\n\t\t\tlet encoding;\r\n\r\n\t\t\tif(!this.compressed) {\r\n\r\n\t\t\t\t// Note: empty sets won't be compressed. They can be discarded.\r\n\t\t\t\tif(this.full) {\r\n\r\n\t\t\t\t\t// This deliberately destroys material variations to save space!\r\n\t\t\t\t\tencoding = new RunLengthEncoding(\r\n\t\t\t\t\t\t[this.materialIndices.length],\r\n\t\t\t\t\t\t[Material.SOLID]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tencoding = RunLengthEncoding.encode(this.materialIndices);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttarget.materialIndices = new Uint8Array(encoding.data);\r\n\t\t\t\ttarget.runLengths = new Uint32Array(encoding.runLengths);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttarget.materialIndices = this.materialIndices;\r\n\t\t\t\ttarget.runLengths = this.runLengths;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.materials = this.materials;\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Decompresses this data.\r\n\t\t *\r\n\t\t * @param {HermiteData} [target=this] - A target data set. If none is provided, the compressed data will be replaced with the decompressed data.\r\n\t\t * @return {HermiteData} The target data set.\r\n\t\t */\r\n\r\n\t\tdecompress(target = this) {\r\n\r\n\t\t\ttarget.materialIndices = !this.compressed ?\r\n\t\t\t\tthis.materialIndices : RunLengthEncoding.decode(\r\n\t\t\t\t\tthis.runLengths, this.materialIndices, new Uint8Array(indexCount)\r\n\t\t\t\t);\r\n\r\n\t\t\ttarget.runLengths = null;\r\n\t\t\ttarget.materials = this.materials;\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Serialises this data.\r\n\t\t *\r\n\t\t * @param {Boolean} [deflate=false] - Whether the data should be compressed if possible.\r\n\t\t * @return {Object} The serialised data.\r\n\t\t */\r\n\r\n\t\tserialize(deflate = false) {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tmaterials: this.materials,\r\n\t\t\t\tmaterialIndices: this.materialIndices,\r\n\t\t\t\trunLengths: this.runLengths,\r\n\t\t\t\tedgeData: (this.edgeData !== null) ? this.edgeData.serialize() : null\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the given serialised data.\r\n\t\t *\r\n\t\t * @param {Object} object - Serialised Hermite data. Can be null.\r\n\t\t * @return {Deserializable} This object or null if the given serialised data was null.\r\n\t\t */\r\n\r\n\t\tdeserialize(object) {\r\n\r\n\t\t\tlet result = this;\r\n\r\n\t\t\tif(object !== null) {\r\n\r\n\t\t\t\tthis.materials = object.materials;\r\n\t\t\t\tthis.materialIndices = object.materialIndices;\r\n\t\t\t\tthis.runLengths = object.runLengths;\r\n\r\n\t\t\t\tif(object.edgeData !== null) {\r\n\r\n\t\t\t\t\tif(this.edgeData === null) {\r\n\r\n\t\t\t\t\t\t// Create an empty edge data container.\r\n\t\t\t\t\t\tthis.edgeData = new EdgeData(resolution);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.edgeData.deserialize(object.edgeData);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.edgeData = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a list of transferable items.\r\n\t\t *\r\n\t\t * @param {Array} [transferList] - An optional target list. The transferable items will be added to this list.\r\n\t\t * @return {Transferable[]} The transfer list.\r\n\t\t */\r\n\r\n\t\tcreateTransferList(transferList = []) {\r\n\r\n\t\t\tif(this.edgeData !== null) {\r\n\r\n\t\t\t\tthis.edgeData.createTransferList(transferList);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(this.materialIndices !== null) {\r\n\r\n\t\t\t\ttransferList.push(this.materialIndices.buffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(this.runLengths !== null) {\r\n\r\n\t\t\t\ttransferList.push(this.runLengths.buffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn transferList;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The global isovalue.\r\n\t\t *\r\n\t\t * A constant distance value that denotes the boundaries of SDFs.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tstatic get isovalue() {\r\n\r\n\t\t\treturn isovalue;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Warning: changing the isovalue is not recommended.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tstatic set isovalue(value) {\r\n\r\n\t\t\tisovalue = value;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The material grid resolution.\r\n\t\t *\r\n\t\t * The effective resolution of a chunk of Hermite data is the distance between\r\n\t\t * two adjacent grid points with respect to the size of the containing world\r\n\t\t * octant.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tstatic get resolution() {\r\n\r\n\t\t\treturn resolution;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Warning: this value should only be set once.\r\n\t\t *\r\n\t\t * The upper limit is 256.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tstatic set resolution(value) {\r\n\r\n\t\t\t// Round up to the next power of two.\r\n\t\t\tvalue = Math.pow(2, Math.max(0, Math.ceil(Math.log2(value))));\r\n\r\n\t\t\tresolution = Math.max(1, Math.min(256, value));\r\n\t\t\tindexCount = Math.pow((resolution + 1), 3);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An operation that describes a density field.\r\n\t */\r\n\r\n\tclass DensityFunction extends Operation {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new density function operation.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - An SDF.\r\n\t\t */\r\n\r\n\t\tconstructor(sdf) {\r\n\r\n\t\t\tsuper(OperationType.DENSITY_FUNCTION);\r\n\r\n\t\t\t/**\r\n\t\t\t * An SDF.\r\n\t\t\t *\r\n\t\t\t * @type {SignedDistanceFunction}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.sdf = sdf;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the bounding box of this density function.\r\n\t\t *\r\n\t\t * @return {Box3} The bounding box.\r\n\t\t */\r\n\r\n\t\tcomputeBoundingBox() {\r\n\r\n\t\t\treturn this.sdf.getBoundingBox(true);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the material index for the given world position.\r\n\t\t *\r\n\t\t * @param {Vector3} position - The world position of the material index.\r\n\t\t * @return {Number} The material index.\r\n\t\t */\r\n\r\n\t\tgenerateMaterialIndex(position) {\r\n\r\n\t\t\treturn (this.sdf.sample(position) <= HermiteData.isovalue) ? this.sdf.material : Material.AIR;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Generates surface intersection data for the specified edge.\r\n\t\t *\r\n\t\t * @param {Edge} edge - The edge that should be processed.\r\n\t\t */\r\n\r\n\t\tgenerateEdge(edge) {\r\n\r\n\t\t\tedge.approximateZeroCrossing(this.sdf);\r\n\t\t\tedge.computeSurfaceNormal(this.sdf);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A matrix.\r\n\t *\r\n\t * @type {Matrix4}\r\n\t * @private\r\n\t */\r\n\r\n\tconst m$1 = new Matrix4();\r\n\r\n\t/**\r\n\t * An abstract Signed Distance Function.\r\n\t *\r\n\t * An SDF describes the signed Euclidean distance to the surface of an object,\r\n\t * effectively describing its density at every point in 3D space. It yields\r\n\t * negative values for points that lie inside the volume and positive values\r\n\t * for points outside. The value is zero at the exact boundary of the object.\r\n\t *\r\n\t * @implements {Serializable}\r\n\t * @implements {TransferableContainer}\r\n\t */\r\n\r\n\tclass SignedDistanceFunction {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new base SDF.\r\n\t\t *\r\n\t\t * @param {SDFType} type - The type of the SDF.\r\n\t\t * @param {Number} [material=Material.SOLID] - A material index. Must be an integer in the range of 1 to 255.\r\n\t\t */\r\n\r\n\t\tconstructor(type, material = Material.SOLID) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The type of this SDF.\r\n\t\t\t *\r\n\t\t\t * @type {SDFType}\r\n\t\t\t */\r\n\r\n\t\t\tthis.type = type;\r\n\r\n\t\t\t/**\r\n\t\t\t * The operation type.\r\n\t\t\t *\r\n\t\t\t * @type {OperationType}\r\n\t\t\t */\r\n\r\n\t\t\tthis.operation = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A material index.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.material = Math.min(255, Math.max(Material.SOLID, Math.trunc(material)));\r\n\r\n\t\t\t/**\r\n\t\t\t * The axis-aligned bounding box of this SDF.\r\n\t\t\t *\r\n\t\t\t * @type {Box3}\r\n\t\t\t * @protected\r\n\t\t\t */\r\n\r\n\t\t\tthis.boundingBox = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The positional translation.\r\n\t\t\t *\r\n\t\t\t * Call {@link updateInverseTransformation} after changing this field.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.position = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * The rotation.\r\n\t\t\t *\r\n\t\t\t * Call {@link updateInverseTransformation} after changing this field.\r\n\t\t\t *\r\n\t\t\t * @type {Quaternion}\r\n\t\t\t */\r\n\r\n\t\t\tthis.quaternion = new Quaternion();\r\n\r\n\t\t\t/**\r\n\t\t\t * The scale.\r\n\t\t\t *\r\n\t\t\t * Call {@link updateInverseTransformation} after changing this field.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.scale = new Vector3(1, 1, 1);\r\n\r\n\t\t\t/**\r\n\t\t\t * The inverted transformation matrix.\r\n\t\t\t *\r\n\t\t\t * @type {Matrix4}\r\n\t\t\t */\r\n\r\n\t\t\tthis.inverseTransformation = new Matrix4();\r\n\r\n\t\t\tthis.updateInverseTransformation();\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of SDFs.\r\n\t\t\t *\r\n\t\t\t * SDFs can be chained to build CSG expressions.\r\n\t\t\t *\r\n\t\t\t * @type {SignedDistanceFunction[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.children = [];\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Composes a transformation matrix using the translation, rotation and scale\r\n\t\t * of this SDF.\r\n\t\t *\r\n\t\t * The transformation matrix is not needed for most SDF calculations and is\r\n\t\t * therefore not stored explicitly to save space.\r\n\t\t *\r\n\t\t * @param {Matrix4} [target] - A target matrix. If none is provided, a new one will be created.\r\n\t\t * @return {Matrix4} The transformation matrix.\r\n\t\t */\r\n\r\n\t\tgetTransformation(target = new Matrix4()) {\r\n\r\n\t\t\treturn target.compose(this.position, this.quaternion, this.scale);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the AABB of this SDF if it doesn't exist yet and returns it.\r\n\t\t *\r\n\t\t * @param {Boolean} [recursive=false] - Whether the child SDFs should be taken into account.\r\n\t\t * @return {Box3} The bounding box.\r\n\t\t */\r\n\r\n\t\tgetBoundingBox(recursive = false) {\r\n\r\n\t\t\tconst children = this.children;\r\n\r\n\t\t\tlet boundingBox = this.boundingBox;\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tif(boundingBox === null) {\r\n\r\n\t\t\t\tboundingBox = this.computeBoundingBox();\r\n\t\t\t\tthis.boundingBox = boundingBox;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(recursive) {\r\n\r\n\t\t\t\tboundingBox = boundingBox.clone();\r\n\r\n\t\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\t\tboundingBox.union(children[i].getBoundingBox(recursive));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn boundingBox;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the material.\r\n\t\t *\r\n\t\t * @param {Material} material - The material. Must be an integer in the range of 1 to 255.\r\n\t\t * @return {SignedDistanceFunction} This SDF.\r\n\t\t */\r\n\r\n\t\tsetMaterial(material) {\r\n\r\n\t\t\tthis.material = Math.min(255, Math.max(Material.SOLID, Math.trunc(material)));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the CSG operation type of this SDF.\r\n\t\t *\r\n\t\t * @param {OperationType} operation - The CSG operation type.\r\n\t\t * @return {SignedDistanceFunction} This SDF.\r\n\t\t */\r\n\r\n\t\tsetOperationType(operation) {\r\n\r\n\t\t\tthis.operation = operation;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Updates the inverse transformation matrix.\r\n\t\t *\r\n\t\t * This method should be called after the position, quaternion or scale has\r\n\t\t * changed. The bounding box will be updated automatically.\r\n\t\t *\r\n\t\t * @return {SignedDistanceFunction} This SDF.\r\n\t\t */\r\n\r\n\t\tupdateInverseTransformation() {\r\n\r\n\t\t\tthis.inverseTransformation.getInverse(this.getTransformation(m$1));\r\n\t\t\tthis.boundingBox = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds the given SDF to this one.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - An SDF.\r\n\t\t * @return {SignedDistanceFunction} This SDF.\r\n\t\t */\r\n\r\n\t\tunion(sdf) {\r\n\r\n\t\t\tthis.children.push(sdf.setOperationType(OperationType.UNION));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts the given SDF from this one.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - An SDF.\r\n\t\t * @return {SignedDistanceFunction} This SDF.\r\n\t\t */\r\n\r\n\t\tsubtract(sdf) {\r\n\r\n\t\t\tthis.children.push(sdf.setOperationType(OperationType.DIFFERENCE));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Intersects the given SDF with this one.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - An SDF.\r\n\t\t * @return {SignedDistanceFunction} This SDF.\r\n\t\t */\r\n\r\n\t\tintersect(sdf) {\r\n\r\n\t\t\tthis.children.push(sdf.setOperationType(OperationType.INTERSECTION));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Translates this SDF into a CSG expression.\r\n\t\t *\r\n\t\t * @return {Operation} A CSG operation.\r\n\t\t * @example a.union(b.intersect(c)).union(d).subtract(e) => Difference(Union(a, Intersection(b, c), d), e)\r\n\t\t */\r\n\r\n\t\ttoCSG() {\r\n\r\n\t\t\tconst children = this.children;\r\n\r\n\t\t\tlet operation = new DensityFunction(this);\r\n\t\t\tlet operationType;\r\n\t\t\tlet child;\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\tchild = children[i];\r\n\r\n\t\t\t\tif(operationType !== child.operation) {\r\n\r\n\t\t\t\t\toperationType = child.operation;\r\n\r\n\t\t\t\t\tswitch(operationType) {\r\n\r\n\t\t\t\t\t\tcase OperationType.UNION:\r\n\t\t\t\t\t\t\toperation = new Union(operation);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase OperationType.DIFFERENCE:\r\n\t\t\t\t\t\t\toperation = new Difference(operation);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase OperationType.INTERSECTION:\r\n\t\t\t\t\t\t\toperation = new Intersection(operation);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\toperation.children.push(child.toCSG());\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn operation;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Serialises this SDF.\r\n\t\t *\r\n\t\t * @param {Boolean} [deflate=false] - Whether the data should be compressed if possible.\r\n\t\t * @return {Object} The serialised data.\r\n\t\t */\r\n\r\n\t\tserialize(deflate = false) {\r\n\r\n\t\t\tconst result = {\r\n\t\t\t\ttype: this.type,\r\n\t\t\t\toperation: this.operation,\r\n\t\t\t\tmaterial: this.material,\r\n\t\t\t\tposition: this.position.toArray(),\r\n\t\t\t\tquaternion: this.quaternion.toArray(),\r\n\t\t\t\tscale: this.scale.toArray(),\r\n\t\t\t\tparameters: null,\r\n\t\t\t\tchildren: []\r\n\t\t\t};\r\n\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 0, l = this.children.length; i < l; ++i) {\r\n\r\n\t\t\t\tresult.children.push(this.children[i].serialize(deflate));\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a list of transferable items.\r\n\t\t *\r\n\t\t * @param {Array} [transferList] - An optional target list. The transferable items will be added to this list.\r\n\t\t * @return {Transferable[]} The transfer list.\r\n\t\t */\r\n\r\n\t\tcreateTransferList(transferList = []) {\r\n\r\n\t\t\treturn transferList;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns a plain object that describes this SDF.\r\n\t\t *\r\n\t\t * @return {Object} A simple description of this SDF.\r\n\t\t */\r\n\r\n\t\ttoJSON() {\r\n\r\n\t\t\treturn this.serialize(true);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the bounding box of this SDF.\r\n\t\t *\r\n\t\t * @protected\r\n\t\t * @throws {Error} An error is thrown if the method is not overridden.\r\n\t\t * @return {Box3} The bounding box.\r\n\t\t */\r\n\r\n\t\tcomputeBoundingBox() {\r\n\r\n\t\t\tthrow new Error(\"SignedDistanceFunction#computeBoundingBox method not implemented!\");\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Samples the volume's density at the given point in space.\r\n\t\t *\r\n\t\t * @throws {Error} An error is thrown if the method is not overridden.\r\n\t\t * @param {Vector3} position - A position.\r\n\t\t * @return {Number} The Euclidean distance to the surface.\r\n\t\t */\r\n\r\n\t\tsample(position) {\r\n\r\n\t\t\tthrow new Error(\"SignedDistanceFunction#sample method not implemented!\");\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An enumeration of SDF types.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {String} HEIGHTFIELD - A heightfield description.\r\n\t * @property {String} FRACTAL_NOISE - A fractal noise description.\r\n\t * @property {String} SUPER_PRIMITIVE - A super primitive description.\r\n\t */\r\n\r\n\tconst SDFType = {\r\n\r\n\t\tHEIGHTFIELD: \"sdf.heightfield\",\r\n\t\tFRACTAL_NOISE: \"sdf.fractalnoise\",\r\n\t\tSUPER_PRIMITIVE: \"sdf.superprimitive\"\r\n\r\n\t};\n\n\t/**\r\n\t * The super primitive.\r\n\t *\r\n\t * A function that is able to represent a wide range of conic/rectangular-radial\r\n\t * primitives of genus 0 and 1: (round) box, sphere, cylinder, capped cone,\r\n\t * torus, capsule, pellet, pipe, etc.\r\n\t *\r\n\t * Reference:\r\n\t *  https://www.shadertoy.com/view/MsVGWG\r\n\t */\r\n\r\n\tclass SuperPrimitive extends SignedDistanceFunction {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new super primitive.\r\n\t\t *\r\n\t\t * See {@link SuperPrimitivePreset} for a list of default configurations.\r\n\t\t *\r\n\t\t * @param {Object} parameters - The parameters.\r\n\t\t * @param {Array} parameters.s - The size and genus weight [x, y, z, w].\r\n\t\t * @param {Array} parameters.r - The corner radii [x, y, z].\r\n\t\t * @param {Number} [material] - A material index.\r\n\t\t * @example const cube = SuperPrimitive.create(SuperPrimitivePreset.CUBE);\r\n\t\t */\r\n\r\n\t\tconstructor(parameters = {}, material) {\r\n\r\n\t\t\tsuper(SDFType.SUPER_PRIMITIVE, material);\r\n\r\n\t\t\t/**\r\n\t\t\t * The base size. The W-component affects the genus of the primitive.\r\n\t\t\t *\r\n\t\t\t * @type {Vector4}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.s0 = new Vector4(...parameters.s);\r\n\r\n\t\t\t/**\r\n\t\t\t * The base corner radii.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.r0 = new Vector3(...parameters.r);\r\n\r\n\t\t\t/**\r\n\t\t\t * The size, adjusted for further calculations.\r\n\t\t\t *\r\n\t\t\t * @type {Vector4}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.s = new Vector4();\r\n\r\n\t\t\t/**\r\n\t\t\t * The corner radii, adjusted for further calculations.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.r = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * Precomputed corner rounding constants.\r\n\t\t\t *\r\n\t\t\t * @type {Vector2}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.ba = new Vector2();\r\n\r\n\t\t\t/**\r\n\t\t\t * The bottom radius offset.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.offset = 0;\r\n\r\n\t\t\t// Calculate constants ahead of time.\r\n\t\t\tthis.precompute();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the size and genus weight.\r\n\t\t *\r\n\t\t * @param {Number} x - X.\r\n\t\t * @param {Number} y - Y.\r\n\t\t * @param {Number} z - Z.\r\n\t\t * @param {Number} w - W.\r\n\t\t * @return {SuperPrimitive} This instance.\r\n\t\t */\r\n\r\n\t\tsetSize(x, y, z, w) {\r\n\r\n\t\t\tthis.s0.set(x, y, z, w);\r\n\r\n\t\t\treturn this.precompute();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the corner radii.\r\n\t\t *\r\n\t\t * @param {Number} x - X.\r\n\t\t * @param {Number} y - Y.\r\n\t\t * @param {Number} z - Z.\r\n\t\t * @return {SuperPrimitive} This instance.\r\n\t\t */\r\n\r\n\t\tsetRadii(x, y, z) {\r\n\r\n\t\t\tthis.r0.set(x, y, z);\r\n\r\n\t\t\treturn this.precompute();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Precomputes corner rounding factors.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @return {SuperPrimitive} This instance.\r\n\t\t */\r\n\r\n\t\tprecompute() {\r\n\r\n\t\t\tconst s = this.s.copy(this.s0);\r\n\t\t\tconst r = this.r.copy(this.r0);\r\n\t\t\tconst ba = this.ba;\r\n\r\n\t\t\ts.x -= r.x;\r\n\t\t\ts.y -= r.x;\r\n\r\n\t\t\tr.x -= s.w;\r\n\t\t\ts.w -= r.y;\r\n\r\n\t\t\ts.z -= r.y;\r\n\r\n\t\t\tthis.offset = -2.0 * s.z;\r\n\r\n\t\t\tba.set(r.z, this.offset);\r\n\t\t\tconst divisor = ba.dot(ba);\r\n\r\n\t\t\tif(divisor === 0.0) {\r\n\r\n\t\t\t\t// Y must not be 0 to prevent bad values for Z = 0 in the last term (*).\r\n\t\t\t\tba.set(0.0, -1.0);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tba.divideScalar(divisor);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the bounding box of this SDF.\r\n\t\t *\r\n\t\t * @return {Box3} The bounding box.\r\n\t\t */\r\n\r\n\t\tcomputeBoundingBox() {\r\n\r\n\t\t\tconst s = this.s0;\r\n\t\t\tconst boundingBox = new Box3();\r\n\r\n\t\t\tboundingBox.min.x = Math.min(-s.x, -1.0);\r\n\t\t\tboundingBox.min.y = Math.min(-s.y, -1.0);\r\n\t\t\tboundingBox.min.z = Math.min(-s.z, -1.0);\r\n\r\n\t\t\tboundingBox.max.x = Math.max(s.x, 1.0);\r\n\t\t\tboundingBox.max.y = Math.max(s.y, 1.0);\r\n\t\t\tboundingBox.max.z = Math.max(s.z, 1.0);\r\n\r\n\t\t\tboundingBox.applyMatrix4(this.getTransformation());\r\n\r\n\t\t\treturn boundingBox;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Samples the volume's density at the given point in space.\r\n\t\t *\r\n\t\t * @param {Vector3} position - A position.\r\n\t\t * @return {Number} The euclidean distance to the surface.\r\n\t\t */\r\n\r\n\t\tsample(position) {\r\n\r\n\t\t\tposition.applyMatrix4(this.inverseTransformation);\r\n\r\n\t\t\tconst s = this.s;\r\n\t\t\tconst r = this.r;\r\n\t\t\tconst ba = this.ba;\r\n\r\n\t\t\tconst dx = Math.abs(position.x) - s.x;\r\n\t\t\tconst dy = Math.abs(position.y) - s.y;\r\n\t\t\tconst dz = Math.abs(position.z) - s.z;\r\n\r\n\t\t\tconst mx0 = Math.max(dx, 0.0);\r\n\t\t\tconst my0 = Math.max(dy, 0.0);\r\n\t\t\tconst l0 = Math.sqrt(mx0 * mx0 + my0 * my0);\r\n\r\n\t\t\tconst p = position.z - s.z;\r\n\t\t\tconst q = Math.abs(l0 + Math.min(0.0, Math.max(dx, dy)) - r.x) - s.w;\r\n\r\n\t\t\tconst c = Math.min(Math.max(q * ba.x + p * ba.y, 0.0), 1.0);\r\n\t\t\tconst diagX = q - r.z * c;\r\n\t\t\tconst diagY = p - this.offset * c;\r\n\r\n\t\t\tconst hx0 = Math.max(q - r.z, 0.0);\r\n\t\t\tconst hy0 = position.z + s.z;\r\n\t\t\tconst hx1 = Math.max(q, 0.0);\r\n\t\t\t// hy1 = p;\r\n\r\n\t\t\tconst diagSq = diagX * diagX + diagY * diagY;\r\n\t\t\tconst h0Sq = hx0 * hx0 + hy0 * hy0;\r\n\t\t\tconst h1Sq = hx1 * hx1 + p * p;\r\n\t\t\tconst paBa = q * -ba.y + p * ba.x;\r\n\r\n\t\t\tconst l1 = Math.sqrt(Math.min(diagSq, Math.min(h0Sq, h1Sq)));\r\n\r\n\t\t\t// (*) paBa must not be 0: if dz is also 0, the result will be wrong.\r\n\t\t\treturn l1 * Math.sign(Math.max(paBa, dz)) - r.y;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Serialises this SDF.\r\n\t\t *\r\n\t\t * @param {Boolean} [deflate=false] - Whether the data should be compressed if possible.\r\n\t\t * @return {Object} The serialised data.\r\n\t\t */\r\n\r\n\t\tserialize(deflate = false) {\r\n\r\n\t\t\tconst result = super.serialize();\r\n\r\n\t\t\tresult.parameters = {\r\n\t\t\t\ts: this.s0.toArray(),\r\n\t\t\t\tr: this.r0.toArray()\r\n\t\t\t};\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a new primitive using the specified preset.\r\n\t\t *\r\n\t\t * @param {SuperPrimitivePreset} preset - The super primitive preset.\r\n\t\t */\r\n\r\n\t\tstatic create(preset) {\r\n\r\n\t\t\tconst parameters = superPrimitivePresets[preset];\r\n\r\n\t\t\treturn new SuperPrimitive({\r\n\t\t\t\ts: parameters[0],\r\n\t\t\t\tr: parameters[1]\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A list of parameter presets.\r\n\t *\r\n\t * @type {Array<Float32Array[]>}\r\n\t * @private\r\n\t */\r\n\r\n\tconst superPrimitivePresets = [\r\n\r\n\t\t// Cube.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 1.0, 1.0]),\r\n\t\t\tnew Float32Array([0.0, 0.0, 0.0])\r\n\t\t],\r\n\r\n\t\t// Cylinder.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 1.0, 1.0]),\r\n\t\t\tnew Float32Array([1.0, 0.0, 0.0])\r\n\t\t],\r\n\r\n\t\t// Cone.\r\n\t\t[\r\n\t\t\tnew Float32Array([0.0, 0.0, 1.0, 1.0]),\r\n\t\t\tnew Float32Array([0.0, 0.0, 1.0])\r\n\t\t],\r\n\r\n\t\t// Pill.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 2.0, 1.0]),\r\n\t\t\tnew Float32Array([1.0, 1.0, 0.0])\r\n\t\t],\r\n\r\n\t\t// Sphere.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 1.0, 1.0]),\r\n\t\t\tnew Float32Array([1.0, 1.0, 0.0])\r\n\t\t],\r\n\r\n\t\t// Pellet.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 0.25, 1.0]),\r\n\t\t\tnew Float32Array([1.0, 0.25, 0.0])\r\n\t\t],\r\n\r\n\t\t// Torus.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 0.25, 0.25]),\r\n\t\t\tnew Float32Array([1.0, 0.25, 0.0])\r\n\t\t],\r\n\r\n\t\t// Pipe.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 1.0, 0.25]),\r\n\t\t\tnew Float32Array([1.0, 0.1, 0.0])\r\n\t\t],\r\n\r\n\t\t// Corridor.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 1.0, 0.25]),\r\n\t\t\tnew Float32Array([0.1, 0.1, 0.0])\r\n\t\t]\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * An enumeration of super primitive presets.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {Number} CUBE - A cube.\r\n\t * @property {Number} CYLINDER - A cylinder.\r\n\t * @property {Number} CONE - A cone.\r\n\t * @property {Number} PILL - A pill.\r\n\t * @property {Number} SPHERE - A sphere.\r\n\t * @property {Number} PELLET - A pellet.\r\n\t * @property {Number} TORUS - A torus.\r\n\t * @property {Number} PIPE - A pipe.\r\n\t * @property {Number} CORRIDOR - A corridor.\r\n\t */\r\n\r\n\tconst SuperPrimitivePreset = {\r\n\r\n\t\tCUBE: 0,\r\n\t\tCYLINDER: 1,\r\n\t\tCONE: 2,\r\n\t\tPILL: 3,\r\n\t\tSPHERE: 4,\r\n\t\tPELLET: 5,\r\n\t\tTORUS: 6,\r\n\t\tPIPE: 7,\r\n\t\tCORRIDOR: 8\r\n\r\n\t};\n\n\t/**\r\n\t * An SDF loader event.\r\n\t */\r\n\r\n\tclass SDFLoaderEvent extends Event {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new SDF loader event.\r\n\t\t *\r\n\t\t * @param {String} type - The name of the event.\r\n\t\t */\r\n\r\n\t\tconstructor(type) {\r\n\r\n\t\t\tsuper(type);\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of serialised SDFs.\r\n\t\t\t *\r\n\t\t\t * @type {Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.descriptions = null;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A load event.\r\n\t *\r\n\t * This event is dispatched by {@link SDFLoader}.\r\n\t *\r\n\t * @type {SDFLoaderEvent}\r\n\t * @example sdfLoader.addEventListener(\"load\", myListener);\r\n\t */\r\n\r\n\tconst load = new SDFLoaderEvent(\"load\");\n\n\t/**\r\n\t * A collection of binary number utilities.\r\n\t */\n\n\t/**\r\n\t * A world octant identifier.\r\n\t *\r\n\t * Each octant can be identified by a LOD index and a positional key.\r\n\t */\n\n\t/**\r\n\t * A scene that consists of several concentric geometry rings.\r\n\t */\n\n\t/**\r\n\t * A clipmap event.\r\n\t */\r\n\r\n\tclass ClipmapEvent extends Event {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new clipmap event.\r\n\t\t *\r\n\t\t * @param {String} type - The name of the event.\r\n\t\t */\r\n\r\n\t\tconstructor(type) {\r\n\r\n\t\t\tsuper(type);\r\n\r\n\t\t\t/**\r\n\t\t\t * The LOD shell.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.lod = -1;\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of world octant Identifiers that have left the LOD shell.\r\n\t\t\t *\r\n\t\t\t * @type {WorldOctantId[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.left = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of world octant Identifiers that have entered the LOD shell.\r\n\t\t\t *\r\n\t\t\t * @type {WorldOctantId[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.entered = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * An error event.\r\n\t\t\t *\r\n\t\t\t * @type {ErrorEvent}\r\n\t\t\t */\r\n\r\n\t\t\tthis.error = null;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Signals the end of a clipmap update for a single LOD shell.\r\n\t *\r\n\t * This event is dispatched by {@link Clipmap}.\r\n\t *\r\n\t * @type {ClipmapEvent}\r\n\t * @example terrain.addEventListener(\"update\", myListener);\r\n\t */\r\n\r\n\tconst update = new ClipmapEvent(\"update\");\r\n\r\n\t/**\r\n\t * Signals the occurrence of an unexpected error.\r\n\t *\r\n\t * This event is dispatched by {@link Clipmap}.\r\n\t *\r\n\t * @type {ClipmapEvent}\r\n\t * @example terrain.addEventListener(\"error\", myListener);\r\n\t */\r\n\r\n\tconst error = new ClipmapEvent(\"error\");\n\n\t/**\r\n\t * An enumeration of worker actions.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {String} EXTRACT - Isosurface extraction signal.\r\n\t * @property {String} MODIFY - Data modification signal.\r\n\t * @property {String} CONFIGURE - General configuration signal.\r\n\t * @property {String} CLOSE - Thread termination signal.\r\n\t */\n\n\t/**\r\n\t * A message.\r\n\t *\r\n\t * Messages are exchanged between different execution contexts such as a worker\r\n\t * and the main thread.\r\n\t */\n\n\t/**\r\n\t * A collection of worker messages.\r\n\t *\r\n\t * @module rabbit-hole/worker/messages\r\n\t */\n\n\t/**\r\n\t * A worker event.\r\n\t */\r\n\r\n\tclass WorkerEvent extends Event {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new worker event.\r\n\t\t *\r\n\t\t * @param {String} type - The name of the event.\r\n\t\t */\r\n\r\n\t\tconstructor(type) {\r\n\r\n\t\t\tsuper(type);\r\n\r\n\t\t\t/**\r\n\t\t\t * A worker.\r\n\t\t\t *\r\n\t\t\t * @type {Worker}\r\n\t\t\t */\r\n\r\n\t\t\tthis.worker = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A worker response.\r\n\t\t\t *\r\n\t\t\t * @type {Response}\r\n\t\t\t */\r\n\r\n\t\t\tthis.response = null;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A worker message event.\r\n\t *\r\n\t * This event is dispatched by {@link ThreadPool}.\r\n\t *\r\n\t * @type {WorkerEvent}\r\n\t * @example threadPool.addEventListener(\"message\", myListener);\r\n\t */\r\n\r\n\tconst message = new WorkerEvent(\"message\");\n\n\t/**\r\n\t * A terrain event.\r\n\t */\r\n\r\n\tclass TerrainEvent extends Event {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new terrain event.\r\n\t\t *\r\n\t\t * @param {String} type - The name of the event.\r\n\t\t */\r\n\r\n\t\tconstructor(type) {\r\n\r\n\t\t\tsuper(type);\r\n\r\n\t\t\t/**\r\n\t\t\t * A world octant.\r\n\t\t\t *\r\n\t\t\t * @type {WorldOctant}\r\n\t\t\t */\r\n\r\n\t\t\tthis.octant = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Identifier of the world octant.\r\n\t\t\t *\r\n\t\t\t * @type {WorldOctantId}\r\n\t\t\t */\r\n\r\n\t\t\tthis.octantId = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * An error event.\r\n\t\t\t *\r\n\t\t\t * @type {ErrorEvent}\r\n\t\t\t */\r\n\r\n\t\t\tthis.error = null;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Signals the start of a modification task.\r\n\t *\r\n\t * This event is dispatched by {@link Terrain}.\r\n\t *\r\n\t * @type {TerrainEvent}\r\n\t * @example terrain.addEventListener(\"modificationstart\", myListener);\r\n\t */\r\n\r\n\tconst modificationstart = new TerrainEvent(\"modificationstart\");\r\n\r\n\t/**\r\n\t * Signals the end of a modification task.\r\n\t *\r\n\t * This event is dispatched by {@link Terrain}.\r\n\t *\r\n\t * @type {TerrainEvent}\r\n\t * @example terrain.addEventListener(\"modificationend\", myListener);\r\n\t */\r\n\r\n\tconst modificationend = new TerrainEvent(\"modificationend\");\r\n\r\n\t/**\r\n\t * Signals the start of an extraction task.\r\n\t *\r\n\t * This event is dispatched by {@link Terrain}.\r\n\t *\r\n\t * @type {TerrainEvent}\r\n\t * @example terrain.addEventListener(\"extractionstart\", myListener);\r\n\t */\r\n\r\n\tconst extractionstart = new TerrainEvent(\"extractionstart\");\r\n\r\n\t/**\r\n\t * Signals the end of an extraction task.\r\n\t *\r\n\t * This event is dispatched by {@link Terrain}.\r\n\t *\r\n\t * @type {TerrainEvent}\r\n\t * @example terrain.addEventListener(\"extractionend\", myListener);\r\n\t */\r\n\r\n\tconst extractionend = new TerrainEvent(\"extractionend\");\r\n\r\n\t/**\r\n\t * Signals the end of a volume data loading process.\r\n\t *\r\n\t * This event is dispatched by {@link Terrain}.\r\n\t *\r\n\t * @type {TerrainEvent}\r\n\t * @example terrain.addEventListener(\"load\", myListener);\r\n\t */\r\n\r\n\tconst load$1 = new TerrainEvent(\"load\");\r\n\r\n\t/**\r\n\t * Signals the occurrence of an unexpected error.\r\n\t *\r\n\t * This event is dispatched by {@link Terrain}.\r\n\t *\r\n\t * @type {TerrainEvent}\r\n\t * @example terrain.addEventListener(\"error\", myListener);\r\n\t */\r\n\r\n\tconst error$1 = new TerrainEvent(\"error\");\n\n\t/**\r\n\t * Core components.\r\n\t *\r\n\t * @module rabbit-hole/core\r\n\t */\n\n\t/**\r\n\t * Geometry clipmap components.\r\n\t *\r\n\t * @module rabbit-hole/clipmap\r\n\t */\n\n\t/**\r\n\t * Data encoding and decoding components.\r\n\t *\r\n\t * @module rabbit-hole/codecs\r\n\t */\n\n\t/**\r\n\t * A collection of events.\r\n\t *\r\n\t * @module rabbit-hole/events\r\n\t */\n\n\t/**\r\n\t * An isosurface, the result of a contouring process.\r\n\t *\r\n\t * @implements {Serializable}\r\n\t * @implements {Deserializable}\r\n\t * @implements {TransferableContainer}\r\n\t */\r\n\r\n\tclass Isosurface {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new isosurface.\r\n\t\t *\r\n\t\t * @param {Uint16Array} indices - Triangle indices.\r\n\t\t * @param {Float32Array} positions - Generated vertices.\r\n\t\t * @param {Float32Array} normals - Generated normals.\r\n\t\t * @param {Float32Array} uvs - Generated uvs.\r\n\t\t * @param {Uint8Array} materials - Generated materials.\r\n\t\t */\r\n\r\n\t\tconstructor(indices, positions, normals, uvs, materials) {\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of vertex indices that describe triangles.\r\n\t\t\t *\r\n\t\t\t * @type {Uint16Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.indices = indices;\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of vertices.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.positions = positions;\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of normals.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.normals = normals;\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of UV coordinates.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.uvs = uvs;\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of material indices.\r\n\t\t\t *\r\n\t\t\t * @type {Uint8Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.materials = materials;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Serialises this isosurface.\r\n\t\t *\r\n\t\t * @param {Boolean} [deflate=false] - Whether the data should be compressed if possible.\r\n\t\t * @return {Object} The serialised data.\r\n\t\t */\r\n\r\n\t\tserialize(deflate = false) {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tindices: this.indices,\r\n\t\t\t\tpositions: this.positions,\r\n\t\t\t\tnormals: this.normals,\r\n\t\t\t\tuvs: this.uvs,\r\n\t\t\t\tmaterials: this.materials\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the given serialised isosurface.\r\n\t\t *\r\n\t\t * @param {Object} object - A serialised isosurface. Can be null.\r\n\t\t * @return {Deserializable} This object or null if the given serialised isosurface was null.\r\n\t\t */\r\n\r\n\t\tdeserialize(object) {\r\n\r\n\t\t\tlet result = this;\r\n\r\n\t\t\tif(object !== null) {\r\n\r\n\t\t\t\tthis.indices = object.indices;\r\n\t\t\t\tthis.positions = object.positions;\r\n\t\t\t\tthis.normals = object.normals;\r\n\t\t\t\tthis.uvs = object.uvs;\r\n\t\t\t\tthis.materials = object.materials;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a list of transferable items.\r\n\t\t *\r\n\t\t * @param {Array} [transferList] - An optional target list. The transferable items will be added to this list.\r\n\t\t * @return {Transferable[]} The transfer list.\r\n\t\t */\r\n\r\n\t\tcreateTransferList(transferList = []) {\r\n\r\n\t\t\ttransferList.push(this.indices.buffer);\r\n\t\t\ttransferList.push(this.positions.buffer);\r\n\t\t\ttransferList.push(this.normals.buffer);\r\n\t\t\ttransferList.push(this.uvs.buffer);\r\n\t\t\ttransferList.push(this.materials.buffer);\r\n\r\n\t\t\treturn transferList;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An edge mask.\r\n\t *\r\n\t * @type {Uint8Array}\r\n\t */\r\n\r\n\t/**\r\n\t * A face mask for cell processing.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t */\r\n\r\n\tconst cellProcFaceMask = [\r\n\r\n\t\tnew Uint8Array([0, 4, 0]),\r\n\t\tnew Uint8Array([1, 5, 0]),\r\n\t\tnew Uint8Array([2, 6, 0]),\r\n\t\tnew Uint8Array([3, 7, 0]),\r\n\t\tnew Uint8Array([0, 2, 1]),\r\n\t\tnew Uint8Array([4, 6, 1]),\r\n\t\tnew Uint8Array([1, 3, 1]),\r\n\t\tnew Uint8Array([5, 7, 1]),\r\n\t\tnew Uint8Array([0, 1, 2]),\r\n\t\tnew Uint8Array([2, 3, 2]),\r\n\t\tnew Uint8Array([4, 5, 2]),\r\n\t\tnew Uint8Array([6, 7, 2])\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * An edge mask for cell processing.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t */\r\n\r\n\tconst cellProcEdgeMask = [\r\n\r\n\t\tnew Uint8Array([0, 1, 2, 3, 0]),\r\n\t\tnew Uint8Array([4, 5, 6, 7, 0]),\r\n\t\tnew Uint8Array([0, 4, 1, 5, 1]),\r\n\t\tnew Uint8Array([2, 6, 3, 7, 1]),\r\n\t\tnew Uint8Array([0, 2, 4, 6, 2]),\r\n\t\tnew Uint8Array([1, 3, 5, 7, 2])\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * A face mask for face processing.\r\n\t *\r\n\t * @type {Array<Uint8Array[]>}\r\n\t */\r\n\r\n\tconst faceProcFaceMask = [\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([4, 0, 0]),\r\n\t\t\tnew Uint8Array([5, 1, 0]),\r\n\t\t\tnew Uint8Array([6, 2, 0]),\r\n\t\t\tnew Uint8Array([7, 3, 0])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([2, 0, 1]),\r\n\t\t\tnew Uint8Array([6, 4, 1]),\r\n\t\t\tnew Uint8Array([3, 1, 1]),\r\n\t\t\tnew Uint8Array([7, 5, 1])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([1, 0, 2]),\r\n\t\t\tnew Uint8Array([3, 2, 2]),\r\n\t\t\tnew Uint8Array([5, 4, 2]),\r\n\t\t\tnew Uint8Array([7, 6, 2])\r\n\t\t]\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * An edge mask for face processing.\r\n\t *\r\n\t * @type {Array<Uint8Array[]>}\r\n\t */\r\n\r\n\tconst faceProcEdgeMask = [\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([1, 4, 0, 5, 1, 1]),\r\n\t\t\tnew Uint8Array([1, 6, 2, 7, 3, 1]),\r\n\t\t\tnew Uint8Array([0, 4, 6, 0, 2, 2]),\r\n\t\t\tnew Uint8Array([0, 5, 7, 1, 3, 2])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([0, 2, 3, 0, 1, 0]),\r\n\t\t\tnew Uint8Array([0, 6, 7, 4, 5, 0]),\r\n\t\t\tnew Uint8Array([1, 2, 0, 6, 4, 2]),\r\n\t\t\tnew Uint8Array([1, 3, 1, 7, 5, 2])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([1, 1, 0, 3, 2, 0]),\r\n\t\t\tnew Uint8Array([1, 5, 4, 7, 6, 0]),\r\n\t\t\tnew Uint8Array([0, 1, 5, 0, 4, 1]),\r\n\t\t\tnew Uint8Array([0, 3, 7, 2, 6, 1])\r\n\t\t]\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * An edge mask for edge processing.\r\n\t *\r\n\t * @type {Array<Uint8Array[]>}\r\n\t */\r\n\r\n\tconst edgeProcEdgeMask = [\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([3, 2, 1, 0, 0]),\r\n\t\t\tnew Uint8Array([7, 6, 5, 4, 0])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([5, 1, 4, 0, 1]),\r\n\t\t\tnew Uint8Array([7, 3, 6, 2, 1])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([6, 4, 2, 0, 2]),\r\n\t\t\tnew Uint8Array([7, 5, 3, 1, 2])\r\n\t\t]\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * An edge mask.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t */\r\n\r\n\tconst procEdgeMask = [\r\n\r\n\t\tnew Uint8Array([3, 2, 1, 0]),\r\n\t\tnew Uint8Array([7, 5, 6, 4]),\r\n\t\tnew Uint8Array([11, 10, 9, 8])\r\n\r\n\t];\n\n\t/**\r\n\t * The maximum number of vertices. Vertex indices use 16 bits.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst MAX_VERTEX_COUNT = Math.pow(2, 16) - 1;\r\n\r\n\t/**\r\n\t * An edge contouring sub-procedure.\r\n\t *\r\n\t * @private\r\n\t * @param {Array} octants - Four leaf octants.\r\n\t * @param {Number} dir - A direction index.\r\n\t * @param {Array} indexBuffer - An output list for vertex indices.\r\n\t */\r\n\r\n\tfunction contourProcessEdge(octants, dir, indexBuffer) {\r\n\r\n\t\tconst indices = [-1, -1, -1, -1];\r\n\t\tconst signChange = [false, false, false, false];\r\n\r\n\t\tlet minSize = Infinity;\r\n\t\tlet minIndex = 0;\r\n\t\tlet flip = false;\r\n\r\n\t\tlet c1, c2, m1, m2;\r\n\t\tlet octant, edge;\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; i < 4; ++i) {\r\n\r\n\t\t\toctant = octants[i];\r\n\t\t\tedge = procEdgeMask[dir][i];\r\n\r\n\t\t\tc1 = edges[edge][0];\r\n\t\t\tc2 = edges[edge][1];\r\n\r\n\t\t\tm1 = (octant.voxel.materials >> c1) & 1;\r\n\t\t\tm2 = (octant.voxel.materials >> c2) & 1;\r\n\r\n\t\t\tif(octant.size < minSize) {\r\n\r\n\t\t\t\tminSize = octant.size;\r\n\t\t\t\tminIndex = i;\r\n\t\t\t\tflip = (m1 !== Material.AIR);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindices[i] = octant.voxel.index;\r\n\t\t\tsignChange[i] = (m1 !== m2);\r\n\r\n\t\t}\r\n\r\n\t\tif(signChange[minIndex]) {\r\n\r\n\t\t\tif(!flip) {\r\n\r\n\t\t\t\tindexBuffer.push(indices[0]);\r\n\t\t\t\tindexBuffer.push(indices[1]);\r\n\t\t\t\tindexBuffer.push(indices[3]);\r\n\r\n\t\t\t\tindexBuffer.push(indices[0]);\r\n\t\t\t\tindexBuffer.push(indices[3]);\r\n\t\t\t\tindexBuffer.push(indices[2]);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindexBuffer.push(indices[0]);\r\n\t\t\t\tindexBuffer.push(indices[3]);\r\n\t\t\t\tindexBuffer.push(indices[1]);\r\n\r\n\t\t\t\tindexBuffer.push(indices[0]);\r\n\t\t\t\tindexBuffer.push(indices[2]);\r\n\t\t\t\tindexBuffer.push(indices[3]);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * An edge contouring procedure.\r\n\t *\r\n\t * @private\r\n\t * @param {Array} octants - Four edge octants.\r\n\t * @param {Number} dir - A direction index.\r\n\t * @param {Array} indexBuffer - An output list for vertex indices.\r\n\t */\r\n\r\n\tfunction contourEdgeProc(octants, dir, indexBuffer) {\r\n\r\n\t\tconst c = [0, 0, 0, 0];\r\n\r\n\t\tlet edgeOctants;\r\n\t\tlet octant;\r\n\t\tlet i, j;\r\n\r\n\t\tif(octants[0].voxel !== null && octants[1].voxel !== null &&\r\n\t\t\toctants[2].voxel !== null && octants[3].voxel !== null) {\r\n\r\n\t\t\tcontourProcessEdge(octants, dir, indexBuffer);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor(i = 0; i < 2; ++i) {\r\n\r\n\t\t\t\tc[0] = edgeProcEdgeMask[dir][i][0];\r\n\t\t\t\tc[1] = edgeProcEdgeMask[dir][i][1];\r\n\t\t\t\tc[2] = edgeProcEdgeMask[dir][i][2];\r\n\t\t\t\tc[3] = edgeProcEdgeMask[dir][i][3];\r\n\r\n\t\t\t\tedgeOctants = [];\r\n\r\n\t\t\t\tfor(j = 0; j < 4; ++j) {\r\n\r\n\t\t\t\t\toctant = octants[j];\r\n\r\n\t\t\t\t\tif(octant.voxel !== null) {\r\n\r\n\t\t\t\t\t\tedgeOctants[j] = octant;\r\n\r\n\t\t\t\t\t} else if(octant.children !== null) {\r\n\r\n\t\t\t\t\t\tedgeOctants[j] = octant.children[c[j]];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(j === 4) {\r\n\r\n\t\t\t\t\tcontourEdgeProc(edgeOctants, edgeProcEdgeMask[dir][i][4], indexBuffer);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A face contouring procedure.\r\n\t *\r\n\t * @private\r\n\t * @param {Array} octants - Two face octants.\r\n\t * @param {Number} dir - A direction index.\r\n\t * @param {Array} indexBuffer - An output list for vertex indices.\r\n\t */\r\n\r\n\tfunction contourFaceProc(octants, dir, indexBuffer) {\r\n\r\n\t\tconst c = [0, 0, 0, 0];\r\n\r\n\t\tconst orders = [\r\n\t\t\t[0, 0, 1, 1],\r\n\t\t\t[0, 1, 0, 1]\r\n\t\t];\r\n\r\n\t\tlet faceOctants, edgeOctants;\r\n\t\tlet order, octant;\r\n\t\tlet i, j;\r\n\r\n\t\tif(octants[0].children !== null || octants[1].children !== null) {\r\n\r\n\t\t\tfor(i = 0; i < 4; ++i) {\r\n\r\n\t\t\t\tc[0] = faceProcFaceMask[dir][i][0];\r\n\t\t\t\tc[1] = faceProcFaceMask[dir][i][1];\r\n\r\n\t\t\t\tfaceOctants = [\r\n\t\t\t\t\t(octants[0].children === null) ? octants[0] : octants[0].children[c[0]],\r\n\t\t\t\t\t(octants[1].children === null) ? octants[1] : octants[1].children[c[1]]\r\n\t\t\t\t];\r\n\r\n\t\t\t\tcontourFaceProc(faceOctants, faceProcFaceMask[dir][i][2], indexBuffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor(i = 0; i < 4; ++i) {\r\n\r\n\t\t\t\tc[0] = faceProcEdgeMask[dir][i][1];\r\n\t\t\t\tc[1] = faceProcEdgeMask[dir][i][2];\r\n\t\t\t\tc[2] = faceProcEdgeMask[dir][i][3];\r\n\t\t\t\tc[3] = faceProcEdgeMask[dir][i][4];\r\n\r\n\t\t\t\torder = orders[faceProcEdgeMask[dir][i][0]];\r\n\r\n\t\t\t\tedgeOctants = [];\r\n\r\n\t\t\t\tfor(j = 0; j < 4; ++j) {\r\n\r\n\t\t\t\t\toctant = octants[order[j]];\r\n\r\n\t\t\t\t\tif(octant.voxel !== null) {\r\n\r\n\t\t\t\t\t\tedgeOctants[j] = octant;\r\n\r\n\t\t\t\t\t} else if(octant.children !== null) {\r\n\r\n\t\t\t\t\t\tedgeOctants[j] = octant.children[c[j]];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(j === 4) {\r\n\r\n\t\t\t\t\tcontourEdgeProc(edgeOctants, faceProcEdgeMask[dir][i][5], indexBuffer);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * The main contouring procedure.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - An octant.\r\n\t * @param {Array} indexBuffer - An output list for vertex indices.\r\n\t */\r\n\r\n\tfunction contourCellProc(octant, indexBuffer) {\r\n\r\n\t\tconst children = octant.children;\r\n\t\tconst c = [0, 0, 0, 0];\r\n\r\n\t\tlet faceOctants, edgeOctants;\r\n\t\tlet i;\r\n\r\n\t\tif(children !== null) {\r\n\r\n\t\t\tfor(i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\tcontourCellProc(children[i], indexBuffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor(i = 0; i < 12; ++i) {\r\n\r\n\t\t\t\tc[0] = cellProcFaceMask[i][0];\r\n\t\t\t\tc[1] = cellProcFaceMask[i][1];\r\n\r\n\t\t\t\tfaceOctants = [\r\n\t\t\t\t\tchildren[c[0]],\r\n\t\t\t\t\tchildren[c[1]]\r\n\t\t\t\t];\r\n\r\n\t\t\t\tcontourFaceProc(faceOctants, cellProcFaceMask[i][2], indexBuffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor(i = 0; i < 6; ++i) {\r\n\r\n\t\t\t\tc[0] = cellProcEdgeMask[i][0];\r\n\t\t\t\tc[1] = cellProcEdgeMask[i][1];\r\n\t\t\t\tc[2] = cellProcEdgeMask[i][2];\r\n\t\t\t\tc[3] = cellProcEdgeMask[i][3];\r\n\r\n\t\t\t\tedgeOctants = [\r\n\t\t\t\t\tchildren[c[0]],\r\n\t\t\t\t\tchildren[c[1]],\r\n\t\t\t\t\tchildren[c[2]],\r\n\t\t\t\t\tchildren[c[3]]\r\n\t\t\t\t];\r\n\r\n\t\t\t\tcontourEdgeProc(edgeOctants, cellProcEdgeMask[i][4], indexBuffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Collects positions and normals from the voxel information of the given octant\r\n\t * and its children. The generated vertex indices are stored in the respective\r\n\t * voxels during the octree traversal.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - An octant.\r\n\t * @param {Array} positions - An array to be filled with vertices.\r\n\t * @param {Array} normals - An array to be filled with normals.\r\n\t * @param {Number} index - The next vertex index.\r\n\t */\r\n\r\n\tfunction generateVertexIndices(octant, positions, normals, index) {\r\n\r\n\t\tlet i, voxel;\r\n\r\n\t\tif(octant.children !== null) {\r\n\r\n\t\t\tfor(i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\tindex = generateVertexIndices(octant.children[i], positions, normals, index);\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if(octant.voxel !== null) {\r\n\r\n\t\t\tvoxel = octant.voxel;\r\n\t\t\tvoxel.index = index;\r\n\r\n\t\t\tpositions[index * 3] = voxel.position.x;\r\n\t\t\tpositions[index * 3 + 1] = voxel.position.y;\r\n\t\t\tpositions[index * 3 + 2] = voxel.position.z;\r\n\r\n\t\t\tnormals[index * 3] = voxel.normal.x;\r\n\t\t\tnormals[index * 3 + 1] = voxel.normal.y;\r\n\t\t\tnormals[index * 3 + 2] = voxel.normal.z;\r\n\r\n\t\t\t++index;\r\n\r\n\t\t}\r\n\r\n\t\treturn index;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Dual Contouring is an isosurface extraction technique that was originally\r\n\t * presented by Tao Ju in 2002:\r\n\t *  http://www.cs.wustl.edu/~taoju/research/dualContour.pdf\r\n\t */\r\n\r\n\tclass DualContouring {\r\n\r\n\t\t/**\r\n\t\t * Contours the given volume data.\r\n\t\t *\r\n\t\t * @param {SparseVoxelOctree} svo - A voxel octree.\r\n\t\t * @return {Isosurface} The generated isosurface or null if no data was generated.\r\n\t\t */\r\n\r\n\t\tstatic run(svo) {\r\n\r\n\t\t\tconst indexBuffer = [];\r\n\r\n\t\t\t// Each voxel contains one vertex.\r\n\t\t\tconst vertexCount = svo.voxelCount;\r\n\r\n\t\t\tlet result = null;\r\n\t\t\tlet positions = null;\r\n\t\t\tlet normals = null;\r\n\t\t\tlet uvs = null;\r\n\t\t\tlet materials = null;\r\n\r\n\t\t\tif(vertexCount > MAX_VERTEX_COUNT) {\r\n\r\n\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\"Could not create geometry for cell at position\", svo.min,\r\n\t\t\t\t\t\"(vertex count of\", vertexCount, \"exceeds limit of \", MAX_VERTEX_COUNT, \")\"\r\n\t\t\t\t);\r\n\r\n\t\t\t} else if(vertexCount > 0) {\r\n\r\n\t\t\t\tpositions = new Float32Array(vertexCount * 3);\r\n\t\t\t\tnormals = new Float32Array(vertexCount * 3);\r\n\t\t\t\tuvs = new Float32Array(vertexCount * 2);\r\n\t\t\t\tmaterials = new Uint8Array(vertexCount);\r\n\r\n\t\t\t\tgenerateVertexIndices(svo.root, positions, normals, 0);\r\n\t\t\t\tcontourCellProc(svo.root, indexBuffer);\r\n\r\n\t\t\t\tresult = new Isosurface(\r\n\t\t\t\t\tnew Uint16Array(indexBuffer),\r\n\t\t\t\t\tpositions,\r\n\t\t\t\t\tnormals,\r\n\t\t\t\t\tuvs,\r\n\t\t\t\t\tmaterials\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Isosurface extraction algorithms.\r\n\t *\r\n\t * @module rabbit-hole/isosurface\r\n\t */\n\n\t/**\r\n\t * A collection of loaders.\r\n\t *\r\n\t * @module rabbit-hole/loaders\r\n\t */\n\n\t/**\r\n\t * Symmetric Givens coefficients.\r\n\t *\r\n\t * @type {Vector2}\r\n\t * @private\r\n\t */\r\n\r\n\tconst coefficients = new Vector2();\r\n\r\n\t/**\r\n\t * A collection of matrix rotation utilities.\r\n\t */\r\n\r\n\tclass Givens {\r\n\r\n\t\t/**\r\n\t\t * Calculates symmetric Givens coefficients.\r\n\t\t *\r\n\t\t * @param {Number} aPP - PP.\r\n\t\t * @param {Number} aPQ - PQ.\r\n\t\t * @param {Number} aQQ - QQ.\r\n\t\t * @return {Vector2} The coefficients C and S.\r\n\t\t */\r\n\r\n\t\tstatic calculateCoefficients(aPP, aPQ, aQQ) {\r\n\r\n\t\t\tlet tau, stt, tan;\r\n\r\n\t\t\tif(aPQ === 0.0) {\r\n\r\n\t\t\t\tcoefficients.x = 1.0;\r\n\t\t\t\tcoefficients.y = 0.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttau = (aQQ - aPP) / (2.0 * aPQ);\r\n\t\t\t\tstt = Math.sqrt(1.0 + tau * tau);\r\n\t\t\t\ttan = 1.0 / ((tau >= 0.0) ? (tau + stt) : (tau - stt));\r\n\r\n\t\t\t\tcoefficients.x = 1.0 / Math.sqrt(1.0 + tan * tan);\r\n\t\t\t\tcoefficients.y = tan * coefficients.x;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn coefficients;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A collection of matrix rotation utilities.\r\n\t */\r\n\r\n\tclass Schur {\r\n\r\n\t\t/**\r\n\t\t * Rotates the given matrix.\r\n\t\t *\r\n\t\t * @param {Vector2} a - The vector that should be rotated.\r\n\t\t * @param {Vector2} coefficients - Givens coefficients.\r\n\t\t */\r\n\r\n\t\tstatic rotateXY(a, coefficients) {\r\n\r\n\t\t\tconst c = coefficients.x;\r\n\t\t\tconst s = coefficients.y;\r\n\r\n\t\t\tconst u = a.x;\r\n\t\t\tconst v = a.y;\r\n\r\n\t\t\ta.set(\r\n\t\t\t\tc * u - s * v,\r\n\t\t\t\ts * u + c * v\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rotates the given matrix.\r\n\t\t *\r\n\t\t * @param {Vector2} a - The vector that should be rotated.\r\n\t\t * @param {Vector2} q - A coefficient factor.\r\n\t\t * @param {Vector2} coefficients - Givens coefficients.\r\n\t\t */\r\n\r\n\t\tstatic rotateQXY(a, q, coefficients) {\r\n\r\n\t\t\tconst c = coefficients.x;\r\n\t\t\tconst s = coefficients.y;\r\n\t\t\tconst cc = c * c;\r\n\t\t\tconst ss = s * s;\r\n\r\n\t\t\tconst mx = 2.0 * c * s * q;\r\n\r\n\t\t\tconst u = a.x;\r\n\t\t\tconst v = a.y;\r\n\r\n\t\t\ta.set(\r\n\t\t\t\tcc * u - mx + ss * v,\r\n\t\t\t\tss * u + mx + cc * v\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A threshold for pseudo inversions.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst PSEUDOINVERSE_THRESHOLD = 1e-1;\r\n\r\n\t/**\r\n\t * The number of SVD sweeps.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst SVD_SWEEPS = 5;\r\n\r\n\t/**\r\n\t * A symmetric matrix.\r\n\t *\r\n\t * @type {SymmetricMatrix3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst sm = new SymmetricMatrix3();\r\n\r\n\t/**\r\n\t * A matrix.\r\n\t *\r\n\t * @type {Matrix3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst m$3 = new Matrix3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector2}\r\n\t * @private\r\n\t */\r\n\r\n\tconst a$3 = new Vector2();\r\n\r\n\t/**\r\n\t * A vector that holds the singular values.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b$9 = new Vector3();\r\n\r\n\t/**\r\n\t * Rotates the matrix element from the first row, second column.\r\n\t *\r\n\t * @private\r\n\t * @param {SymmetricMatrix3} vtav - A symmetric matrix.\r\n\t * @param {Matrix3} v - A matrix.\r\n\t */\r\n\r\n\tfunction rotate01(vtav, v) {\r\n\r\n\t\tconst se = vtav.elements;\r\n\t\tconst ve = v.elements;\r\n\r\n\t\tlet coefficients;\r\n\r\n\t\tif(se[1] !== 0.0) {\r\n\r\n\t\t\tcoefficients = Givens.calculateCoefficients(se[0], se[1], se[3]);\r\n\r\n\t\t\tSchur.rotateQXY(a$3.set(se[0], se[3]), se[1], coefficients);\r\n\t\t\tse[0] = a$3.x; se[3] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(se[2], se[4]), coefficients);\r\n\t\t\tse[2] = a$3.x; se[4] = a$3.y;\r\n\r\n\t\t\tse[1] = 0.0;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[0], ve[3]), coefficients);\r\n\t\t\tve[0] = a$3.x; ve[3] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[1], ve[4]), coefficients);\r\n\t\t\tve[1] = a$3.x; ve[4] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[2], ve[5]), coefficients);\r\n\t\t\tve[2] = a$3.x; ve[5] = a$3.y;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rotates the matrix element from the first row, third column.\r\n\t *\r\n\t * @private\r\n\t * @param {SymmetricMatrix3} vtav - A symmetric matrix.\r\n\t * @param {Matrix3} v - A matrix.\r\n\t */\r\n\r\n\tfunction rotate02(vtav, v) {\r\n\r\n\t\tconst se = vtav.elements;\r\n\t\tconst ve = v.elements;\r\n\r\n\t\tlet coefficients;\r\n\r\n\t\tif(se[2] !== 0.0) {\r\n\r\n\t\t\tcoefficients = Givens.calculateCoefficients(se[0], se[2], se[5]);\r\n\r\n\t\t\tSchur.rotateQXY(a$3.set(se[0], se[5]), se[2], coefficients);\r\n\t\t\tse[0] = a$3.x; se[5] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(se[1], se[4]), coefficients);\r\n\t\t\tse[1] = a$3.x; se[4] = a$3.y;\r\n\r\n\t\t\tse[2] = 0.0;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[0], ve[6]), coefficients);\r\n\t\t\tve[0] = a$3.x; ve[6] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[1], ve[7]), coefficients);\r\n\t\t\tve[1] = a$3.x; ve[7] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[2], ve[8]), coefficients);\r\n\t\t\tve[2] = a$3.x; ve[8] = a$3.y;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rotates the matrix element from the second row, third column.\r\n\t *\r\n\t * @private\r\n\t * @param {SymmetricMatrix3} vtav - A symmetric matrix.\r\n\t * @param {Matrix3} v - A matrix.\r\n\t */\r\n\r\n\tfunction rotate12(vtav, v) {\r\n\r\n\t\tconst se = vtav.elements;\r\n\t\tconst ve = v.elements;\r\n\r\n\t\tlet coefficients;\r\n\r\n\t\tif(se[4] !== 0.0) {\r\n\r\n\t\t\tcoefficients = Givens.calculateCoefficients(se[3], se[4], se[5]);\r\n\r\n\t\t\tSchur.rotateQXY(a$3.set(se[3], se[5]), se[4], coefficients);\r\n\t\t\tse[3] = a$3.x; se[5] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(se[1], se[2]), coefficients);\r\n\t\t\tse[1] = a$3.x; se[2] = a$3.y;\r\n\r\n\t\t\tse[4] = 0.0;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[3], ve[6]), coefficients);\r\n\t\t\tve[3] = a$3.x; ve[6] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[4], ve[7]), coefficients);\r\n\t\t\tve[4] = a$3.x; ve[7] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[5], ve[8]), coefficients);\r\n\t\t\tve[5] = a$3.x; ve[8] = a$3.y;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the singular values.\r\n\t *\r\n\t * @private\r\n\t * @param {SymmetricMatrix3} vtav - A symmetric matrix.\r\n\t * @param {Matrix3} v - An identity matrix.\r\n\t * @return {Vector3} The singular values.\r\n\t */\r\n\r\n\tfunction solveSymmetric(vtav, v) {\r\n\r\n\t\tconst e = vtav.elements;\r\n\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; i < SVD_SWEEPS; ++i) {\r\n\r\n\t\t\t// Rotate the upper right (lower left) triagonal.\r\n\t\t\trotate01(vtav, v);\r\n\t\t\trotate02(vtav, v);\r\n\t\t\trotate12(vtav, v);\r\n\r\n\t\t}\r\n\r\n\t\treturn b$9.set(e[0], e[3], e[5]);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the pseudo inverse of a given value.\r\n\t *\r\n\t * @private\r\n\t * @param {Number} x - The value to invert.\r\n\t * @return {Number} The inverted value.\r\n\t */\r\n\r\n\tfunction invert(x) {\r\n\r\n\t\tconst invX = (Math.abs(x) < PSEUDOINVERSE_THRESHOLD) ? 0.0 : 1.0 / x;\r\n\r\n\t\treturn (Math.abs(invX) < PSEUDOINVERSE_THRESHOLD) ? 0.0 : invX;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the pseudo inverse of v using the singular values.\r\n\t *\r\n\t * @private\r\n\t * @param {Matrix3} v - A matrix.\r\n\t * @param {Vector3} sigma - The singular values.\r\n\t * @return {Matrix3} The inverted matrix.\r\n\t */\r\n\r\n\tfunction pseudoInverse(v, sigma) {\r\n\r\n\t\tconst ve = v.elements;\r\n\r\n\t\tconst v00 = ve[0], v01 = ve[3], v02 = ve[6];\r\n\t\tconst v10 = ve[1], v11 = ve[4], v12 = ve[7];\r\n\t\tconst v20 = ve[2], v21 = ve[5], v22 = ve[8];\r\n\r\n\t\tconst d0 = invert(sigma.x);\r\n\t\tconst d1 = invert(sigma.y);\r\n\t\tconst d2 = invert(sigma.z);\r\n\r\n\t\treturn v.set(\r\n\r\n\t\t\t// First row.\r\n\t\t\tv00 * d0 * v00 + v01 * d1 * v01 + v02 * d2 * v02,\r\n\t\t\tv00 * d0 * v10 + v01 * d1 * v11 + v02 * d2 * v12,\r\n\t\t\tv00 * d0 * v20 + v01 * d1 * v21 + v02 * d2 * v22,\r\n\r\n\t\t\t// Second row.\r\n\t\t\tv10 * d0 * v00 + v11 * d1 * v01 + v12 * d2 * v02,\r\n\t\t\tv10 * d0 * v10 + v11 * d1 * v11 + v12 * d2 * v12,\r\n\t\t\tv10 * d0 * v20 + v11 * d1 * v21 + v12 * d2 * v22,\r\n\r\n\t\t\t// Third row.\r\n\t\t\tv20 * d0 * v00 + v21 * d1 * v01 + v22 * d2 * v02,\r\n\t\t\tv20 * d0 * v10 + v21 * d1 * v11 + v22 * d2 * v12,\r\n\t\t\tv20 * d0 * v20 + v21 * d1 * v21 + v22 * d2 * v22\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A Singular Value Decomposition solver.\r\n\t *\r\n\t * Decomposes the given linear system into the matrices U, D and V and solves\r\n\t * the equation: U D V^T x = b.\r\n\t *\r\n\t * See http://mathworld.wolfram.com/SingularValueDecomposition.html for more\r\n\t * information.\r\n\t */\r\n\r\n\tclass SingularValueDecomposition {\r\n\r\n\t\t/**\r\n\t\t * Performs the Singular Value Decomposition to solve the given linear system.\r\n\t\t *\r\n\t\t * @param {SymmetricMatrix3} ata - ATA. Will not be modified.\r\n\t\t * @param {Vector3} atb - ATb. Will not be modified.\r\n\t\t * @param {Vector3} x - A target vector to store the result in.\r\n\t\t */\r\n\r\n\t\tstatic solve(ata, atb, x) {\r\n\r\n\t\t\tconst sigma = solveSymmetric(sm.copy(ata), m$3.identity());\r\n\t\t\tconst invV = pseudoInverse(m$3, sigma);\r\n\r\n\t\t\tx.copy(atb).applyMatrix3(invV);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A point.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst p$3 = new Vector3();\r\n\r\n\t/**\r\n\t * Computes the error of the approximated position.\r\n\t *\r\n\t * @private\r\n\t * @param {SymmetricMatrix3} ata - ATA.\r\n\t * @param {Vector3} atb - ATb.\r\n\t * @param {Vector3} x - The calculated vertex position.\r\n\t * @return {Number} The QEF error.\r\n\t */\r\n\r\n\tfunction calculateError(ata, atb, x) {\r\n\r\n\t\tata.applyToVector3(p$3.copy(x));\r\n\t\tp$3.subVectors(atb, p$3);\r\n\r\n\t\treturn p$3.dot(p$3);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A Quaratic Error Function solver.\r\n\t *\r\n\t * Finds a point inside a voxel that minimises the sum of the squares of the\r\n\t * distances to the surface intersection planes associated with the voxel.\r\n\t *\r\n\t * Based on an implementation by Leonard Ritter and Nick Gildea:\r\n\t *  https://github.com/nickgildea/qef\r\n\t */\r\n\r\n\tclass QEFSolver {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new QEF solver.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\t/**\r\n\t\t\t * QEF data. Will be used destructively.\r\n\t\t\t *\r\n\t\t\t * @type {QEFData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * ATA.\r\n\t\t\t *\r\n\t\t\t * @type {SymmetricMatrix3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.ata = new SymmetricMatrix3();\r\n\r\n\t\t\t/**\r\n\t\t\t * ATb.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.atb = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * The mass point of the current QEF data set.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.massPoint = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * Indicates whether this solver has a solution.\r\n\t\t\t *\r\n\t\t\t * @type {Boolean}\r\n\t\t\t */\r\n\r\n\t\t\tthis.hasSolution = false;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the QEF data.\r\n\t\t *\r\n\t\t * @param {QEFData} d - QEF Data.\r\n\t\t * @return {QEFSolver} This solver.\r\n\t\t */\r\n\r\n\t\tsetData(d) {\r\n\r\n\t\t\tthis.data = d;\r\n\t\t\tthis.hasSolution = false;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Solves the Quadratic Error Function.\r\n\t\t *\r\n\t\t * @param {Vector3} x - A target vector to store the vertex position in.\r\n\t\t * @return {Number} The quadratic error of the solution.\r\n\t\t */\r\n\r\n\t\tsolve(x) {\r\n\r\n\t\t\tconst data = this.data;\r\n\t\t\tconst massPoint = this.massPoint;\r\n\t\t\tconst ata = this.ata.copy(data.ata);\r\n\t\t\tconst atb = this.atb.copy(data.atb);\r\n\r\n\t\t\tlet error = Infinity;\r\n\r\n\t\t\tif(!this.hasSolution && data !== null && data.numPoints > 0) {\r\n\r\n\t\t\t\t// Divide the mass point sum to get the average.\r\n\t\t\t\tp$3.copy(data.massPointSum).divideScalar(data.numPoints);\r\n\t\t\t\tmassPoint.copy(p$3);\r\n\r\n\t\t\t\tata.applyToVector3(p$3);\r\n\t\t\t\tatb.sub(p$3);\r\n\r\n\t\t\t\tSingularValueDecomposition.solve(ata, atb, x);\r\n\t\t\t\terror = calculateError(ata, atb, x);\r\n\t\t\t\tx.add(massPoint);\r\n\r\n\t\t\t\tthis.hasSolution = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn error;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A data container for the QEF solver.\r\n\t */\r\n\r\n\tclass QEFData {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new QEF data container.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\t/**\r\n\t\t\t * A symmetric matrix.\r\n\t\t\t *\r\n\t\t\t * @type {SymmetricMatrix3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.ata = new SymmetricMatrix3();\r\n\r\n\t\t\tthis.ata.set(\r\n\r\n\t\t\t\t0, 0, 0,\r\n\t\t\t\t0, 0,\r\n\t\t\t\t0\r\n\r\n\t\t\t);\r\n\r\n\t\t\t/**\r\n\t\t\t * A vector.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.atb = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * An accumulation of the surface intersection points.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.massPointSum = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * The amount of accumulated surface intersection points.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.numPoints = 0;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this data instance.\r\n\t\t *\r\n\t\t * @param {SymmetricMatrix3} ata - ATA.\r\n\t\t * @param {Vector3} atb - ATb.\r\n\t\t * @param {Vector3} massPointSum - The accumulated mass points.\r\n\t\t * @param {Vector3} numPoints - The number of mass points.\r\n\t\t * @return {QEFData} This data.\r\n\t\t */\r\n\r\n\t\tset(ata, atb, massPointSum, numPoints) {\r\n\r\n\t\t\tthis.ata.copy(ata);\r\n\t\t\tthis.atb.copy(atb);\r\n\r\n\t\t\tthis.massPointSum.copy(massPointSum);\r\n\t\t\tthis.numPoints = numPoints;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies values from a given data instance.\r\n\t\t *\r\n\t\t * @param {QEFData} d - The data to copy.\r\n\t\t * @return {QEFData} This data.\r\n\t\t */\r\n\r\n\t\tcopy(d) {\r\n\r\n\t\t\treturn this.set(d.ata, d.atb, d.massPointSum, d.numPoints);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds the given surface intersection point and normal.\r\n\t\t *\r\n\t\t * @param {Vector3} p - An intersection point.\r\n\t\t * @param {Vector3} n - A surface intersection normal.\r\n\t\t */\r\n\r\n\t\tadd(p, n) {\r\n\r\n\t\t\tconst nx = n.x;\r\n\t\t\tconst ny = n.y;\r\n\t\t\tconst nz = n.z;\r\n\r\n\t\t\tconst b = p.dot(n);\r\n\r\n\t\t\tconst ata = this.ata.elements;\r\n\t\t\tconst atb = this.atb;\r\n\r\n\t\t\tata[0] += nx * nx;\r\n\t\t\tata[1] += nx * ny; ata[3] += ny * ny;\r\n\t\t\tata[2] += nx * nz; ata[4] += ny * nz; ata[5] += nz * nz;\r\n\r\n\t\t\tatb.x += b * nx;\r\n\t\t\tatb.y += b * ny;\r\n\t\t\tatb.z += b * nz;\r\n\r\n\t\t\tthis.massPointSum.add(p);\r\n\r\n\t\t\t++this.numPoints;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds an entire data set.\r\n\t\t *\r\n\t\t * @param {QEFData} d - QEF data.\r\n\t\t */\r\n\r\n\t\taddData(d) {\r\n\r\n\t\t\tthis.ata.add(d.ata);\r\n\t\t\tthis.atb.add(d.atb);\r\n\r\n\t\t\tthis.massPointSum.add(d.massPointSum);\r\n\t\t\tthis.numPoints += d.numPoints;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this data.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.ata.set(\r\n\r\n\t\t\t\t0, 0, 0,\r\n\t\t\t\t0, 0,\r\n\t\t\t\t0\r\n\r\n\t\t\t);\r\n\r\n\t\t\tthis.atb.set(0, 0, 0);\r\n\t\t\tthis.massPointSum.set(0, 0, 0);\r\n\t\t\tthis.numPoints = 0;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this data.\r\n\t\t *\r\n\t\t * @return {QEFData} The cloned data.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().copy(this);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Mathematical system components.\r\n\t *\r\n\t * @module rabbit-hole/math\r\n\t */\n\n\t/**\r\n\t * A cubic voxel that holds information about the surface of a volume.\r\n\t */\r\n\r\n\tclass Voxel {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new voxel.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\t/**\r\n\t\t\t * Holds binary material information about all eight corners of this voxel.\r\n\t\t\t *\r\n\t\t\t * A value of 0 means that this voxel is completely outside of the volume,\r\n\t\t\t * whereas a value of 255 means that it's fully inside of it. Any other\r\n\t\t\t * value indicates a material change which implies that the voxel contains\r\n\t\t\t * the surface.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.materials = 0;\r\n\r\n\t\t\t/**\r\n\t\t\t * The amount of edges that exhibit a material change in this voxel.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.edgeCount = 0;\r\n\r\n\t\t\t/**\r\n\t\t\t * A generated index for this voxel's vertex. Used during the construction\r\n\t\t\t * of the final polygons.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.index = -1;\r\n\r\n\t\t\t/**\r\n\t\t\t * The vertex that lies inside this voxel.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.position = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * The normal of the vertex that lies inside this voxel.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.normal = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * A QEF data construct. Used to calculate the vertex position.\r\n\t\t\t *\r\n\t\t\t * @type {QEFData}\r\n\t\t\t */\r\n\r\n\t\t\tthis.qefData = null;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A QEF solver.\r\n\t *\r\n\t * @type {QEFSolver}\r\n\t * @private\r\n\t */\r\n\r\n\tconst qefSolver = new QEFSolver();\r\n\r\n\t/**\r\n\t * A bias for boundary checks.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst BIAS = 1e-1;\r\n\r\n\t/**\r\n\t * An error threshold for QEF-based voxel clustering.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tlet errorThreshold = -1;\r\n\r\n\t/**\r\n\t * A voxel octant.\r\n\t */\r\n\r\n\tclass VoxelCell extends CubicOctant {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new voxel octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [min] - The lower bounds of the octant.\r\n\t\t * @param {Number} [size] - The size of the octant.\r\n\t\t */\r\n\r\n\t\tconstructor(min, size) {\r\n\r\n\t\t\tsuper(min, size);\r\n\r\n\t\t\t/**\r\n\t\t\t * A voxel that contains draw information.\r\n\t\t\t *\r\n\t\t\t * @type {Voxel}\r\n\t\t\t */\r\n\r\n\t\t\tthis.voxel = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if the given point lies inside this cell.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @return {Boolean} Whether the given point lies inside this cell.\r\n\t\t */\r\n\r\n\t\tcontains(p) {\r\n\r\n\t\t\tconst min = this.min;\r\n\t\t\tconst size = this.size;\r\n\r\n\t\t\treturn (\r\n\t\t\t\tp.x >= min.x - BIAS &&\r\n\t\t\t\tp.y >= min.y - BIAS &&\r\n\t\t\t\tp.z >= min.z - BIAS &&\r\n\t\t\t\tp.x <= min.x + size + BIAS &&\r\n\t\t\t\tp.y <= min.y + size + BIAS &&\r\n\t\t\t\tp.z <= min.z + size + BIAS\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Attempts to simplify this cell.\r\n\t\t *\r\n\t\t * @return {Number} The amount of removed voxels.\r\n\t\t */\r\n\r\n\t\tcollapse() {\r\n\r\n\t\t\tconst children = this.children;\r\n\r\n\t\t\tconst signs = [\r\n\t\t\t\t-1, -1, -1, -1,\r\n\t\t\t\t-1, -1, -1, -1\r\n\t\t\t];\r\n\r\n\t\t\tconst position = new Vector3();\r\n\r\n\t\t\tlet midSign = -1;\r\n\t\t\tlet collapsible = (children !== null);\r\n\r\n\t\t\tlet removedVoxels = 0;\r\n\r\n\t\t\tlet child, sign, voxel;\r\n\t\t\tlet qefData, error;\r\n\r\n\t\t\tlet v, i;\r\n\r\n\t\t\tif(collapsible) {\r\n\r\n\t\t\t\tqefData = new QEFData();\r\n\r\n\t\t\t\tfor(v = 0, i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\t\tchild = children[i];\r\n\t\t\t\t\tremovedVoxels += child.collapse();\r\n\t\t\t\t\tvoxel = child.voxel;\r\n\r\n\t\t\t\t\tif(child.children !== null) {\r\n\r\n\t\t\t\t\t\t// Couldn't simplify the child.\r\n\t\t\t\t\t\tcollapsible = false;\r\n\r\n\t\t\t\t\t} else if(voxel !== null) {\r\n\r\n\t\t\t\t\t\tqefData.addData(voxel.qefData);\r\n\r\n\t\t\t\t\t\tmidSign = (voxel.materials >> (7 - i)) & 1;\r\n\t\t\t\t\t\tsigns[i] = (voxel.materials >> i) & 1;\r\n\r\n\t\t\t\t\t\t++v;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(collapsible) {\r\n\r\n\t\t\t\t\terror = qefSolver.setData(qefData).solve(position);\r\n\r\n\t\t\t\t\tif(error <= errorThreshold) {\r\n\r\n\t\t\t\t\t\tvoxel = new Voxel();\r\n\t\t\t\t\t\tvoxel.position.copy(this.contains(position) ? position : qefSolver.massPoint);\r\n\r\n\t\t\t\t\t\tfor(i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\t\t\t\tsign = signs[i];\r\n\t\t\t\t\t\t\tchild = children[i];\r\n\r\n\t\t\t\t\t\t\tif(sign === -1) {\r\n\r\n\t\t\t\t\t\t\t\t// Undetermined, use mid sign instead.\r\n\t\t\t\t\t\t\t\tvoxel.materials |= (midSign << i);\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tvoxel.materials |= (sign << i);\r\n\r\n\t\t\t\t\t\t\t\t// Accumulate normals.\r\n\t\t\t\t\t\t\t\tvoxel.normal.add(child.voxel.normal);\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvoxel.normal.normalize();\r\n\t\t\t\t\t\tvoxel.qefData = qefData;\r\n\r\n\t\t\t\t\t\tthis.voxel = voxel;\r\n\t\t\t\t\t\tthis.children = null;\r\n\r\n\t\t\t\t\t\t// Removed existing voxels and created a new one.\r\n\t\t\t\t\t\tremovedVoxels += v - 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn removedVoxels;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * An error threshold for QEF-based voxel clustering (mesh simplification).\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tstatic get errorThreshold() {\r\n\r\n\t\t\treturn errorThreshold;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The mesh simplification error threshold.\r\n\t\t *\r\n\t\t * A bigger threshold allows more voxel cells to collapse which results in\r\n\t\t * less vertices being created.\r\n\t\t *\r\n\t\t * An error threshold of -1 disables the mesh simplification.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tstatic set errorThreshold(value) {\r\n\r\n\t\t\terrorThreshold = value;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Creates intermediate voxel cells down to the leaf octant that is described\r\n\t * by the given local grid coordinates and returns it.\r\n\t *\r\n\t * @private\r\n\t * @param {VoxelCell} cell - The root octant.\r\n\t * @param {Number} n - The grid resolution.\r\n\t * @param {Number} x - A local grid point X-coordinate.\r\n\t * @param {Number} y - A local grid point Y-coordinate.\r\n\t * @param {Number} z - A local grid point Z-coordinate.\r\n\t * @return {VoxelCell} A leaf voxel cell.\r\n\t */\r\n\r\n\tfunction getCell(cell, n, x, y, z) {\r\n\r\n\t\tlet i = 0;\r\n\r\n\t\tfor(n = n >> 1; n > 0; n >>= 1, i = 0) {\r\n\r\n\t\t\t// YZ.\r\n\t\t\tif(x >= n) {\r\n\r\n\t\t\t\ti += 4; x -= n;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// XZ.\r\n\t\t\tif(y >= n) {\r\n\r\n\t\t\t\ti += 2; y -= n;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// XY.\r\n\t\t\tif(z >= n) {\r\n\r\n\t\t\t\ti += 1; z -= n;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(cell.children === null) {\r\n\r\n\t\t\t\tcell.split();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcell = cell.children[i];\r\n\r\n\t\t}\r\n\r\n\t\treturn cell;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a voxel and builds a material configuration code from the materials\r\n\t * in the voxel corners.\r\n\t *\r\n\t * @private\r\n\t * @param {Number} n - The grid resolution.\r\n\t * @param {Number} x - A local grid point X-coordinate.\r\n\t * @param {Number} y - A local grid point Y-coordinate.\r\n\t * @param {Number} z - A local grid point Z-coordinate.\r\n\t * @param {Uint8Array} materialIndices - The material indices.\r\n\t * @return {Voxel} A voxel.\r\n\t */\r\n\r\n\tfunction createVoxel(n, x, y, z, materialIndices) {\r\n\r\n\t\tconst m = n + 1;\r\n\t\tconst mm = m * m;\r\n\r\n\t\tconst voxel = new Voxel();\r\n\r\n\t\tlet materials, edgeCount;\r\n\t\tlet material, offset, index;\r\n\t\tlet c1, c2, m1, m2;\r\n\r\n\t\tlet i;\r\n\r\n\t\t// Pack the material information of the eight corners into a single byte.\r\n\t\tfor(materials = 0, i = 0; i < 8; ++i) {\r\n\r\n\t\t\t// Translate the coordinates into a one-dimensional grid point index.\r\n\t\t\toffset = pattern[i];\r\n\t\t\tindex = (z + offset[2]) * mm + (y + offset[1]) * m + (x + offset[0]);\r\n\r\n\t\t\t// Convert the identified material index into a binary value.\r\n\t\t\tmaterial = Math.min(materialIndices[index], Material.SOLID);\r\n\r\n\t\t\t// Store the value in bit i.\r\n\t\t\tmaterials |= (material << i);\r\n\r\n\t\t}\r\n\r\n\t\t// Find out how many edges intersect with the implicit surface.\r\n\t\tfor(edgeCount = 0, i = 0; i < 12; ++i) {\r\n\r\n\t\t\tc1 = edges[i][0];\r\n\t\t\tc2 = edges[i][1];\r\n\r\n\t\t\tm1 = (materials >> c1) & 1;\r\n\t\t\tm2 = (materials >> c2) & 1;\r\n\r\n\t\t\t// Check if there is a material change on the edge.\r\n\t\t\tif(m1 !== m2) {\r\n\r\n\t\t\t\t++edgeCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvoxel.materials = materials;\r\n\t\tvoxel.edgeCount = edgeCount;\r\n\t\tvoxel.qefData = new QEFData();\r\n\r\n\t\treturn voxel;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A sparse, cubic voxel octree.\r\n\t */\r\n\r\n\tclass SparseVoxelOctree extends Octree {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new voxel octree.\r\n\t\t *\r\n\t\t * @param {HermiteData} data - A set of volume data.\r\n\t\t * @param {Vector3} [min] - The lower bounds of this octree.\r\n\t\t * @param {Number} [size=1] - The size of this octree.\r\n\t\t */\r\n\r\n\t\tconstructor(data, min = new Vector3(), size = 1) {\r\n\r\n\t\t\tsuper();\r\n\r\n\t\t\t/**\r\n\t\t\t * The root octant.\r\n\t\t\t *\r\n\t\t\t * @type {VoxelCell}\r\n\t\t\t */\r\n\r\n\t\t\tthis.root = new VoxelCell(min, size);\r\n\r\n\t\t\t/**\r\n\t\t\t * The amount of voxels in this octree.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.voxelCount = 0;\r\n\r\n\t\t\tif(data !== null && data.edgeData !== null) {\r\n\r\n\t\t\t\tthis.construct(data);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(VoxelCell.errorThreshold >= 0) {\r\n\r\n\t\t\t\tthis.simplify();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Attempts to simplify the octree by clustering voxels.\r\n\t\t *\r\n\t\t * @private\r\n\t\t */\r\n\r\n\t\tsimplify() {\r\n\r\n\t\t\tthis.voxelCount -= this.root.collapse();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Constructs voxel cells from volume data.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {HermiteData} data - The volume data.\r\n\t\t */\r\n\r\n\t\tconstruct(data) {\r\n\r\n\t\t\tconst n = HermiteData.resolution;\r\n\t\t\tconst edgeData = data.edgeData;\r\n\t\t\tconst materialIndices = data.materialIndices;\r\n\r\n\t\t\tconst qefSolver = new QEFSolver();\r\n\t\t\tconst intersection = new Vector3();\r\n\r\n\t\t\tconst edgeIterators = [\r\n\t\t\t\tedgeData.edgesX(this.min, this.root.size),\r\n\t\t\t\tedgeData.edgesY(this.min, this.root.size),\r\n\t\t\t\tedgeData.edgesZ(this.min, this.root.size)\r\n\t\t\t];\r\n\r\n\t\t\tconst sequences = [\r\n\t\t\t\tnew Uint8Array([0, 1, 2, 3]),\r\n\t\t\t\tnew Uint8Array([0, 1, 4, 5]),\r\n\t\t\t\tnew Uint8Array([0, 2, 4, 6])\r\n\t\t\t];\r\n\r\n\t\t\tlet voxelCount = 0;\r\n\r\n\t\t\tlet edges$$1, edge;\r\n\t\t\tlet sequence, offset;\r\n\t\t\tlet cell, voxel;\r\n\r\n\t\t\tlet x, y, z;\r\n\t\t\tlet d, i;\r\n\r\n\t\t\t// Process edges X -> Y -> Z.\r\n\t\t\tfor(d = 0; d < 3; ++d) {\r\n\r\n\t\t\t\tsequence = sequences[d];\r\n\t\t\t\tedges$$1 = edgeIterators[d];\r\n\r\n\t\t\t\tfor(edge of edges$$1) {\r\n\r\n\t\t\t\t\tedge.computeZeroCrossingPosition(intersection);\r\n\r\n\t\t\t\t\t// Each edge can belong to up to four voxel cells.\r\n\t\t\t\t\tfor(i = 0; i < 4; ++i) {\r\n\r\n\t\t\t\t\t\t// Rotate around the edge.\r\n\t\t\t\t\t\toffset = pattern[sequence[i]];\r\n\r\n\t\t\t\t\t\tx = edge.coordinates.x - offset[0];\r\n\t\t\t\t\t\ty = edge.coordinates.y - offset[1];\r\n\t\t\t\t\t\tz = edge.coordinates.z - offset[2];\r\n\r\n\t\t\t\t\t\t// Check if the adjusted coordinates still lie inside the grid bounds.\r\n\t\t\t\t\t\tif(x >= 0 && y >= 0 && z >= 0 && x < n && y < n && z < n) {\r\n\r\n\t\t\t\t\t\t\tcell = getCell(this.root, n, x, y, z);\r\n\r\n\t\t\t\t\t\t\tif(cell.voxel === null) {\r\n\r\n\t\t\t\t\t\t\t\t// The existence of the edge guarantees that the voxel contains the surface.\r\n\t\t\t\t\t\t\t\tcell.voxel = createVoxel(n, x, y, z, materialIndices);\r\n\r\n\t\t\t\t\t\t\t\t++voxelCount;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Add the edge data to the voxel.\r\n\t\t\t\t\t\t\tvoxel = cell.voxel;\r\n\t\t\t\t\t\t\tvoxel.normal.add(edge.n);\r\n\t\t\t\t\t\t\tvoxel.qefData.add(intersection, edge.n);\r\n\r\n\t\t\t\t\t\t\tif(voxel.qefData.numPoints === voxel.edgeCount) {\r\n\r\n\t\t\t\t\t\t\t\t// Finalise the voxel by solving the accumulated data.\r\n\t\t\t\t\t\t\t\tqefSolver.setData(voxel.qefData).solve(voxel.position);\r\n\r\n\t\t\t\t\t\t\t\tif(!cell.contains(voxel.position)) {\r\n\r\n\t\t\t\t\t\t\t\t\tvoxel.position.copy(qefSolver.massPoint);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tvoxel.normal.normalize();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.voxelCount = voxelCount;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Space partitioning components used for contouring.\r\n\t *\r\n\t * @module rabbit-hole/octree/voxel\r\n\t */\n\n\t/**\r\n\t * World octree space partitioning components.\r\n\t *\r\n\t * @module rabbit-hole/octree/world\r\n\t */\n\n\t/**\r\n\t * Space partitioning components.\r\n\t *\r\n\t * @module rabbit-hole/octree\r\n\t */\n\n\t/**\r\n\t * Utility components.\r\n\t *\r\n\t * @module rabbit-hole/utils\r\n\t */\n\n\t/**\r\n\t * The world size of the current data cell.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tlet cellSize = 0;\r\n\r\n\t/**\r\n\t * The lower bounds of the current data cell.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst cellPosition = new Vector3();\r\n\r\n\t/**\r\n\t * Finds out which grid points lie inside the area of the given operation.\r\n\t *\r\n\t * @private\r\n\t * @param {Operation} operation - A CSG operation.\r\n\t * @return {Box3} The index bounds.\r\n\t */\r\n\r\n\tfunction computeIndexBounds(operation) {\r\n\r\n\t\tconst s = cellSize;\r\n\t\tconst n = HermiteData.resolution;\r\n\r\n\t\tconst min = new Vector3(0, 0, 0);\r\n\t\tconst max = new Vector3(n, n, n);\r\n\r\n\t\tconst cellBounds = new Box3(cellPosition, cellPosition.clone().addScalar(cellSize));\r\n\t\tconst operationBounds = operation.getBoundingBox();\r\n\r\n\t\tif(operation.type !== OperationType.INTERSECTION) {\r\n\r\n\t\t\tif(operationBounds.intersectsBox(cellBounds)) {\r\n\r\n\t\t\t\tmin.copy(operationBounds.min).max(cellBounds.min).sub(cellBounds.min);\r\n\r\n\t\t\t\tmin.x = Math.ceil(min.x * n / s);\r\n\t\t\t\tmin.y = Math.ceil(min.y * n / s);\r\n\t\t\t\tmin.z = Math.ceil(min.z * n / s);\r\n\r\n\t\t\t\tmax.copy(operationBounds.max).min(cellBounds.max).sub(cellBounds.min);\r\n\r\n\t\t\t\tmax.x = Math.floor(max.x * n / s);\r\n\t\t\t\tmax.y = Math.floor(max.y * n / s);\r\n\t\t\t\tmax.z = Math.floor(max.z * n / s);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// The chunk is unaffected by this operation.\r\n\t\t\t\tmin.set(n, n, n);\r\n\t\t\t\tmax.set(0, 0, 0);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn new Box3(min, max);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Combines material indices.\r\n\t *\r\n\t * @private\r\n\t * @param {Operation} operation - A CSG operation.\r\n\t * @param {HermiteData} data0 - A target data set.\r\n\t * @param {HermiteData} data1 - A predominant data set.\r\n\t * @param {Box3} bounds - Grid iteration limits.\r\n\t */\r\n\r\n\tfunction combineMaterialIndices(operation, data0, data1, bounds) {\r\n\r\n\t\tconst n = HermiteData.resolution;\r\n\t\tconst m = n + 1;\r\n\t\tconst mm = m * m;\r\n\r\n\t\tconst X = bounds.max.x;\r\n\t\tconst Y = bounds.max.y;\r\n\t\tconst Z = bounds.max.z;\r\n\r\n\t\tlet x, y, z;\r\n\r\n\t\tfor(z = bounds.min.z; z <= Z; ++z) {\r\n\r\n\t\t\tfor(y = bounds.min.y; y <= Y; ++y) {\r\n\r\n\t\t\t\tfor(x = bounds.min.x; x <= X; ++x) {\r\n\r\n\t\t\t\t\toperation.updateMaterialIndex((z * mm + y * m + x), data0, data1);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Generates material indices.\r\n\t *\r\n\t * @private\r\n\t * @param {DensityFunction} operation - A CSG operation.\r\n\t * @param {HermiteData} data - A target data set.\r\n\t * @param {Box3} bounds - Grid iteration limits.\r\n\t */\r\n\r\n\tfunction generateMaterialIndices(operation, data, bounds) {\r\n\r\n\t\tconst s = cellSize;\r\n\t\tconst n = HermiteData.resolution;\r\n\t\tconst m = n + 1;\r\n\t\tconst mm = m * m;\r\n\r\n\t\tconst materialIndices = data.materialIndices;\r\n\r\n\t\tconst base = cellPosition;\r\n\t\tconst offset = new Vector3();\r\n\t\tconst position = new Vector3();\r\n\r\n\t\tconst X = bounds.max.x;\r\n\t\tconst Y = bounds.max.y;\r\n\t\tconst Z = bounds.max.z;\r\n\r\n\t\tlet materialIndex;\r\n\t\tlet materials = 0;\r\n\r\n\t\tlet x, y, z;\r\n\r\n\t\tfor(z = bounds.min.z; z <= Z; ++z) {\r\n\r\n\t\t\toffset.z = z * s / n;\r\n\r\n\t\t\tfor(y = bounds.min.y; y <= Y; ++y) {\r\n\r\n\t\t\t\toffset.y = y * s / n;\r\n\r\n\t\t\t\tfor(x = bounds.min.x; x <= X; ++x) {\r\n\r\n\t\t\t\t\toffset.x = x * s / n;\r\n\r\n\t\t\t\t\tmaterialIndex = operation.generateMaterialIndex(position.addVectors(base, offset));\r\n\r\n\t\t\t\t\tif(materialIndex !== Material.AIR) {\r\n\r\n\t\t\t\t\t\tmaterialIndices[z * mm + y * m + x] = materialIndex;\r\n\r\n\t\t\t\t\t\t++materials;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdata.materials = materials;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Combines edges.\r\n\t *\r\n\t * @private\r\n\t * @param {Operation} operation - A CSG operation.\r\n\t * @param {HermiteData} data0 - A target data set.\r\n\t * @param {HermiteData} data1 - A predominant data set.\r\n\t * @return {Object} The generated edge data.\r\n\t */\r\n\r\n\tfunction combineEdges(operation, data0, data1) {\r\n\r\n\t\tconst n = HermiteData.resolution;\r\n\t\tconst m = n + 1;\r\n\t\tconst mm = m * m;\r\n\r\n\t\tconst indexOffsets = new Uint32Array([1, m, mm]);\r\n\t\tconst materialIndices = data0.materialIndices;\r\n\r\n\t\tconst edge1 = new Edge();\r\n\t\tconst edge0 = new Edge();\r\n\r\n\t\tconst edgeData1 = data1.edgeData;\r\n\t\tconst edgeData0 = data0.edgeData;\r\n\r\n\t\tconst lengths = new Uint32Array(3);\r\n\t\tconst edgeCount = EdgeData.calculate1DEdgeCount(n);\r\n\r\n\t\tconst edgeData = new EdgeData(\r\n\t\t\tn,\r\n\t\t\tMath.min(edgeCount, edgeData0.indices[0].length + edgeData1.indices[0].length),\r\n\t\t\tMath.min(edgeCount, edgeData0.indices[1].length + edgeData1.indices[1].length),\r\n\t\t\tMath.min(edgeCount, edgeData0.indices[2].length + edgeData1.indices[2].length)\r\n\t\t);\r\n\r\n\t\tlet edges1, zeroCrossings1, normals1;\r\n\t\tlet edges0, zeroCrossings0, normals0;\r\n\t\tlet edges$$1, zeroCrossings, normals;\r\n\t\tlet indexOffset;\r\n\r\n\t\tlet indexA1, indexB1;\r\n\t\tlet indexA0, indexB0;\r\n\r\n\t\tlet m1, m2;\r\n\t\tlet edge;\r\n\r\n\t\tlet c, d, i, j, il, jl;\r\n\r\n\t\t// Process the edges along the X-axis, then Y and finally Z.\r\n\t\tfor(c = 0, d = 0; d < 3; c = 0, ++d) {\r\n\r\n\t\t\tedges1 = edgeData1.indices[d];\r\n\t\t\tedges0 = edgeData0.indices[d];\r\n\t\t\tedges$$1 = edgeData.indices[d];\r\n\r\n\t\t\tzeroCrossings1 = edgeData1.zeroCrossings[d];\r\n\t\t\tzeroCrossings0 = edgeData0.zeroCrossings[d];\r\n\t\t\tzeroCrossings = edgeData.zeroCrossings[d];\r\n\r\n\t\t\tnormals1 = edgeData1.normals[d];\r\n\t\t\tnormals0 = edgeData0.normals[d];\r\n\t\t\tnormals = edgeData.normals[d];\r\n\r\n\t\t\tindexOffset = indexOffsets[d];\r\n\r\n\t\t\til = edges1.length;\r\n\t\t\tjl = edges0.length;\r\n\r\n\t\t\t// Process all generated edges.\r\n\t\t\tfor(i = 0, j = 0; i < il; ++i) {\r\n\r\n\t\t\t\tindexA1 = edges1[i];\r\n\t\t\t\tindexB1 = indexA1 + indexOffset;\r\n\r\n\t\t\t\tm1 = materialIndices[indexA1];\r\n\t\t\t\tm2 = materialIndices[indexB1];\r\n\r\n\t\t\t\tif(m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\r\n\r\n\t\t\t\t\tedge1.t = zeroCrossings1[i];\r\n\t\t\t\t\tedge1.n.x = normals1[i * 3];\r\n\t\t\t\t\tedge1.n.y = normals1[i * 3 + 1];\r\n\t\t\t\t\tedge1.n.z = normals1[i * 3 + 2];\r\n\r\n\t\t\t\t\tif(operation.type === OperationType.DIFFERENCE) {\r\n\r\n\t\t\t\t\t\tedge1.n.negate();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tedge = edge1;\r\n\r\n\t\t\t\t\t// Process existing edges up to the generated edge.\r\n\t\t\t\t\twhile(j < jl && edges0[j] <= indexA1) {\r\n\r\n\t\t\t\t\t\tindexA0 = edges0[j];\r\n\t\t\t\t\t\tindexB0 = indexA0 + indexOffset;\r\n\r\n\t\t\t\t\t\tedge0.t = zeroCrossings0[j];\r\n\t\t\t\t\t\tedge0.n.x = normals0[j * 3];\r\n\t\t\t\t\t\tedge0.n.y = normals0[j * 3 + 1];\r\n\t\t\t\t\t\tedge0.n.z = normals0[j * 3 + 2];\r\n\r\n\t\t\t\t\t\tm1 = materialIndices[indexA0];\r\n\r\n\t\t\t\t\t\tif(indexA0 < indexA1) {\r\n\r\n\t\t\t\t\t\t\tm2 = materialIndices[indexB0];\r\n\r\n\t\t\t\t\t\t\tif(m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\r\n\r\n\t\t\t\t\t\t\t\t// The edge exhibits a material change and there is no conflict.\r\n\t\t\t\t\t\t\t\tedges$$1[c] = indexA0;\r\n\t\t\t\t\t\t\t\tzeroCrossings[c] = edge0.t;\r\n\t\t\t\t\t\t\t\tnormals[c * 3] = edge0.n.x;\r\n\t\t\t\t\t\t\t\tnormals[c * 3 + 1] = edge0.n.y;\r\n\t\t\t\t\t\t\t\tnormals[c * 3 + 2] = edge0.n.z;\r\n\r\n\t\t\t\t\t\t\t\t++c;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// Resolve the conflict.\r\n\t\t\t\t\t\t\tedge = operation.selectEdge(edge0, edge1, (m1 === Material.SOLID));\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t++j;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tedges$$1[c] = indexA1;\r\n\t\t\t\t\tzeroCrossings[c] = edge.t;\r\n\t\t\t\t\tnormals[c * 3] = edge.n.x;\r\n\t\t\t\t\tnormals[c * 3 + 1] = edge.n.y;\r\n\t\t\t\t\tnormals[c * 3 + 2] = edge.n.z;\r\n\r\n\t\t\t\t\t++c;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Collect remaining edges.\r\n\t\t\twhile(j < jl) {\r\n\r\n\t\t\t\tindexA0 = edges0[j];\r\n\t\t\t\tindexB0 = indexA0 + indexOffset;\r\n\r\n\t\t\t\tm1 = materialIndices[indexA0];\r\n\t\t\t\tm2 = materialIndices[indexB0];\r\n\r\n\t\t\t\tif(m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\r\n\r\n\t\t\t\t\tedges$$1[c] = indexA0;\r\n\t\t\t\t\tzeroCrossings[c] = zeroCrossings0[j];\r\n\t\t\t\t\tnormals[c * 3] = normals0[j * 3];\r\n\t\t\t\t\tnormals[c * 3 + 1] = normals0[j * 3 + 1];\r\n\t\t\t\t\tnormals[c * 3 + 2] = normals0[j * 3 + 2];\r\n\r\n\t\t\t\t\t++c;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++j;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlengths[d] = c;\r\n\r\n\t\t}\r\n\r\n\t\treturn { edgeData, lengths };\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Generates edge data.\r\n\t *\r\n\t * @private\r\n\t * @param {DensityFunction} operation - A CSG operation.\r\n\t * @param {HermiteData} data - A target data set.\r\n\t * @param {Box3} bounds - Grid iteration limits.\r\n\t * @return {Object} The generated edge data.\r\n\t */\r\n\r\n\tfunction generateEdges(operation, data, bounds) {\r\n\r\n\t\tconst s = cellSize;\r\n\t\tconst n = HermiteData.resolution;\r\n\t\tconst m = n + 1;\r\n\t\tconst mm = m * m;\r\n\r\n\t\tconst indexOffsets = new Uint32Array([1, m, mm]);\r\n\t\tconst materialIndices = data.materialIndices;\r\n\r\n\t\tconst base = cellPosition;\r\n\t\tconst offsetA = new Vector3();\r\n\t\tconst offsetB = new Vector3();\r\n\t\tconst edge = new Edge();\r\n\r\n\t\tconst lengths = new Uint32Array(3);\r\n\t\tconst edgeData = new EdgeData(n, EdgeData.calculate1DEdgeCount(n));\r\n\r\n\t\tlet edges$$1, zeroCrossings, normals, indexOffset;\r\n\t\tlet indexA, indexB;\r\n\r\n\t\tlet minX, minY, minZ;\r\n\t\tlet maxX, maxY, maxZ;\r\n\r\n\t\tlet c, d, a, axis;\r\n\t\tlet x, y, z;\r\n\r\n\t\t// Process the edges along the X-axis, then Y and finally Z.\r\n\t\tfor(a = 4, c = 0, d = 0; d < 3; a >>= 1, c = 0, ++d) {\r\n\r\n\t\t\t// X: [1, 0, 0] Y: [0, 1, 0] Z: [0, 0, 1].\r\n\t\t\taxis = pattern[a];\r\n\r\n\t\t\tedges$$1 = edgeData.indices[d];\r\n\t\t\tzeroCrossings = edgeData.zeroCrossings[d];\r\n\t\t\tnormals = edgeData.normals[d];\r\n\t\t\tindexOffset = indexOffsets[d];\r\n\r\n\t\t\tminX = bounds.min.x; maxX = bounds.max.x;\r\n\t\t\tminY = bounds.min.y; maxY = bounds.max.y;\r\n\t\t\tminZ = bounds.min.z; maxZ = bounds.max.z;\r\n\r\n\t\t\t/* Include edges that straddle the bounding box and avoid processing grid\r\n\t\t\tpoints at chunk borders. */\r\n\t\t\tswitch(d) {\r\n\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tminX = Math.max(minX - 1, 0);\r\n\t\t\t\t\tmaxX = Math.min(maxX, n - 1);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tminY = Math.max(minY - 1, 0);\r\n\t\t\t\t\tmaxY = Math.min(maxY, n - 1);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tminZ = Math.max(minZ - 1, 0);\r\n\t\t\t\t\tmaxZ = Math.min(maxZ, n - 1);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor(z = minZ; z <= maxZ; ++z) {\r\n\r\n\t\t\t\tfor(y = minY; y <= maxY; ++y) {\r\n\r\n\t\t\t\t\tfor(x = minX; x <= maxX; ++x) {\r\n\r\n\t\t\t\t\t\tindexA = z * mm + y * m + x;\r\n\t\t\t\t\t\tindexB = indexA + indexOffset;\r\n\r\n\t\t\t\t\t\t// Check if the edge exhibits a material change.\r\n\t\t\t\t\t\tif(materialIndices[indexA] !== materialIndices[indexB]) {\r\n\r\n\t\t\t\t\t\t\toffsetA.set(\r\n\t\t\t\t\t\t\t\tx * s / n,\r\n\t\t\t\t\t\t\t\ty * s / n,\r\n\t\t\t\t\t\t\t\tz * s / n\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\toffsetB.set(\r\n\t\t\t\t\t\t\t\t(x + axis[0]) * s / n,\r\n\t\t\t\t\t\t\t\t(y + axis[1]) * s / n,\r\n\t\t\t\t\t\t\t\t(z + axis[2]) * s / n\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tedge.a.addVectors(base, offsetA);\r\n\t\t\t\t\t\t\tedge.b.addVectors(base, offsetB);\r\n\r\n\t\t\t\t\t\t\t// Create and store the edge data.\r\n\t\t\t\t\t\t\toperation.generateEdge(edge);\r\n\r\n\t\t\t\t\t\t\tedges$$1[c] = indexA;\r\n\t\t\t\t\t\t\tzeroCrossings[c] = edge.t;\r\n\t\t\t\t\t\t\tnormals[c * 3] = edge.n.x;\r\n\t\t\t\t\t\t\tnormals[c * 3 + 1] = edge.n.y;\r\n\t\t\t\t\t\t\tnormals[c * 3 + 2] = edge.n.z;\r\n\r\n\t\t\t\t\t\t\t++c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlengths[d] = c;\r\n\r\n\t\t}\r\n\r\n\t\treturn { edgeData, lengths };\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Either generates or combines volume data based on the operation type.\r\n\t *\r\n\t * @private\r\n\t * @param {Operation} operation - A CSG operation.\r\n\t * @param {HermiteData} data0 - A target data set. May be empty or full.\r\n\t * @param {HermiteData} [data1] - A predominant data set. Cannot be null.\r\n\t */\r\n\r\n\tfunction update$1(operation, data0, data1) {\r\n\r\n\t\tconst bounds = computeIndexBounds(operation);\r\n\r\n\t\tlet result, edgeData, lengths, d;\r\n\t\tlet done = false;\r\n\r\n\t\t// Grid points.\r\n\t\tif(operation.type === OperationType.DENSITY_FUNCTION) {\r\n\r\n\t\t\tgenerateMaterialIndices(operation, data0, bounds);\r\n\r\n\t\t} else if(data0.empty) {\r\n\r\n\t\t\tif(operation.type === OperationType.UNION) {\r\n\r\n\t\t\t\tdata0.set(data1);\r\n\t\t\t\tdone = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif(!(data0.full && operation.type === OperationType.UNION)) {\r\n\r\n\t\t\t\tcombineMaterialIndices(operation, data0, data1, bounds);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Edges.\r\n\t\tif(!done && !data0.empty && !data0.full) {\r\n\r\n\t\t\tresult = (operation.type === OperationType.DENSITY_FUNCTION) ?\r\n\t\t\t\tgenerateEdges(operation, data0, bounds) :\r\n\t\t\t\tcombineEdges(operation, data0, data1);\r\n\r\n\t\t\tedgeData = result.edgeData;\r\n\t\t\tlengths = result.lengths;\r\n\r\n\t\t\t// Cut off empty data.\r\n\t\t\tfor(d = 0; d < 3; ++d) {\r\n\r\n\t\t\t\tedgeData.indices[d] = edgeData.indices[d].slice(0, lengths[d]);\r\n\t\t\t\tedgeData.zeroCrossings[d] = edgeData.zeroCrossings[d].slice(0, lengths[d]);\r\n\t\t\t\tedgeData.normals[d] = edgeData.normals[d].slice(0, lengths[d] * 3);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdata0.edgeData = edgeData;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Executes the given operation to generate data.\r\n\t *\r\n\t * @private\r\n\t * @param {Operation} operation - An operation.\r\n\t * @return {HermiteData} The generated data or null if the data is empty.\r\n\t */\r\n\r\n\tfunction execute(operation) {\r\n\r\n\t\tconst children = operation.children;\r\n\r\n\t\tlet result, data;\r\n\t\tlet i, l;\r\n\r\n\t\tif(operation.type === OperationType.DENSITY_FUNCTION) {\r\n\r\n\t\t\t// Create a data target.\r\n\t\t\tresult = new HermiteData();\r\n\r\n\t\t\t// Use the density function to generate data.\r\n\t\t\tupdate$1(operation, result);\r\n\r\n\t\t}\r\n\r\n\t\t// Union, Difference or Intersection.\r\n\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t// Generate the full result of the child operation recursively.\r\n\t\t\tdata = execute(children[i]);\r\n\r\n\t\t\tif(result === undefined) {\r\n\r\n\t\t\t\tresult = data;\r\n\r\n\t\t\t} else if(data !== null) {\r\n\r\n\t\t\t\tif(result === null) {\r\n\r\n\t\t\t\t\tif(operation.type === OperationType.UNION) {\r\n\r\n\t\t\t\t\t\t// Build upon the first non-empty data.\r\n\t\t\t\t\t\tresult = data;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Combine the two data sets.\r\n\t\t\t\t\tupdate$1(operation, result, data);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if(operation.type === OperationType.INTERSECTION) {\r\n\r\n\t\t\t\t// An intersection with nothing results in nothing.\r\n\t\t\t\tresult = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(result === null && operation.type !== OperationType.UNION) {\r\n\r\n\t\t\t\t// Further subtractions and intersections would have no effect.\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn (result !== null && result.empty) ? null : result;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Constructive Solid Geometry combines Signed Distance Functions by using\r\n\t * Boolean operators to generate and transform volume data.\r\n\t */\r\n\r\n\tclass ConstructiveSolidGeometry {\r\n\r\n\t\t/**\r\n\t\t * Transforms the given Hermite data in two steps:\r\n\t\t *\r\n\t\t *  1. Generate data by executing the given SDF\r\n\t\t *  2. Combine the generated data with the given data\r\n\t\t *\r\n\t\t * @param {Number[]} min - The lower bounds of the volume data cell.\r\n\t\t * @param {Number} size - The size of the volume data cell.\r\n\t\t * @param {HermiteData} data - The volume data that should be modified.\r\n\t\t * @param {SignedDistanceFunction} sdf - An SDF.\r\n\t\t * @return {HermiteData} The modified, uncompressed data or null if the result is empty.\r\n\t\t */\r\n\r\n\t\tstatic run(min, size, data, sdf) {\r\n\r\n\t\t\tcellPosition.fromArray(min);\r\n\t\t\tcellSize = size;\r\n\r\n\t\t\tif(data === null) {\r\n\r\n\t\t\t\tif(sdf.operation === OperationType.UNION) {\r\n\r\n\t\t\t\t\t// Prepare an empty target.\r\n\t\t\t\t\tdata = new HermiteData(false);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tdata.decompress();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Step 1.\r\n\t\t\tlet operation = sdf.toCSG();\r\n\r\n\t\t\tconst generatedData = (data !== null) ? execute(operation) : null;\r\n\r\n\t\t\tif(generatedData !== null) {\r\n\r\n\t\t\t\t// Wrap the operation in a super operation.\r\n\t\t\t\tswitch(sdf.operation) {\r\n\r\n\t\t\t\t\tcase OperationType.UNION:\r\n\t\t\t\t\t\toperation = new Union(operation);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase OperationType.DIFFERENCE:\r\n\t\t\t\t\t\toperation = new Difference(operation);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase OperationType.INTERSECTION:\r\n\t\t\t\t\t\toperation = new Intersection(operation);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Step 2.\r\n\t\t\t\tupdate$1(operation, data, generatedData);\r\n\r\n\t\t\t\t// Provoke an isosurface extraction.\r\n\t\t\t\tdata.contoured = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn (data !== null && data.empty) ? null : data;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A collection of Constructive Solid Geometry components.\r\n\t *\r\n\t * @module rabbit-hole/volume/csg\r\n\t */\n\n\t/**\r\n\t * A collection of Signed Distance Function components.\r\n\t *\r\n\t * @module rabbit-hole/volume/sdf\r\n\t */\n\n\t/**\r\n\t * Volume management components.\r\n\t *\r\n\t * @module rabbit-hole/volume\r\n\t */\n\n\t/**\r\n\t * Multithreading components.\r\n\t *\r\n\t * @module rabbit-hole/worker\r\n\t */\n\n\t/**\r\n\t * Exposure of the library components.\r\n\t *\r\n\t * @module rabbit-hole\r\n\t */\n\n\t/**\r\n\t * A base class for performance test reports.\r\n\t */\r\n\r\n\tclass Report {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new report.\r\n\t\t *\r\n\t\t * @param {String} [name] - The name of this report.\r\n\t\t */\r\n\r\n\t\tconstructor(name = \"Report\") {\r\n\r\n\t\t\t/**\r\n\t\t\t * The name of this report.\r\n\t\t\t *\r\n\t\t\t * @type {String}\r\n\t\t\t */\r\n\r\n\t\t\tthis.name = name;\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of strings.\r\n\t\t\t *\r\n\t\t\t * @type {String[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.lines = [];\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of measurment values.\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = [];\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this report.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.data = [];\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds an arbitrary line to the report.\r\n\t\t *\r\n\t\t * @param {Number} line - An arbitrary line.\r\n\t\t */\r\n\r\n\t\taddLine(line) {\r\n\r\n\t\t\tthis.lines.push(line);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a measurement reading.\r\n\t\t *\r\n\t\t * @param {Number} result - A measurement reading.\r\n\t\t */\r\n\r\n\t\taddValue(value) {\r\n\r\n\t\t\tthis.data.push(value);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns a string that describes this instance.\r\n\t\t *\r\n\t\t * @return {String} The string representation.\r\n\t\t */\r\n\r\n\t\ttoString() {\r\n\r\n\t\t\tconst lines = this.lines;\r\n\t\t\tconst data = this.data;\r\n\r\n\t\t\tlet result = this.name + \"\\n\\n\";\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 0, l = lines.length; i < l; ++i) {\r\n\r\n\t\t\t\tresult += lines[i] + \"\\n\";\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult += \"\\nValues:\\n\";\r\n\t\t\tresult += \"i, ms\\n\";\r\n\r\n\t\t\tfor(i = 0, l = data.length; i < l; ++i) {\r\n\r\n\t\t\t\tresult += (i + 1) + \", \" + data[i] + \"\\n\";\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A base class for performance tests.\r\n\t */\r\n\r\n\tclass Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new test.\r\n\t\t *\r\n\t\t * @param {String} name - The name of the test.\r\n\t\t */\r\n\r\n\t\tconstructor(name = null) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The name of this test.\r\n\t\t\t *\r\n\t\t\t * @type {String}\r\n\t\t\t */\r\n\r\n\t\t\tthis.name = name;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises this test.\r\n\t\t *\r\n\t\t * @throws {Error} An error is thrown if the method is not overridden.\r\n\t\t * @return {Test} This test.\r\n\t\t */\r\n\r\n\t\tinitialize() {\r\n\r\n\t\t\tthrow new Error(\"Test#initialize method not implemented!\");\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @throws {Error} An error is thrown if the method is not overridden.\r\n\t\t * @return {Test} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthrow new Error(\"Test#clear method not implemented!\");\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @throws {Error} An error is thrown if the method is not overridden.\r\n\t\t * @return {String} A result message.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tthrow new Error(\"Test#run method not implemented!\");\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A compression test.\r\n\t */\r\n\r\n\tclass CompressionTest extends Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new compression test.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper(\"Compression Test\");\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A target container for compressed Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.targetContainer = new HermiteData(false);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {CompressionTest} This test.\r\n\t\t */\r\n\r\n\t\tinitialize() {\r\n\r\n\t\t\tconst cellSize = 1;\r\n\t\t\tconst halfSize = cellSize / 2;\r\n\t\t\tconst cellPosition = [-halfSize, -halfSize, -halfSize];\r\n\r\n\t\t\tconst sdf = SuperPrimitive.create(SuperPrimitivePreset.PIPE);\r\n\t\t\tsdf.scale.set(0.475, 0.475, 0.475);\r\n\t\t\tsdf.updateInverseTransformation();\r\n\r\n\t\t\tthis.data = ConstructiveSolidGeometry.run(cellPosition, cellSize, null, sdf.setOperationType(OperationType.UNION));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {CompressionTest} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.data = null;\r\n\t\t\tthis.targetContainer.clear();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @return {Report} A report.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tconst c = 200;\r\n\r\n\t\t\tconst report = new Report(\"Compression Report\");\r\n\t\t\tconst targetContainer = this.targetContainer;\r\n\t\t\tconst data = this.data;\r\n\r\n\t\t\tconst n = HermiteData.resolution;\r\n\t\t\tconst maxMaterials = Math.pow((n + 1), 3);\r\n\t\t\tconst maxEdges = 3 * Math.pow((n + 1), 2) * n;\r\n\r\n\t\t\tlet edgeData;\r\n\t\t\tlet materials;\r\n\t\t\tlet materialCount;\r\n\t\t\tlet runLengthCount;\r\n\t\t\tlet edgeCount;\r\n\t\t\tlet t0, i;\r\n\r\n\t\t\treport.addLine(\"Performing \" + c + \" compression tasks\");\r\n\r\n\t\t\tfor(i = 0; i < c; ++i) {\r\n\r\n\t\t\t\tt0 = performance.now();\r\n\t\t\t\tdata.compress(targetContainer);\r\n\t\t\t\treport.addValue(performance.now() - t0);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterials = targetContainer.materials;\r\n\t\t\tmaterialCount = targetContainer.materialIndices.length;\r\n\t\t\trunLengthCount = targetContainer.runLengths.length;\r\n\t\t\tedgeData = data.edgeData;\r\n\t\t\tedgeCount = (\r\n\t\t\t\tedgeData.indices[0].length +\r\n\t\t\t\tedgeData.indices[1].length +\r\n\t\t\t\tedgeData.indices[2].length\r\n\t\t\t);\r\n\r\n\t\t\treport.addLine(\"Material Statistics\");\r\n\t\t\treport.addLine(\"Total Materials: \" + maxMaterials + \" (\" + materials + \" solid)\");\r\n\t\t\treport.addLine(\"Compressed Materials: \" + materialCount + \" (+ \" + runLengthCount + \" run-lengths)\");\r\n\t\t\treport.addLine(\"Compression Ratio: \" + (maxMaterials / (materialCount + runLengthCount * 4)).toFixed(2));\r\n\t\t\treport.addLine(\"Space Savings: \" + ((1 - (materialCount + runLengthCount * 4) / maxMaterials) * 100).toFixed(2) + \"%\");\r\n\t\t\treport.addLine(\"Maximum Memory Usage: \" + ((maxMaterials * 8) / 8 / 1024).toFixed(2) + \" KB\");\r\n\t\t\treport.addLine(\"Estimated Memory Usage: \" + ((materialCount * 8 + runLengthCount * 32) / 8 / 1024).toFixed(2) + \" KB\\n\");\r\n\r\n\t\t\treport.addLine(\"Edge Data Statistics\");\r\n\t\t\treport.addLine(\"Total Edges: \" + edgeCount + \" (\" + maxEdges + \" max)\");\r\n\t\t\treport.addLine(\"Compression Ratio: \" + (maxEdges / edgeCount).toFixed(2));\r\n\t\t\treport.addLine(\"Space Savings: \" + ((1 - edgeCount / maxEdges) * 100).toFixed(2) + \"%\");\r\n\t\t\treport.addLine(\"Maximum Memory Usage: \" + ((maxEdges * 32 + maxEdges * 32 + 3 * maxEdges * 32) / 8 / 1024 / 1024).toFixed(2) + \" MB\");\r\n\t\t\treport.addLine(\"Estimated Memory Usage: \" + ((edgeCount * 32 + edgeCount * 32 + 3 * edgeCount * 32) / 8 / 1024).toFixed(2) + \" KB\");\r\n\r\n\t\t\tconsole.log(\"Compressed data\", targetContainer);\r\n\r\n\t\t\treturn report;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A decompression test.\r\n\t */\r\n\r\n\tclass DecompressionTest extends Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new decompression test.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper(\"Decompression Test\");\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A target container for compressed Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.targetContainer = new HermiteData(false);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {DecompressionTest} This test.\r\n\t\t */\r\n\r\n\t\tinitialize() {\r\n\r\n\t\t\tconst cellSize = 1;\r\n\t\t\tconst halfSize = cellSize / 2;\r\n\t\t\tconst cellPosition = [-halfSize, -halfSize, -halfSize];\r\n\r\n\t\t\tconst sdf = SuperPrimitive.create(SuperPrimitivePreset.PIPE);\r\n\t\t\tsdf.scale.set(0.475, 0.475, 0.475);\r\n\t\t\tsdf.updateInverseTransformation();\r\n\r\n\t\t\tthis.data = ConstructiveSolidGeometry.run(cellPosition, cellSize, null, sdf.setOperationType(OperationType.UNION));\r\n\t\t\tthis.data.compress();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {DecompressionTest} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.data = null;\r\n\t\t\tthis.targetContainer.clear();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tconst c = 200;\r\n\r\n\t\t\tconst report = new Report(\"Decompression Report\");\r\n\t\t\tconst targetContainer = this.targetContainer;\r\n\t\t\tconst data = this.data;\r\n\r\n\t\t\tlet t0, i;\r\n\r\n\t\t\treport.addLine(\"Performing \" + c + \" decompression tasks\");\r\n\r\n\t\t\tfor(i = 0; i < c; ++i) {\r\n\r\n\t\t\t\tt0 = performance.now();\r\n\t\t\t\tdata.decompress(targetContainer);\r\n\t\t\t\treport.addValue(performance.now() - t0);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.log(\"Decompressed data\", targetContainer);\r\n\r\n\t\t\treturn report;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A CSG test.\r\n\t */\r\n\r\n\tclass CSGTest extends Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new CSG test.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper(\"CSG Test\");\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A cell size.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellSize = 1;\r\n\r\n\t\t\t/**\r\n\t\t\t * A cell position.\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellPosition = [-0.5, -0.5, -0.5];\r\n\r\n\t\t\t/**\r\n\t\t\t * An SDF.\r\n\t\t\t *\r\n\t\t\t * @type {SignedDistanceFunction}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.sdf = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {CSGTest} This test.\r\n\t\t */\r\n\r\n\t\tinitialize() {\r\n\r\n\t\t\tconst pellet = SuperPrimitive.create(SuperPrimitivePreset.PELLET).setOperationType(OperationType.UNION);\r\n\t\t\tconst pipe = SuperPrimitive.create(SuperPrimitivePreset.PIPE).setOperationType(OperationType.UNION);\r\n\r\n\t\t\tpellet.scale.set(0.475, 0.475, 0.475);\r\n\t\t\tpellet.updateInverseTransformation();\r\n\t\t\tpipe.scale.set(0.475, 0.475, 0.475);\r\n\t\t\tpipe.updateInverseTransformation();\r\n\r\n\t\t\tthis.data = ConstructiveSolidGeometry.run(this.cellPosition, this.cellSize, null, pellet);\r\n\t\t\tthis.sdf = pipe;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {CSGTest} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.data = null;\r\n\t\t\tthis.sdf = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tconst c = 200;\r\n\r\n\t\t\tconst report = new Report(\"CSG Report\");\r\n\t\t\tconst cellPosition = this.cellPosition;\r\n\t\t\tconst cellSize = this.cellSize;\r\n\t\t\tconst data = this.data;\r\n\t\t\tconst sdf = this.sdf;\r\n\r\n\t\t\tlet result, t0, i;\r\n\r\n\t\t\treport.addLine(\"Executing \" + c + \" CSG Union operations on existing data\");\r\n\t\t\treport.addLine(\"Initial material count: \" + data.materials);\r\n\t\t\treport.addLine(\"Initial edge count: \" + (\r\n\t\t\t\tdata.edgeData.indices[0].length +\r\n\t\t\t\tdata.edgeData.indices[1].length +\r\n\t\t\t\tdata.edgeData.indices[2].length\r\n\t\t\t));\r\n\r\n\t\t\tfor(i = 0; i < c; ++i) {\r\n\r\n\t\t\t\tt0 = performance.now();\r\n\t\t\t\tresult = ConstructiveSolidGeometry.run(cellPosition, cellSize, data, sdf);\r\n\t\t\t\treport.addValue(performance.now() - t0);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treport.addLine(\"Final material count: \" + result.materials);\r\n\t\t\treport.addLine(\"Final edge count: \" + (\r\n\t\t\t\tresult.edgeData.indices[0].length +\r\n\t\t\t\tresult.edgeData.indices[1].length +\r\n\t\t\t\tresult.edgeData.indices[2].length\r\n\t\t\t));\r\n\r\n\t\t\tconsole.log(\"Generated data\", result);\r\n\r\n\t\t\treturn report;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A SVO test.\r\n\t */\r\n\r\n\tclass SVOTest extends Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new SVO test.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper(\"SVO Test\");\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A cell size.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellSize = 1;\r\n\r\n\t\t\t/**\r\n\t\t\t * A cell position.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellPosition = new Vector3(-0.5, -0.5, -0.5);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {SVOTest} This test.\r\n\t\t */\r\n\r\n\t\tinitialize() {\r\n\r\n\t\t\tconst sdf = SuperPrimitive.create(SuperPrimitivePreset.PIPE);\r\n\t\t\tsdf.scale.set(0.475, 0.475, 0.475);\r\n\t\t\tsdf.updateInverseTransformation();\r\n\r\n\t\t\tVoxelCell.errorThreshold = 1e-2;\r\n\r\n\t\t\tthis.data = ConstructiveSolidGeometry.run(this.cellPosition.toArray(), this.cellSize, null, sdf.setOperationType(OperationType.UNION));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {SVOTest} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tconst c = 200;\r\n\r\n\t\t\tconst report = new Report(\"SVO Report\");\r\n\t\t\tconst cellPosition = this.cellPosition;\r\n\t\t\tconst cellSize = this.cellSize;\r\n\t\t\tconst data = this.data;\r\n\r\n\t\t\tlet svo, t0, i;\r\n\r\n\t\t\treport.addLine(\"Building \" + c + \" sparse voxel octrees\");\r\n\t\t\treport.addLine(\"Material count: \" + data.materials);\r\n\t\t\treport.addLine(\"Edge count: \" + (\r\n\t\t\t\tdata.edgeData.indices[0].length +\r\n\t\t\t\tdata.edgeData.indices[1].length +\r\n\t\t\t\tdata.edgeData.indices[2].length\r\n\t\t\t));\r\n\r\n\t\t\tfor(i = 0; i < c; ++i) {\r\n\r\n\t\t\t\tt0 = performance.now();\r\n\t\t\t\tsvo = new SparseVoxelOctree(data, cellPosition, cellSize);\r\n\t\t\t\treport.addValue(performance.now() - t0);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treport.addLine(\"Final voxel count: \" + svo.voxelCount);\r\n\r\n\t\t\tconsole.log(\"Sparse voxel octree\", svo);\r\n\r\n\t\t\treturn report;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A contouring test.\r\n\t */\r\n\r\n\tclass ContouringTest extends Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new contouring test.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper(\"Contouring Test\");\r\n\r\n\t\t\t/**\r\n\t\t\t * A sparse voxel octree.\r\n\t\t\t *\r\n\t\t\t * @type {SparseVoxelOctree}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.svo = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {ContouringTest} This test.\r\n\t\t */\r\n\r\n\t\tinitialize() {\r\n\r\n\t\t\tconst cellSize = 1;\r\n\t\t\tconst halfSize = cellSize / 2;\r\n\t\t\tconst cellPosition = new Vector3(-halfSize, -halfSize, -halfSize);\r\n\r\n\t\t\tconst sdf = SuperPrimitive.create(SuperPrimitivePreset.PIPE);\r\n\t\t\tsdf.scale.set(0.475, 0.475, 0.475);\r\n\t\t\tsdf.updateInverseTransformation();\r\n\r\n\t\t\tVoxelCell.errorThreshold = 1e-2;\r\n\r\n\t\t\tthis.svo = new SparseVoxelOctree(\r\n\t\t\t\tConstructiveSolidGeometry.run(cellPosition.toArray(), cellSize, null, sdf.setOperationType(OperationType.UNION)),\r\n\t\t\t\tcellPosition, cellSize\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {ContouringTest} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.svo = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tconst c = 200;\r\n\r\n\t\t\tconst report = new Report(\"Contouring Report\");\r\n\t\t\tconst svo = this.svo;\r\n\r\n\t\t\tlet isosurface, t0, i;\r\n\r\n\t\t\treport.addLine(\"Performing \" + c + \" contouring tasks\");\r\n\t\t\treport.addLine(\"Voxel count: \" + svo.voxelCount);\r\n\r\n\t\t\tfor(i = 0; i < c; ++i) {\r\n\r\n\t\t\t\tt0 = performance.now();\r\n\t\t\t\tisosurface = DualContouring.run(svo);\r\n\t\t\t\treport.addValue(performance.now() - t0);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treport.addLine(\"Generated vertices: \" + (isosurface.positions.length / 3));\r\n\t\t\treport.addLine(\"Generated triangle indices: \" + isosurface.indices.length);\r\n\r\n\t\t\tconsole.log(\"Extracted isosurface\", isosurface);\r\n\r\n\t\t\treturn report;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An enumeration of worker actions.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {String} CONFIGURE - General configuration signal.\r\n\t * @property {String} TEST - Test start signal.\r\n\t */\r\n\r\n\tconst Action$1 = {\r\n\r\n\t\tCONFIGURE: \"worker.config\",\r\n\t\tTEST: \"worker.test\"\r\n\r\n\t};\n\n\t/**\r\n\t * A collection of available tests.\r\n\t *\r\n\t * @type {Map}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst tests = new Map([\r\n\t\t[\"Compression\", new CompressionTest()],\r\n\t\t[\"Decompression\", new DecompressionTest()],\r\n\t\t[\"Contouring\", new ContouringTest()],\r\n\t\t[\"CSG\", new CSGTest()],\r\n\t\t[\"SVO\", new SVOTest()]\r\n\t]);\r\n\r\n\t/**\r\n\t * Receives and handles messages from the main thread.\r\n\t *\r\n\t * @private\r\n\t * @param {Event} event - A message event containing data from the main thread.\r\n\t */\r\n\r\n\tself.addEventListener(\"message\", function onMessage(event) {\r\n\r\n\t\tconst request = event.data;\r\n\r\n\t\tlet test, report;\r\n\r\n\t\tswitch(request.action) {\r\n\r\n\t\t\tcase Action$1.CONFIGURE: {\r\n\r\n\t\t\t\tHermiteData.resolution = request.resolution;\r\n\t\t\t\tconsole.log(\"Setting Hermite data resolution to\", request.resolution);\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase Action$1.TEST: {\r\n\r\n\t\t\t\ttest = tests.get(request.id).initialize();\r\n\t\t\t\treport = test.run();\r\n\t\t\t\ttest.clear();\r\n\r\n\t\t\t\tpostMessage({\r\n\t\t\t\t\treportName: report.name,\r\n\t\t\t\t\treportURL: URL.createObjectURL(new Blob([report.toString()], { type: \"text/plain\" }))\r\n\t\t\t\t});\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t});\n\n}());\n";

	/**
	 * An object URL that points to the worker program.
	 *
	 * @type {String}
	 * @private
	 */

	const workerURL = URL.createObjectURL(new Blob([workerCode], { type: "text/javascript" }));

	/**
	 * A worker.
	 *
	 * @type {Worker}
	 * @private
	 */

	let worker = null;

	/**
	 * A list of available tests.
	 *
	 * @type {String[]}
	 * @private
	 */

	const tests = [
		"Compression",
		"Decompression",
		"Contouring",
		"CSG",
		"SVO"
	];

	/**
	 * Configures the worker.
	 *
	 * @private
	 * @param {Event} event - An event.
	 */

	function configure(event) {

		worker.postMessage({
			action: Action.CONFIGURE,
			resolution: Number.parseInt(event.target.value)
		});

	}

	/**
	 * Runs the specified test.
	 *
	 * @private
	 * @param {Event} event - An event.
	 */

	function runTest(event) {

		const id = event.target.id;
		const h3 = document.createElement("h3");

		h3.appendChild(document.createTextNode("Running " + id + " Test\u2026"));
		document.getElementById("aside").appendChild(h3);
		document.getElementById("mask").removeAttribute("class");

		worker.postMessage({
			action: Action.TEST,
			id: id
		});

	}

	/**
	 * Shows the result of test that has been completed.
	 *
	 * @private
	 * @param {Event} event - A worker message.
	 */

	function showResult(event) {

		const response = event.data;
		const div = document.createElement("div");
		const span = document.createElement("span");
		const a = document.createElement("a");

		a.href = response.reportURL;
		a.setAttribute("download", response.reportName + ".log");
		a.setAttribute("class", "report");
		a.appendChild(document.createTextNode("Report \u2b73"));

		span.appendChild(document.createTextNode("Test complete"));
		span.setAttribute("class", "status");
		span.appendChild(a);

		div.setAttribute("class", "result");
		div.appendChild(span);
		div.appendChild(a);

		document.getElementById("aside").appendChild(div);
		document.getElementById("mask").setAttribute("class", "hidden");

	}

	/**
	 * Creates a list of available tests.
	 *
	 * @private
	 */

	function showAvailableTests() {

		const main = document.getElementById("main");
		const ul = document.createElement("ul");

		let test, li, a;

		for(test of tests) {

			li = document.createElement("li");

			a = document.createElement("a");
			a.appendChild(document.createTextNode(test));
			a.setAttribute("href", "#" + test);
			a.setAttribute("id", test);
			a.addEventListener("click", runTest);

			li.appendChild(a);
			ul.appendChild(li);

		}

		main.appendChild(ul);

	}

	/**
	 * Handles worker events.
	 *
	 * @param {Event} event - An event.
	 */

	function handleEvent(event) {

		switch(event.type) {

			case "message":
				showResult(event);
				break;

			case "error":
				console.error("Encountered an unexpected error", event);
				break;

		}

	}

	/**
	 * Starts the program.
	 *
	 * @private
	 * @param {Event} event - An event.
	 */

	window.addEventListener("load", function main(event) {

		window.removeEventListener("load", main);
		document.getElementById("resolution").addEventListener("change", configure);

		// Initialise the worker thread.
		worker = new Worker(workerURL);
		worker.addEventListener("message", handleEvent);
		worker.addEventListener("error", handleEvent);
		worker.postMessage({
			action: Action.CONFIGURE,
			resolution: 64
		});

		showAvailableTests();

	});

}());
