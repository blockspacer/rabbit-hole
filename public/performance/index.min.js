!function(){"use strict";var t={CONFIGURE:"worker.config",TEST:"worker.test"},n=URL.createObjectURL(new Blob(['!function(){"use strict";var t=function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")},n=function(){function t(t,n){for(var e=0;e<n.length;e++){var i=n[e];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(n,e,i){return e&&t(n.prototype,e),i&&t(n,i),n}}(),e=function t(n,e,i){null===n&&(n=Function.prototype);var a=Object.getOwnPropertyDescriptor(n,e);if(void 0===a){var r=Object.getPrototypeOf(n);return null===r?void 0:t(r,e,i)}if("value"in a)return a.value;var s=a.get;if(void 0!==s)return s.call(i)},i=function(t,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);t.prototype=Object.create(n&&n.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(t,n):t.__proto__=n)},a=function(t,n){if(!t)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return!n||"object"!=typeof n&&"function"!=typeof n?t:n},r=function(t){if(Array.isArray(t)){for(var n=0,e=Array(t.length);n<t.length;n++)e[n]=t[n];return e}return Array.from(t)},s=(function(){function e(){t(this,e)}n(e,[{key:"serialize",value:function(){throw new Error("Serializable#serialise method not implemented!")}}])}(),function(){function e(){t(this,e)}n(e,[{key:"deserialize",value:function(t){throw new Error("Deserializable#deserialise method not implemented!")}}])}(),function(){function e(){t(this,e)}n(e,[{key:"dispose",value:function(){throw new Error("Disposable#dispose method not implemented!")}}])}(),function(){function e(){t(this,e)}n(e,[{key:"createTransferList",value:function(){throw new Error("TransferableContainer#createTransferList method not implemented!")}}])}(),function(){function e(){t(this,e),this.elements=[],this.head=0}return n(e,[{key:"add",value:function(t){this.elements.push(t)}},{key:"peek",value:function(){return this.elements.length>0?this.elements[this.head]:void 0}},{key:"poll",value:function(){var t=this.elements,n=t.length,e=void 0;return n>0&&(e=t[this.head++],2*this.head>=n&&(this.elements=t.slice(this.head),this.head=0)),e}},{key:"clear",value:function(){this.elements=[],this.head=0}},{key:"size",get:function(){return this.elements.length-this.head}},{key:"empty",get:function(){return 0===this.elements.length}}]),e}()),o=function n(e){t(this,n),this.type=e,this.target=null},u=function(){function e(){t(this,e),this.listenerFunctions=new Map,this.listenerObjects=new Map}return n(e,[{key:"addEventListener",value:function(t,n){var e="function"==typeof n?this.listenerFunctions:this.listenerObjects;e.has(t)?e.get(t).add(n):e.set(t,new Set([n]))}},{key:"removeEventListener",value:function(t,n){var e="function"==typeof n?this.listenerFunctions:this.listenerObjects,i=void 0;e.has(t)&&((i=e.get(t)).delete(n),0===i.size&&e.delete(t))}},{key:"dispatchEvent",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this,e=n.listenerFunctions,i=n.listenerObjects,a=void 0;if(t.target=n,e.has(t.type)){a=e.get(t.type);var r=!0,s=!1,o=void 0;try{for(var u,l=a[Symbol.iterator]();!(r=(u=l.next()).done);r=!0)u.value.call(n,t)}catch(t){s=!0,o=t}finally{try{!r&&l.return&&l.return()}finally{if(s)throw o}}}if(i.has(t.type)){a=i.get(t.type);var h=!0,c=!1,d=void 0;try{for(var v,m=a[Symbol.iterator]();!(h=(v=m.next()).done);h=!0)v.value.handleEvent(t)}catch(t){c=!0,d=t}finally{try{!h&&m.return&&m.return()}finally{if(c)throw d}}}}}]),e}(),l={UNION:"csg.union",DIFFERENCE:"csg.difference",INTERSECTION:"csg.intersection",DENSITY_FUNCTION:"csg.densityfunction"},h=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;t(this,e),this.x=n,this.y=i,this.z=a}return n(e,[{key:"set",value:function(t,n,e){return this.x=t,this.y=n,this.z=e,this}},{key:"copy",value:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z)}},{key:"fromArray",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this}},{key:"toArray",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t}},{key:"setFromSpherical",value:function(t){var n=Math.sin(t.phi)*t.radius;return this.x=n*Math.sin(t.theta),this.y=Math.cos(t.phi)*t.radius,this.z=n*Math.cos(t.theta),this}},{key:"setFromCylindrical",value:function(t){return this.x=t.radius*Math.sin(t.theta),this.y=t.y,this.z=t.radius*Math.cos(t.theta),this}},{key:"setFromMatrixColumn",value:function(t,n){return this.fromArray(t.elements,4*n)}},{key:"setFromMatrixPosition",value:function(t){var n=t.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this}},{key:"setFromMatrixScale",value:function(t){var n=this.setFromMatrixColumn(t,0).length(),e=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=n,this.y=e,this.z=i,this}},{key:"add",value:function(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}},{key:"addScalar",value:function(t){return this.x+=t,this.y+=t,this.z+=t,this}},{key:"addVectors",value:function(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this.z=t.z+n.z,this}},{key:"addScaledVector",value:function(t,n){return this.x+=t.x*n,this.y+=t.y*n,this.z+=t.z*n,this}},{key:"sub",value:function(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}},{key:"subScalar",value:function(t){return this.x-=t,this.y-=t,this.z-=t,this}},{key:"subVectors",value:function(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this.z=t.z-n.z,this}},{key:"multiply",value:function(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}},{key:"multiplyScalar",value:function(t){return this.x*=t,this.y*=t,this.z*=t,this}},{key:"multiplyVectors",value:function(t,n){return this.x=t.x*n.x,this.y=t.y*n.y,this.z=t.z*n.z,this}},{key:"divide",value:function(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}},{key:"divideScalar",value:function(t){return this.x/=t,this.y/=t,this.z/=t,this}},{key:"crossVectors",value:function(t,n){var e=t.x,i=t.y,a=t.z,r=n.x,s=n.y,o=n.z;return this.x=i*o-a*s,this.y=a*r-e*o,this.z=e*s-i*r,this}},{key:"cross",value:function(t){return this.crossVectors(this,t)}},{key:"transformDirection",value:function(t){var n=this.x,e=this.y,i=this.z,a=t.elements;return this.x=a[0]*n+a[4]*e+a[8]*i,this.y=a[1]*n+a[5]*e+a[9]*i,this.z=a[2]*n+a[6]*e+a[10]*i,this.normalize()}},{key:"applyMatrix3",value:function(t){var n=this.x,e=this.y,i=this.z,a=t.elements;return this.x=a[0]*n+a[3]*e+a[6]*i,this.y=a[1]*n+a[4]*e+a[7]*i,this.z=a[2]*n+a[5]*e+a[8]*i,this}},{key:"applyMatrix4",value:function(t){var n=this.x,e=this.y,i=this.z,a=t.elements;return this.x=a[0]*n+a[4]*e+a[8]*i+a[12],this.y=a[1]*n+a[5]*e+a[9]*i+a[13],this.z=a[2]*n+a[6]*e+a[10]*i+a[14],this}},{key:"applyQuaternion",value:function(t){var n=this.x,e=this.y,i=this.z,a=t.x,r=t.y,s=t.z,o=t.w,u=o*n+r*i-s*e,l=o*e+s*n-a*i,h=o*i+a*e-r*n,c=-a*n-r*e-s*i;return this.x=u*o+c*-a+l*-s-h*-r,this.y=l*o+c*-r+h*-a-u*-s,this.z=h*o+c*-s+u*-r-l*-a,this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}},{key:"dot",value:function(t){return this.x*t.x+this.y*t.y+this.z*t.z}},{key:"reflect",value:function(t){arguments.length>1&&void 0!==arguments[1]?arguments[1]:new e;var n=t.x,i=t.y,a=t.z;return this.sub(t.multiplyScalar(2*this.dot(t))),t.set(n,i,a),this}},{key:"angleTo",value:function(t){var n=this.dot(t)/Math.sqrt(this.lengthSquared()*t.lengthSquared());return Math.acos(Math.min(Math.max(n,-1),1))}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}},{key:"lengthSquared",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}},{key:"manhattanDistanceTo",value:function(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}},{key:"distanceToSquared",value:function(t){var n=this.x-t.x,e=this.y-t.y,i=this.z-t.z;return n*n+e*e+i*i}},{key:"distanceTo",value:function(t){return Math.sqrt(this.distanceToSquared(t))}},{key:"normalize",value:function(){return this.divideScalar(this.length())}},{key:"setLength",value:function(t){return this.normalize().multiplyScalar(t)}},{key:"min",value:function(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}},{key:"max",value:function(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}},{key:"clamp",value:function(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this.z=Math.max(t.z,Math.min(n.z,this.z)),this}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}},{key:"lerp",value:function(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this.z+=(t.z-this.z)*n,this}},{key:"lerpVectors",value:function(t,n,e){return this.subVectors(n,t).multiplyScalar(e).add(t)}},{key:"equals",value:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}}]),e}(),c=new h,d=[new h,new h,new h,new h,new h,new h,new h,new h],v=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h(1/0,1/0,1/0),i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h(-1/0,-1/0,-1/0);t(this,e),this.min=n,this.max=i}return n(e,[{key:"set",value:function(t,n){return this.min.copy(t),this.max.copy(n),this}},{key:"copy",value:function(t){return this.min.copy(t.min),this.max.copy(t.max),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"makeEmpty",value:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}},{key:"isEmpty",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}},{key:"getCenter",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h;return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getSize",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h;return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}},{key:"getBoundingSphere",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new y;return this.getCenter(t.center),t.radius=.5*this.getSize(c).length(),t}},{key:"expandByPoint",value:function(t){return this.min.min(t),this.max.max(t),this}},{key:"expandByVector",value:function(t){return this.min.sub(t),this.max.add(t),this}},{key:"expandByScalar",value:function(t){return this.min.addScalar(-t),this.max.addScalar(t),this}},{key:"setFromPoints",value:function(t){var n=void 0,e=void 0;for(this.min.set(0,0,0),this.max.set(0,0,0),n=0,e=t.length;n<e;++n)this.expandByPoint(t[n]);return this}},{key:"setFromCenterAndSize",value:function(t,n){var e=c.copy(n).multiplyScalar(.5);return this.min.copy(t).sub(e),this.max.copy(t).add(e),this}},{key:"clampPoint",value:function(t){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h).copy(t).clamp(this.min,this.max)}},{key:"distanceToPoint",value:function(t){return c.copy(t).clamp(this.min,this.max).sub(t).length()}},{key:"applyMatrix4",value:function(t){var n=this.min,e=this.max;return this.isEmpty()||(d[0].set(n.x,n.y,n.z).applyMatrix4(t),d[1].set(n.x,n.y,e.z).applyMatrix4(t),d[2].set(n.x,e.y,n.z).applyMatrix4(t),d[3].set(n.x,e.y,e.z).applyMatrix4(t),d[4].set(e.x,n.y,n.z).applyMatrix4(t),d[5].set(e.x,n.y,e.z).applyMatrix4(t),d[6].set(e.x,e.y,n.z).applyMatrix4(t),d[7].set(e.x,e.y,e.z).applyMatrix4(t),this.setFromPoints(d)),this}},{key:"translate",value:function(t){return this.min.add(t),this.max.add(t),this}},{key:"intersect",value:function(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}},{key:"union",value:function(t){return this.min.min(t.min),this.max.max(t.max),this}},{key:"containsPoint",value:function(t){var n=this.min,e=this.max;return t.x>=n.x&&t.y>=n.y&&t.z>=n.z&&t.x<=e.x&&t.y<=e.y&&t.z<=e.z}},{key:"containsBox",value:function(t){var n=this.min,e=this.max,i=t.min,a=t.max;return n.x<=i.x&&a.x<=e.x&&n.y<=i.y&&a.y<=e.y&&n.z<=i.z&&a.z<=e.z}},{key:"intersectsBox",value:function(t){var n=this.min,e=this.max,i=t.min,a=t.max;return a.x>=n.x&&a.y>=n.y&&a.z>=n.z&&i.x<=e.x&&i.y<=e.y&&i.z<=e.z}},{key:"intersectsSphere",value:function(t){return this.clampPoint(t.center,c).distanceToSquared(t.center)<=t.radius*t.radius}},{key:"intersectsPlane",value:function(t){var n=void 0,e=void 0;return t.normal.x>0?(n=t.normal.x*this.min.x,e=t.normal.x*this.max.x):(n=t.normal.x*this.max.x,e=t.normal.x*this.min.x),t.normal.y>0?(n+=t.normal.y*this.min.y,e+=t.normal.y*this.max.y):(n+=t.normal.y*this.max.y,e+=t.normal.y*this.min.y),t.normal.z>0?(n+=t.normal.z*this.min.z,e+=t.normal.z*this.max.z):(n+=t.normal.z*this.max.z,e+=t.normal.z*this.min.z),n<=t.constant&&e>=t.constant}},{key:"equals",value:function(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}]),e}(),m=new v,y=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t(this,e),this.center=n,this.radius=i}return n(e,[{key:"set",value:function(t,n){return this.center.copy(t),this.radius=n,this}},{key:"copy",value:function(t){return this.center.copy(t.center),this.radius=t.radius,this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"setFromPoints",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m.setFromPoints(t).getCenter(this.center),e=0,i=void 0,a=void 0;for(i=0,a=t.length;i<a;++i)e=Math.max(e,n.distanceToSquared(t[i]));return this.radius=Math.sqrt(e),this}},{key:"getBoundingBox",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new v;return t.set(this.center,this.center),t.expandByScalar(this.radius),t}},{key:"isEmpty",value:function(){return this.radius<=0}},{key:"translate",value:function(t){return this.center.add(t),this}},{key:"clampPoint",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=this.center.distanceToSquared(t);return n.copy(t),e>this.radius*this.radius&&(n.sub(this.center).normalize(),n.multiplyScalar(this.radius).add(this.center)),n}},{key:"distanceToPoint",value:function(t){return t.distanceTo(this.center)-this.radius}},{key:"containsPoint",value:function(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}},{key:"intersectsSphere",value:function(t){var n=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=n*n}},{key:"intersectsBox",value:function(t){return t.intersectsSphere(this)}},{key:"intersectsPlane",value:function(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}},{key:"equals",value:function(t){return t.center.equals(this.center)&&t.radius===this.radius}}]),e}(),f=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t(this,e),this.x=n,this.y=i}return n(e,[{key:"set",value:function(t,n){return this.x=t,this.y=n,this}},{key:"copy",value:function(t){return this.x=t.x,this.y=t.y,this}},{key:"clone",value:function(){return new this.constructor(this.x,this.y)}},{key:"fromArray",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[n],this.y=t[n+1],this}},{key:"toArray",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[n]=this.x,t[n+1]=this.y,t}},{key:"add",value:function(t){return this.x+=t.x,this.y+=t.y,this}},{key:"addScalar",value:function(t){return this.x+=t,this.y+=t,this}},{key:"addVectors",value:function(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this}},{key:"addScaledVector",value:function(t,n){return this.x+=t.x*n,this.y+=t.y*n,this}},{key:"sub",value:function(t){return this.x-=t.x,this.y-=t.y,this}},{key:"subScalar",value:function(t){return this.x-=t,this.y-=t,this}},{key:"subVectors",value:function(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this}},{key:"multiply",value:function(t){return this.x*=t.x,this.y*=t.y,this}},{key:"multiplyScalar",value:function(t){return this.x*=t,this.y*=t,this}},{key:"divide",value:function(t){return this.x/=t.x,this.y/=t.y,this}},{key:"divideScalar",value:function(t){return this.x/=t,this.y/=t,this}},{key:"applyMatrix3",value:function(t){var n=this.x,e=this.y,i=t.elements;return this.x=i[0]*n+i[3]*e+i[6],this.y=i[1]*n+i[4]*e+i[7],this}},{key:"dot",value:function(t){return this.x*t.x+this.y*t.y}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)}},{key:"lengthSquared",value:function(){return this.x*this.x+this.y*this.y}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y)}},{key:"manhattanDistanceTo",value:function(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}},{key:"distanceToSquared",value:function(t){var n=this.x-t.x,e=this.y-t.y;return n*n+e*e}},{key:"distanceTo",value:function(t){return Math.sqrt(this.distanceToSquared(t))}},{key:"normalize",value:function(){return this.divideScalar(this.length())}},{key:"setLength",value:function(t){return this.normalize().multiplyScalar(t)}},{key:"min",value:function(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}},{key:"max",value:function(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}},{key:"clamp",value:function(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this}},{key:"angle",value:function(){var t=Math.atan2(this.y,this.x);return t<0&&(t+=2*Math.PI),t}},{key:"lerp",value:function(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this}},{key:"lerpVectors",value:function(t,n,e){return this.subVectors(n,t).multiplyScalar(e).add(t)}},{key:"rotateAround",value:function(t,n){var e=Math.cos(n),i=Math.sin(n),a=this.x-t.x,r=this.y-t.y;return this.x=a*e-r*i+t.x,this.y=a*i+r*e+t.y,this}},{key:"equals",value:function(t){return t.x===this.x&&t.y===this.y}},{key:"width",get:function(){return this.x},set:function(t){return this.x=t}},{key:"height",get:function(){return this.y},set:function(t){return this.y=t}}]),e}(),x=new f,p=(function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new f(1/0,1/0),i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new f(-1/0,-1/0);t(this,e),this.min=n,this.max=i}n(e,[{key:"set",value:function(t,n){return this.min.copy(t),this.max.copy(n),this}},{key:"copy",value:function(t){return this.min.copy(t.min),this.max.copy(t.max),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"makeEmpty",value:function(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}},{key:"isEmpty",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y}},{key:"getCenter",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new f;return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getSize",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new f;return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}},{key:"getBoundingSphere",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new y;return this.getCenter(t.center),t.radius=.5*this.getSize(x).length(),t}},{key:"expandByPoint",value:function(t){return this.min.min(t),this.max.max(t),this}},{key:"expandByVector",value:function(t){return this.min.sub(t),this.max.add(t),this}},{key:"expandByScalar",value:function(t){return this.min.addScalar(-t),this.max.addScalar(t),this}},{key:"setFromPoints",value:function(t){var n=void 0,e=void 0;for(this.min.set(0,0),this.max.set(0,0),n=0,e=t.length;n<e;++n)this.expandByPoint(t[n]);return this}},{key:"setFromCenterAndSize",value:function(t,n){var e=x.copy(n).multiplyScalar(.5);return this.min.copy(t).sub(e),this.max.copy(t).add(e),this}},{key:"clampPoint",value:function(t){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:new f).copy(t).clamp(this.min,this.max)}},{key:"distanceToPoint",value:function(t){return x.copy(t).clamp(this.min,this.max).sub(t).length()}},{key:"translate",value:function(t){return this.min.add(t),this.max.add(t),this}},{key:"intersect",value:function(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}},{key:"union",value:function(t){return this.min.min(t.min),this.max.max(t.max),this}},{key:"containsPoint",value:function(t){var n=this.min,e=this.max;return t.x>=n.x&&t.y>=n.y&&t.x<=e.x&&t.y<=e.y}},{key:"containsBox",value:function(t){var n=this.min,e=this.max,i=t.min,a=t.max;return n.x<=i.x&&a.x<=e.x&&n.y<=i.y&&a.y<=e.y}},{key:"intersectsBox",value:function(t){var n=this.min,e=this.max,i=t.min,a=t.max;return a.x>=n.x&&a.y>=n.y&&i.x<=e.x&&i.y<=e.y}},{key:"equals",value:function(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}])}(),function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;t(this,e),this.radius=n,this.theta=i,this.y=a}n(e,[{key:"set",value:function(t,n,e){return this.radius=t,this.theta=n,this.y=e,this}},{key:"copy",value:function(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"setFromVector3",value:function(t){return this.radius=Math.sqrt(t.x*t.x+t.z*t.z),this.theta=Math.atan2(t.x,t.z),this.y=t.y,this}}])}(),function(){function e(){t(this,e),this.elements=new Float32Array([1,0,0,0,1,0,0,0,1])}return n(e,[{key:"set",value:function(t,n,e,i,a,r,s,o,u){var l=this.elements;return l[0]=t,l[3]=n,l[6]=e,l[1]=i,l[4]=a,l[7]=r,l[2]=s,l[5]=o,l[8]=u,this}},{key:"identity",value:function(){return this.set(1,0,0,0,1,0,0,0,1),this}},{key:"copy",value:function(t){var n=t.elements,e=this.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}},{key:"clone",value:function(){return(new this.constructor).fromArray(this.elements)}},{key:"fromArray",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.elements,i=void 0;for(i=0;i<9;++i)e[i]=t[i+n];return this}},{key:"toArray",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.elements,i=void 0;for(i=0;i<9;++i)t[i+n]=e[i];return t}},{key:"multiplyMatrices",value:function(t,n){var e=t.elements,i=n.elements,a=this.elements,r=e[0],s=e[3],o=e[6],u=e[1],l=e[4],h=e[7],c=e[2],d=e[5],v=e[8],m=i[0],y=i[3],f=i[6],x=i[1],p=i[4],g=i[7],k=i[2],z=i[5],w=i[8];return a[0]=r*m+s*x+o*k,a[3]=r*y+s*p+o*z,a[6]=r*f+s*g+o*w,a[1]=u*m+l*x+h*k,a[4]=u*y+l*p+h*z,a[7]=u*f+l*g+h*w,a[2]=c*m+d*x+v*k,a[5]=c*y+d*p+v*z,a[8]=c*f+d*g+v*w,this}},{key:"multiply",value:function(t){return this.multiplyMatrices(this,t)}},{key:"premultiply",value:function(t){return this.multiplyMatrices(t,this)}},{key:"multiplyScalar",value:function(t){var n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=t,n[4]*=t,n[7]*=t,n[2]*=t,n[5]*=t,n[8]*=t,this}},{key:"determinant",value:function(){var t=this.elements,n=t[0],e=t[1],i=t[2],a=t[3],r=t[4],s=t[5],o=t[6],u=t[7],l=t[8];return n*r*l-n*s*u-e*a*l+e*s*o+i*a*u-i*r*o}},{key:"getInverse",value:function(t){var n=t.elements,e=this.elements,i=n[0],a=n[1],r=n[2],s=n[3],o=n[4],u=n[5],l=n[6],h=n[7],c=n[8],d=c*o-u*h,v=u*l-c*s,m=h*s-o*l,y=i*d+a*v+r*m,f=void 0;return 0!==y?(f=1/y,e[0]=d*f,e[1]=(r*h-c*a)*f,e[2]=(u*a-r*o)*f,e[3]=v*f,e[4]=(c*i-r*l)*f,e[5]=(r*s-u*i)*f,e[6]=m*f,e[7]=(a*l-h*i)*f,e[8]=(o*i-a*s)*f):(console.error("Can\'t invert matrix, determinant is zero",t),this.identity()),this}},{key:"transpose",value:function(){var t=this.elements,n=void 0;return n=t[1],t[1]=t[3],t[3]=n,n=t[2],t[2]=t[6],t[6]=n,n=t[5],t[5]=t[7],t[7]=n,this}},{key:"scale",value:function(t,n){var e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=n,e[4]*=n,e[7]*=n,this}},{key:"rotate",value:function(t){var n=Math.cos(t),e=Math.sin(t),i=this.elements,a=i[0],r=i[3],s=i[6],o=i[1],u=i[4],l=i[7];return i[0]=n*a+e*o,i[3]=n*r+e*u,i[6]=n*s+e*l,i[1]=-e*a+n*o,i[4]=-e*r+n*u,i[7]=-e*s+n*l,this}},{key:"translate",value:function(t,n){var e=this.elements;return e[0]+=t*e[2],e[3]+=t*e[5],e[6]+=t*e[8],e[1]+=n*e[2],e[4]+=n*e[5],e[7]+=n*e[8],this}},{key:"equals",value:function(t){var n=this.elements,e=t.elements,i=!0,a=void 0;for(a=0;i&&a<9;++a)n[a]!==e[a]&&(i=!1);return i}}]),e}()),g=0,k=1,z=2,w=3,b=4,M=5,S=new h,C=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;t(this,e),this.x=n,this.y=i,this.z=a,this.w=r}return n(e,[{key:"set",value:function(t,n,e,i){return this.x=t,this.y=n,this.z=e,this.w=i,this}},{key:"copy",value:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z,this.w)}},{key:"fromArray",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this.w=t[n+3],this}},{key:"toArray",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t[n+3]=this.w,t}},{key:"setFromEuler",value:function(t){var n=t.x,e=t.y,i=t.z,a=Math.cos,r=Math.sin,s=a(n/2),o=a(e/2),u=a(i/2),l=r(n/2),h=r(e/2),c=r(i/2);switch(t.order){case g:this.x=l*o*u+s*h*c,this.y=s*h*u-l*o*c,this.z=s*o*c+l*h*u,this.w=s*o*u-l*h*c;break;case b:this.x=l*o*u+s*h*c,this.y=s*h*u-l*o*c,this.z=s*o*c-l*h*u,this.w=s*o*u+l*h*c;break;case z:this.x=l*o*u-s*h*c,this.y=s*h*u+l*o*c,this.z=s*o*c+l*h*u,this.w=s*o*u-l*h*c;break;case M:this.x=l*o*u-s*h*c,this.y=s*h*u+l*o*c,this.z=s*o*c-l*h*u,this.w=s*o*u+l*h*c;break;case k:this.x=l*o*u+s*h*c,this.y=s*h*u+l*o*c,this.z=s*o*c-l*h*u,this.w=s*o*u-l*h*c;break;case w:this.x=l*o*u-s*h*c,this.y=s*h*u-l*o*c,this.z=s*o*c+l*h*u,this.w=s*o*u+l*h*c}return this}},{key:"setFromAxisAngle",value:function(t,n){var e=n/2,i=Math.sin(e);return this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.w=Math.cos(e),this}},{key:"setFromRotationMatrix",value:function(t){var n=t.elements,e=n[0],i=n[4],a=n[8],r=n[1],s=n[5],o=n[9],u=n[2],l=n[6],h=n[10],c=e+s+h,d=void 0;return c>0?(d=.5/Math.sqrt(c+1),this.w=.25/d,this.x=(l-o)*d,this.y=(a-u)*d,this.z=(r-i)*d):e>s&&e>h?(d=2*Math.sqrt(1+e-s-h),this.w=(l-o)/d,this.x=.25*d,this.y=(i+r)/d,this.z=(a+u)/d):s>h?(d=2*Math.sqrt(1+s-e-h),this.w=(a-u)/d,this.x=(i+r)/d,this.y=.25*d,this.z=(o+l)/d):(d=2*Math.sqrt(1+h-e-s),this.w=(r-i)/d,this.x=(a+u)/d,this.y=(o+l)/d,this.z=.25*d),this}},{key:"setFromUnitVectors",value:function(t,n){var e=t.dot(n)+1;return e<1e-6?(e=0,Math.abs(t.x)>Math.abs(t.z)?S.set(-t.y,t.x,0):S.set(0,-t.z,t.y)):S.crossVectors(t,n),this.x=S.x,this.y=S.y,this.z=S.z,this.w=e,this.normalize()}},{key:"invert",value:function(){return this.conjugate().normalize()}},{key:"conjugate",value:function(){return this.x*=-1,this.y*=-1,this.z*=-1,this}},{key:"lengthSquared",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}},{key:"normalize",value:function(){var t=this.length(),n=void 0;return 0===t?(this.x=0,this.y=0,this.z=0,this.w=1):(n=1/t,this.x=this.x*n,this.y=this.y*n,this.z=this.z*n,this.w=this.w*n),this}},{key:"dot",value:function(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}},{key:"multiplyQuaternions",value:function(t,n){var e=t.x,i=t.y,a=t.z,r=t.w,s=n.x,o=n.y,u=n.z,l=n.w;return this.x=e*l+r*s+i*u-a*o,this.y=i*l+r*o+a*s-e*u,this.z=a*l+r*u+e*o-i*s,this.w=r*l-e*s-i*o-a*u,this}},{key:"multiply",value:function(t){return this.multiplyQuaternions(this,t)}},{key:"premultiply",value:function(t){return this.multiplyQuaternions(t,this)}},{key:"slerp",value:function(t,n){var e=this.x,i=this.y,a=this.z,r=this.w,s=void 0,o=void 0,u=void 0,l=void 0,h=void 0;if(1===n)this.copy(t);else if(n>0){if((s=r*t.w+e*t.x+i*t.y+a*t.z)<0?(this.w=-t.w,this.x=-t.x,this.y=-t.y,this.z=-t.z,s=-s):this.copy(t),s>=1)return this.w=r,this.x=e,this.y=i,this.z=a,this;if(o=Math.sqrt(1-s*s),Math.abs(o)<.001)return this.w=.5*(r+this.w),this.x=.5*(e+this.x),this.y=.5*(i+this.y),this.z=.5*(a+this.z),this;u=Math.atan2(o,s),l=Math.sin((1-n)*u)/o,h=Math.sin(n*u)/o,this.w=r*l+this.w*h,this.x=e*l+this.x*h,this.y=i*l+this.y*h,this.z=a*l+this.z*h}return this}},{key:"equals",value:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}}],[{key:"slerp",value:function(t,n,e,i){return e.copy(t).slerp(n,i)}},{key:"slerpFlat",value:function(t,n,e,i,a,r,s){var o=a[r],u=a[r+1],l=a[r+2],h=a[r+3],c=e[i],d=e[i+1],v=e[i+2],m=e[i+3],y=void 0,f=void 0,x=void 0,p=void 0,g=void 0,k=void 0,z=void 0,w=void 0;m===h&&c===o&&d===u&&v===l||(y=1-s,k=(p=c*o+d*u+v*l+m*h)>=0?1:-1,(g=1-p*p)>Number.EPSILON&&(x=Math.sqrt(g),z=Math.atan2(x,p*k),y=Math.sin(y*z)/x,s=Math.sin(s*z)/x),c=c*y+o*(w=s*k),d=d*y+u*w,v=v*y+l*w,m=m*y+h*w,y===1-s&&(c*=f=1/Math.sqrt(c*c+d*d+v*v+m*m),d*=f,v*=f,m*=f)),t[n]=c,t[n+1]=d,t[n+2]=v,t[n+3]=m}}]),e}();function O(t,n,e){return Math.max(Math.min(t,e),n)}var D=new p,P=new C,A=(function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;t(this,e),this.x=n,this.y=i,this.z=a,this.order=e.defaultOrder}n(e,[{key:"set",value:function(t,n,e,i){return this.x=t,this.y=n,this.z=e,this.order=i,this}},{key:"copy",value:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.order=t.order,this}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z,this.order)}},{key:"fromArray",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this.order=t[n+3],this}},{key:"toArray",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t[n+3]=this.order,t}},{key:"toVector3",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).set(this.x,this.y,this.z)}},{key:"setFromRotationMatrix",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.order,e=t.elements,i=e[0],a=e[4],r=e[8],s=e[1],o=e[5],u=e[9],l=e[2],h=e[6],c=e[10];switch(n){case g:this.y=Math.asin(O(r,-1,1)),Math.abs(r)<.99999?(this.x=Math.atan2(-u,c),this.z=Math.atan2(-a,i)):(this.x=Math.atan2(h,o),this.z=0);break;case b:this.x=Math.asin(-O(u,-1,1)),Math.abs(u)<.99999?(this.y=Math.atan2(r,c),this.z=Math.atan2(s,o)):(this.y=Math.atan2(-l,i),this.z=0);break;case z:this.x=Math.asin(O(h,-1,1)),Math.abs(h)<.99999?(this.y=Math.atan2(-l,c),this.z=Math.atan2(-a,o)):(this.y=0,this.z=Math.atan2(s,i));break;case M:this.y=Math.asin(-O(l,-1,1)),Math.abs(l)<.99999?(this.x=Math.atan2(h,c),this.z=Math.atan2(s,i)):(this.x=0,this.z=Math.atan2(-a,o));break;case k:this.z=Math.asin(O(s,-1,1)),Math.abs(s)<.99999?(this.x=Math.atan2(-u,o),this.y=Math.atan2(-l,i)):(this.x=0,this.y=Math.atan2(r,c));break;case w:this.z=Math.asin(-O(a,-1,1)),Math.abs(a)<.99999?(this.x=Math.atan2(h,o),this.y=Math.atan2(r,i)):(this.x=Math.atan2(-u,c),this.y=0)}return this.order=n,this}},{key:"setFromQuaternion",value:function(t,n){return D.makeRotationFromQuaternion(t),this.setFromRotationMatrix(D,n)}},{key:"setFromVector3",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.order;return this.set(t.x,t.y,t.z,n)}},{key:"reorder",value:function(t){return P.setFromEuler(this),this.setFromQuaternion(P,t)}},{key:"equals",value:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.order===this.order}}],[{key:"defaultOrder",get:function(){return g}}])}(),new h),_=new h,T=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h(1,0,0),i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t(this,e),this.normal=n,this.constant=i}return n(e,[{key:"set",value:function(t,n){return this.normal.copy(t),this.constant=n,this}},{key:"setComponents",value:function(t,n,e,i){return this.normal.set(t,n,e),this.constant=i,this}},{key:"copy",value:function(t){return this.normal.copy(t.normal),this.constant=t.constant,this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"setFromNormalAndCoplanarPoint",value:function(t,n){return this.normal.copy(t),this.constant=-n.dot(this.normal),this}},{key:"setFromCoplanarPoints",value:function(t,n,e){var i=A.subVectors(e,n).cross(_.subVectors(t,n)).normalize();return this.setFromNormalAndCoplanarPoint(i,A),this}},{key:"normalize",value:function(){var t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}},{key:"negate",value:function(){return this.normal.negate(),this.constant=-this.constant,this}},{key:"distanceToPoint",value:function(t){return this.normal.dot(t)+this.constant}},{key:"distanceToSphere",value:function(t){return this.distanceToPoint(t.center)-t.radius}},{key:"projectPoint",value:function(t,n){return n.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}},{key:"coplanarPoint",value:function(t){return t.copy(this.normal).multiplyScalar(-this.constant)}},{key:"translate",value:function(t){return this.constant-=t.dot(this.normal),this}},{key:"intersectLine",value:function(t,n){var e=t.delta(A),i=this.normal.dot(e);if(0===i)0===this.distanceToPoint(t.start)&&n.copy(t.start);else{var a=-(t.start.dot(this.normal)+this.constant)/i;a>=0&&a<=1&&n.copy(e).multiplyScalar(a).add(t.start)}return n}},{key:"intersectsLine",value:function(t){var n=this.distanceToPoint(t.start),e=this.distanceToPoint(t.end);return n<0&&e>0||e<0&&n>0}},{key:"intersectsBox",value:function(t){return t.intersectsPlane(this)}},{key:"intersectsSphere",value:function(t){return t.intersectsPlane(this)}},{key:"equals",value:function(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}]),e}(),I=new h,q=new h,E=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new T,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new T,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new T,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new T,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new T,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:new T;t(this,e),this.planes=[n,i,a,r,s,o]}return n(e,[{key:"set",value:function(t,n,e,i,a,r){var s=this.planes;return s[0].copy(t),s[1].copy(n),s[2].copy(e),s[3].copy(i),s[4].copy(a),s[5].copy(r),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(t){var n=this.planes,e=void 0;for(e=0;e<6;++e)n[e].copy(t.planes[e]);return this}},{key:"setFromMatrix",value:function(t){var n=this.planes,e=t.elements,i=e[0],a=e[1],r=e[2],s=e[3],o=e[4],u=e[5],l=e[6],h=e[7],c=e[8],d=e[9],v=e[10],m=e[11],y=e[12],f=e[13],x=e[14],p=e[15];return n[0].setComponents(s-i,h-o,m-c,p-y).normalize(),n[1].setComponents(s+i,h+o,m+c,p+y).normalize(),n[2].setComponents(s+a,h+u,m+d,p+f).normalize(),n[3].setComponents(s-a,h-u,m-d,p-f).normalize(),n[4].setComponents(s-r,h-l,m-v,p-x).normalize(),n[5].setComponents(s+r,h+l,m+v,p+x).normalize(),this}},{key:"intersectsSphere",value:function(t){var n=this.planes,e=t.center,i=-t.radius,a=!0,r=void 0;for(r=0;r<6;++r)if(n[r].distanceToPoint(e)<i){a=!1;break}return a}},{key:"intersectsBox",value:function(t){var n=this.planes,e=t.min,i=t.max,a=!0,r=void 0,s=void 0,o=void 0,u=void 0;for(r=0;r<6;++r)if(u=n[r],I.x=u.normal.x>0?e.x:i.x,q.x=u.normal.x>0?i.x:e.x,I.y=u.normal.y>0?e.y:i.y,q.y=u.normal.y>0?i.y:e.y,I.z=u.normal.z>0?e.z:i.z,q.z=u.normal.z>0?i.z:e.z,s=u.distanceToPoint(I),o=u.distanceToPoint(q),s<0&&o<0){a=!1;break}return a}},{key:"containsPoint",value:function(t){var n=this.planes,e=!0,i=void 0;for(i=0;i<6;++i)if(n[i].distanceToPoint(t)<0){e=!1;break}return e}}]),e}(),V=new h,F=new h,B=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h;t(this,e),this.start=n,this.end=i}return n(e,[{key:"set",value:function(t,n){return this.start.copy(t),this.end.copy(n),this}},{key:"copy",value:function(t){return this.start.copy(t.start),this.end.copy(t.end),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"getCenter",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).addVectors(this.start,this.end).multiplyScalar(.5)}},{key:"delta",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).subVectors(this.end,this.start)}},{key:"lengthSquared",value:function(){return this.start.distanceToSquared(this.end)}},{key:"length",value:function(){return this.start.distanceTo(this.end)}},{key:"at",value:function(t,n){return this.delta(n).multiplyScalar(t).add(this.start)}},{key:"closestPointToPointParameter",value:function(t,n){V.subVectors(t,this.start),F.subVectors(this.end,this.start);var e=F.dot(F),i=F.dot(V);return n?Math.min(Math.max(i/e,0),1):i/e}},{key:"closestPointToPoint",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new h,i=this.closestPointToPointParameter(t,n);return this.delta(e).multiplyScalar(i).add(this.start)}},{key:"equals",value:function(t){return t.start.equals(this.start)&&t.end.equals(this.end)}}]),e}(),R=new h,U=new h,L=new h,$=function(){function e(){t(this,e),this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return n(e,[{key:"set",value:function(t,n,e,i,a,r,s,o,u,l,h,c,d,v,m,y){var f=this.elements;return f[0]=t,f[4]=n,f[8]=e,f[12]=i,f[1]=a,f[5]=r,f[9]=s,f[13]=o,f[2]=u,f[6]=l,f[10]=h,f[14]=c,f[3]=d,f[7]=v,f[11]=m,f[15]=y,this}},{key:"identity",value:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}},{key:"copy",value:function(t){var n=t.elements,e=this.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}},{key:"clone",value:function(){return(new this.constructor).fromArray(this.elements)}},{key:"fromArray",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.elements,i=void 0;for(i=0;i<16;++i)e[i]=t[i+n];return this}},{key:"toArray",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.elements,i=void 0;for(i=0;i<16;++i)t[i+n]=e[i];return t}},{key:"getMaxScaleOnAxis",value:function(){var t=this.elements,n=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],e=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(n,e,i))}},{key:"copyPosition",value:function(t){var n=this.elements,e=t.elements;return n[12]=e[12],n[13]=e[13],n[14]=e[14],this}},{key:"setPosition",value:function(t){var n=this.elements;return n[12]=t.x,n[13]=t.y,n[14]=t.z,this}},{key:"extractBasis",value:function(t,n,e){return t.setFromMatrixColumn(this,0),n.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}},{key:"makeBasis",value:function(t,n,e){return this.set(t.x,n.x,e.x,0,t.y,n.y,e.y,0,t.z,n.z,e.z,0,0,0,0,1),this}},{key:"extractRotation",value:function(t){var n=this.elements,e=t.elements,i=1/R.setFromMatrixColumn(t,0).length(),a=1/R.setFromMatrixColumn(t,1).length(),r=1/R.setFromMatrixColumn(t,2).length();return n[0]=e[0]*i,n[1]=e[1]*i,n[2]=e[2]*i,n[4]=e[4]*a,n[5]=e[5]*a,n[6]=e[6]*a,n[8]=e[8]*r,n[9]=e[9]*r,n[10]=e[10]*r,this}},{key:"makeRotationFromEuler",value:function(t){var n=this.elements,e=t.x,i=t.y,a=t.z,r=Math.cos(e),s=Math.sin(e),o=Math.cos(i),u=Math.sin(i),l=Math.cos(a),h=Math.sin(a),c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,x=void 0,p=void 0,S=void 0,C=void 0,O=void 0,D=void 0;switch(t.order){case g:c=r*l,d=r*h,v=s*l,m=s*h,n[0]=o*l,n[4]=-o*h,n[8]=u,n[1]=d+v*u,n[5]=c-m*u,n[9]=-s*o,n[2]=m-c*u,n[6]=v+d*u,n[10]=r*o;break;case b:y=o*l,f=o*h,x=u*l,p=u*h,n[0]=y+p*s,n[4]=x*s-f,n[8]=r*u,n[1]=r*h,n[5]=r*l,n[9]=-s,n[2]=f*s-x,n[6]=p+y*s,n[10]=r*o;break;case z:y=o*l,f=o*h,x=u*l,p=u*h,n[0]=y-p*s,n[4]=-r*h,n[8]=x+f*s,n[1]=f+x*s,n[5]=r*l,n[9]=p-y*s,n[2]=-r*u,n[6]=s,n[10]=r*o;break;case M:c=r*l,d=r*h,v=s*l,m=s*h,n[0]=o*l,n[4]=v*u-d,n[8]=c*u+m,n[1]=o*h,n[5]=m*u+c,n[9]=d*u-v,n[2]=-u,n[6]=s*o,n[10]=r*o;break;case k:S=r*o,C=r*u,O=s*o,D=s*u,n[0]=o*l,n[4]=D-S*h,n[8]=O*h+C,n[1]=h,n[5]=r*l,n[9]=-s*l,n[2]=-u*l,n[6]=C*h+O,n[10]=S-D*h;break;case w:S=r*o,C=r*u,O=s*o,D=s*u,n[0]=o*l,n[4]=-h,n[8]=u*l,n[1]=S*h+D,n[5]=r*l,n[9]=C*h-O,n[2]=O*h-C,n[6]=s*l,n[10]=D*h+S}return n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}},{key:"makeRotationFromQuaternion",value:function(t){var n=this.elements,e=t.x,i=t.y,a=t.z,r=t.w,s=e+e,o=i+i,u=a+a,l=e*s,h=e*o,c=e*u,d=i*o,v=i*u,m=a*u,y=r*s,f=r*o,x=r*u;return n[0]=1-(d+m),n[4]=h-x,n[8]=c+f,n[1]=h+x,n[5]=1-(l+m),n[9]=v-y,n[2]=c-f,n[6]=v+y,n[10]=1-(l+d),n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}},{key:"lookAt",value:function(t,n,e){var i=this.elements,a=R,r=U,s=L;return s.subVectors(t,n),0===s.lengthSquared()&&(s.z=1),s.normalize(),a.crossVectors(e,s),0===a.lengthSquared()&&(1===Math.abs(e.z)?s.x+=1e-4:s.z+=1e-4,s.normalize(),a.crossVectors(e,s)),a.normalize(),r.crossVectors(s,a),i[0]=a.x,i[4]=r.x,i[8]=s.x,i[1]=a.y,i[5]=r.y,i[9]=s.y,i[2]=a.z,i[6]=r.z,i[10]=s.z,this}},{key:"multiplyMatrices",value:function(t,n){var e=this.elements,i=t.elements,a=n.elements,r=i[0],s=i[4],o=i[8],u=i[12],l=i[1],h=i[5],c=i[9],d=i[13],v=i[2],m=i[6],y=i[10],f=i[14],x=i[3],p=i[7],g=i[11],k=i[15],z=a[0],w=a[4],b=a[8],M=a[12],S=a[1],C=a[5],O=a[9],D=a[13],P=a[2],A=a[6],_=a[10],T=a[14],I=a[3],q=a[7],E=a[11],V=a[15];return e[0]=r*z+s*S+o*P+u*I,e[4]=r*w+s*C+o*A+u*q,e[8]=r*b+s*O+o*_+u*E,e[12]=r*M+s*D+o*T+u*V,e[1]=l*z+h*S+c*P+d*I,e[5]=l*w+h*C+c*A+d*q,e[9]=l*b+h*O+c*_+d*E,e[13]=l*M+h*D+c*T+d*V,e[2]=v*z+m*S+y*P+f*I,e[6]=v*w+m*C+y*A+f*q,e[10]=v*b+m*O+y*_+f*E,e[14]=v*M+m*D+y*T+f*V,e[3]=x*z+p*S+g*P+k*I,e[7]=x*w+p*C+g*A+k*q,e[11]=x*b+p*O+g*_+k*E,e[15]=x*M+p*D+g*T+k*V,this}},{key:"multiply",value:function(t){return this.multiplyMatrices(this,t)}},{key:"premultiply",value:function(t){return this.multiplyMatrices(t,this)}},{key:"multiplyScalar",value:function(t){var n=this.elements;return n[0]*=t,n[4]*=t,n[8]*=t,n[12]*=t,n[1]*=t,n[5]*=t,n[9]*=t,n[13]*=t,n[2]*=t,n[6]*=t,n[10]*=t,n[14]*=t,n[3]*=t,n[7]*=t,n[11]*=t,n[15]*=t,this}},{key:"determinant",value:function(){var t=this.elements,n=t[0],e=t[4],i=t[8],a=t[12],r=t[1],s=t[5],o=t[9],u=t[13],l=t[2],h=t[6],c=t[10],d=t[14],v=n*s,m=n*o,y=n*u,f=e*r,x=e*o,p=e*u,g=i*r,k=i*s,z=i*u,w=a*r,b=a*s,M=a*o;return t[3]*(M*h-z*h-b*c+p*c+k*d-x*d)+t[7]*(m*d-y*c+w*c-g*d+z*l-M*l)+t[11]*(y*h-v*d-w*h+f*d+b*l-p*l)+t[15]*(-k*l-m*h+v*c+g*h-f*c+x*l)}},{key:"getInverse",value:function(t){var n=this.elements,e=t.elements,i=e[0],a=e[1],r=e[2],s=e[3],o=e[4],u=e[5],l=e[6],h=e[7],c=e[8],d=e[9],v=e[10],m=e[11],y=e[12],f=e[13],x=e[14],p=e[15],g=d*x*h-f*v*h+f*l*m-u*x*m-d*l*p+u*v*p,k=y*v*h-c*x*h-y*l*m+o*x*m+c*l*p-o*v*p,z=c*f*h-y*d*h+y*u*m-o*f*m-c*u*p+o*d*p,w=y*d*l-c*f*l-y*u*v+o*f*v+c*u*x-o*d*x,b=i*g+a*k+r*z+s*w,M=void 0;return 0!==b?(M=1/b,n[0]=g*M,n[1]=(f*v*s-d*x*s-f*r*m+a*x*m+d*r*p-a*v*p)*M,n[2]=(u*x*s-f*l*s+f*r*h-a*x*h-u*r*p+a*l*p)*M,n[3]=(d*l*s-u*v*s-d*r*h+a*v*h+u*r*m-a*l*m)*M,n[4]=k*M,n[5]=(c*x*s-y*v*s+y*r*m-i*x*m-c*r*p+i*v*p)*M,n[6]=(y*l*s-o*x*s-y*r*h+i*x*h+o*r*p-i*l*p)*M,n[7]=(o*v*s-c*l*s+c*r*h-i*v*h-o*r*m+i*l*m)*M,n[8]=z*M,n[9]=(y*d*s-c*f*s-y*a*m+i*f*m+c*a*p-i*d*p)*M,n[10]=(o*f*s-y*u*s+y*a*h-i*f*h-o*a*p+i*u*p)*M,n[11]=(c*u*s-o*d*s-c*a*h+i*d*h+o*a*m-i*u*m)*M,n[12]=w*M,n[13]=(c*f*r-y*d*r+y*a*v-i*f*v-c*a*x+i*d*x)*M,n[14]=(y*u*r-o*f*r-y*a*l+i*f*l+o*a*x-i*u*x)*M,n[15]=(o*d*r-c*u*r+c*a*l-i*d*l-o*a*v+i*u*v)*M):(console.error("Can\'t invert matrix, determinant is zero",t),this.identity()),this}},{key:"transpose",value:function(){var t=this.elements,n=void 0;return n=t[1],t[1]=t[4],t[4]=n,n=t[2],t[2]=t[8],t[8]=n,n=t[6],t[6]=t[9],t[9]=n,n=t[3],t[3]=t[12],t[12]=n,n=t[7],t[7]=t[13],t[13]=n,n=t[11],t[11]=t[14],t[14]=n,this}},{key:"scale",value:function(t,n,e){var i=this.elements;return i[0]*=t,i[4]*=n,i[8]*=e,i[1]*=t,i[5]*=n,i[9]*=e,i[2]*=t,i[6]*=n,i[10]*=e,i[3]*=t,i[7]*=n,i[11]*=e,this}},{key:"makeScale",value:function(t,n,e){return this.set(t,0,0,0,0,n,0,0,0,0,e,0,0,0,0,1),this}},{key:"makeTranslation",value:function(t,n,e){return this.set(1,0,0,t,0,1,0,n,0,0,1,e,0,0,0,1),this}},{key:"makeRotationX",value:function(t){var n=Math.cos(t),e=Math.sin(t);return this.set(1,0,0,0,0,n,-e,0,0,e,n,0,0,0,0,1),this}},{key:"makeRotationY",value:function(t){var n=Math.cos(t),e=Math.sin(t);return this.set(n,0,e,0,0,1,0,0,-e,0,n,0,0,0,0,1),this}},{key:"makeRotationZ",value:function(t){var n=Math.cos(t),e=Math.sin(t);return this.set(n,-e,0,0,e,n,0,0,0,0,1,0,0,0,0,1),this}},{key:"makeRotationAxis",value:function(t,n){var e=Math.cos(n),i=Math.sin(n),a=1-e,r=t.x,s=t.y,o=t.z,u=a*r,l=a*s;return this.set(u*r+e,u*s-i*o,u*o+i*s,0,u*s+i*o,l*s+e,l*o-i*r,0,u*o-i*s,l*o+i*r,a*o*o+e,0,0,0,0,1),this}},{key:"makeShear",value:function(t,n,e){return this.set(1,n,e,0,t,1,e,0,t,n,1,0,0,0,0,1),this}},{key:"compose",value:function(t,n,e){return this.makeRotationFromQuaternion(n),this.scale(e.x,e.y,e.z),this.setPosition(t),this}},{key:"decompose",value:function(t,n,e){var i=this.elements,a=i[0],r=i[1],s=i[2],o=i[4],u=i[5],l=i[6],h=i[8],c=i[9],d=i[10],v=this.determinant(),m=R.set(a,r,s).length()*(v<0?-1:1),y=R.set(o,u,l).length(),f=R.set(h,c,d).length(),x=1/m,p=1/y,g=1/f;return t.x=i[12],t.y=i[13],t.z=i[14],i[0]*=x,i[1]*=x,i[2]*=x,i[4]*=p,i[5]*=p,i[6]*=p,i[8]*=g,i[9]*=g,i[10]*=g,n.setFromRotationMatrix(this),i[0]=a,i[1]=r,i[2]=s,i[4]=o,i[5]=u,i[6]=l,i[8]=h,i[9]=c,i[10]=d,e.x=m,e.y=y,e.z=f,this}},{key:"makePerspective",value:function(t,n,e,i,a,r){var s=this.elements,o=2*a/(n-t),u=2*a/(e-i),l=(n+t)/(n-t),h=(e+i)/(e-i),c=-(r+a)/(r-a),d=-2*r*a/(r-a);return s[0]=o,s[4]=0,s[8]=l,s[12]=0,s[1]=0,s[5]=u,s[9]=h,s[13]=0,s[2]=0,s[6]=0,s[10]=c,s[14]=d,s[3]=0,s[7]=0,s[11]=-1,s[15]=0,this}},{key:"makeOrthographic",value:function(t,n,e,i,a,r){var s=this.elements,o=1/(n-t),u=1/(e-i),l=1/(r-a),h=(n+t)*o,c=(e+i)*u,d=(r+a)*l;return s[0]=2*o,s[4]=0,s[8]=0,s[12]=-h,s[1]=0,s[5]=2*u,s[9]=0,s[13]=-c,s[2]=0,s[6]=0,s[10]=-2*l,s[14]=-d,s[3]=0,s[7]=0,s[11]=0,s[15]=1,this}},{key:"equals",value:function(t){var n=this.elements,e=t.elements,i=!0,a=void 0;for(a=0;i&&a<16;++a)n[a]!==e[a]&&(i=!1);return i}}]),e}(),N=[new h,new h,new h,new h],j=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h;t(this,e),this.origin=n,this.direction=i}return n(e,[{key:"set",value:function(t,n){return this.origin.copy(t),this.direction.copy(n),this}},{key:"copy",value:function(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"at",value:function(t){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h).copy(this.direction).multiplyScalar(t).add(this.origin)}},{key:"lookAt",value:function(t){return this.direction.copy(t).sub(this.origin).normalize(),this}},{key:"recast",value:function(t){return this.origin.copy(this.at(t,N[0])),this}},{key:"closestPointToPoint",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=n.subVectors(t,this.origin).dot(this.direction);return e>=0?n.copy(this.direction).multiplyScalar(e).add(this.origin):n.copy(this.origin)}},{key:"distanceSquaredToPoint",value:function(t){var n=N[0].subVectors(t,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(t):N[0].copy(this.direction).multiplyScalar(n).add(this.origin).distanceToSquared(t)}},{key:"distanceToPoint",value:function(t){return Math.sqrt(this.distanceSquaredToPoint(t))}},{key:"distanceToPlane",value:function(t){var n=t.normal.dot(this.direction),e=0!==n?-(this.origin.dot(t.normal)+t.constant)/n:0===t.distanceToPoint(this.origin)?0:-1;return e>=0?e:null}},{key:"distanceSquaredToSegment",value:function(t,n,e,i){var a=N[0].copy(t).add(n).multiplyScalar(.5),r=N[1].copy(n).sub(t).normalize(),s=N[2].copy(this.origin).sub(a),o=.5*t.distanceTo(n),u=-this.direction.dot(r),l=s.dot(this.direction),h=-s.dot(r),c=s.lengthSq(),d=Math.abs(1-u*u),v=void 0,m=void 0,y=void 0,f=void 0,x=void 0;return d>0?(m=u*l-h,y=o*d,(v=u*h-l)>=0?m>=-y?m<=y?x=(v*=f=1/d)*(v+u*(m*=f)+2*l)+m*(u*v+m+2*h)+c:(m=o,x=-(v=Math.max(0,-(u*m+l)))*v+m*(m+2*h)+c):(m=-o,x=-(v=Math.max(0,-(u*m+l)))*v+m*(m+2*h)+c):m<=-y?x=-(v=Math.max(0,-(-u*o+l)))*v+(m=v>0?-o:Math.min(Math.max(-o,-h),o))*(m+2*h)+c:m<=y?(v=0,x=(m=Math.min(Math.max(-o,-h),o))*(m+2*h)+c):x=-(v=Math.max(0,-(u*o+l)))*v+(m=v>0?o:Math.min(Math.max(-o,-h),o))*(m+2*h)+c):(m=u>0?-o:o,x=-(v=Math.max(0,-(u*m+l)))*v+m*(m+2*h)+c),void 0!==e&&e.copy(this.direction).multiplyScalar(v).add(this.origin),void 0!==i&&i.copy(r).multiplyScalar(m).add(a),x}},{key:"intersectSphere",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=N[0].subVectors(t.center,this.origin),i=e.dot(this.direction),a=e.dot(e)-i*i,r=t.radius*t.radius,s=null,o=void 0,u=void 0,l=void 0;return a<=r&&(l=i+(o=Math.sqrt(r-a)),((u=i-o)>=0||l>=0)&&(s=u<0?this.at(l,n):this.at(u,n))),s}},{key:"intersectsSphere",value:function(t){return this.distanceToPoint(t.center)<=t.radius}},{key:"intersectPlane",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=this.distanceToPlane(t);return null===e?null:this.at(e,n)}},{key:"intersectsPlane",value:function(t){var n=t.distanceToPoint(this.origin);return 0===n||t.normal.dot(this.direction)*n<0}},{key:"intersectBox",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=this.origin,i=this.direction,a=t.min,r=t.max,s=1/i.x,o=1/i.y,u=1/i.z,l=null,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0;return s>=0?(c=(a.x-e.x)*s,d=(r.x-e.x)*s):(c=(r.x-e.x)*s,d=(a.x-e.x)*s),o>=0?(v=(a.y-e.y)*o,m=(r.y-e.y)*o):(v=(r.y-e.y)*o,m=(a.y-e.y)*o),c<=m&&v<=d&&((v>c||c!=c)&&(c=v),(m<d||d!=d)&&(d=m),u>=0?(y=(a.z-e.z)*u,f=(r.z-e.z)*u):(y=(r.z-e.z)*u,f=(a.z-e.z)*u),c<=f&&y<=d&&((y>c||c!=c)&&(c=y),(f<d||d!=d)&&(d=f),d>=0&&(l=this.at(c>=0?c:d,n)))),l}},{key:"intersectsBox",value:function(t){return null!==this.intersectBox(t,N[0])}},{key:"intersectTriangle",value:function(t,n,e,i,a){var r=this.direction,s=N[0],o=N[1],u=N[2],l=N[3],h=null,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0;return o.subVectors(n,t),u.subVectors(e,t),l.crossVectors(o,u),0===(c=r.dot(l))||i&&c>0||(c>0?d=1:(d=-1,c=-c),s.subVectors(this.origin,t),(v=d*r.dot(u.crossVectors(s,u)))>=0&&(m=d*r.dot(o.cross(s)))>=0&&v+m<=c&&(y=-d*s.dot(l))>=0&&(h=this.at(y/c,a))),h}},{key:"applyMatrix4",value:function(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}},{key:"equals",value:function(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}}]),e}(),X=(function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;t(this,e),this.radius=n,this.phi=i,this.theta=a}n(e,[{key:"set",value:function(t,n,e){return this.radius=t,this.phi=n,this.theta=e,this}},{key:"copy",value:function(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"setFromVector3",value:function(t){return this.radius=t.length(),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t.x,t.z),this.phi=Math.acos(Math.min(Math.max(t.y/this.radius,-1),1))),this.makeSafe()}},{key:"makeSafe",value:function(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}}])}(),function(){function e(){t(this,e),this.elements=new Float32Array([1,0,0,1,0,1])}return n(e,[{key:"set",value:function(t,n,e,i,a,r){var s=this.elements;return s[0]=t,s[1]=n,s[3]=i,s[2]=e,s[4]=a,s[5]=r,this}},{key:"identity",value:function(){return this.set(1,0,0,1,0,1),this}},{key:"copy",value:function(t){var n=t.elements;return this.set(n[0],n[1],n[2],n[3],n[4],n[5]),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"toMatrix3",value:function(t){var n=t.elements;t.set(n[0],n[1],n[2],n[1],n[3],n[4],n[2],n[4],n[5])}},{key:"add",value:function(t){var n=this.elements,e=t.elements;return n[0]+=e[0],n[1]+=e[1],n[3]+=e[3],n[2]+=e[2],n[4]+=e[4],n[5]+=e[5],this}},{key:"norm",value:function(){var t=this.elements,n=t[1]*t[1],e=t[2]*t[2],i=t[4]*t[4];return Math.sqrt(t[0]*t[0]+n+e+n+t[3]*t[3]+i+e+i+t[5]*t[5])}},{key:"off",value:function(){var t=this.elements;return Math.sqrt(2*(t[1]*t[1]+t[2]*t[2]+t[4]*t[4]))}},{key:"applyToVector3",value:function(t){var n=t.x,e=t.y,i=t.z,a=this.elements;return t.x=a[0]*n+a[1]*e+a[2]*i,t.y=a[1]*n+a[3]*e+a[4]*i,t.z=a[2]*n+a[4]*e+a[5]*i,t}},{key:"equals",value:function(t){var n=this.elements,e=t.elements,i=!0,a=void 0;for(a=0;i&&a<6;++a)n[a]!==e[a]&&(i=!1);return i}}],[{key:"calculateIndex",value:function(t,n){return 3-(3-t)*(2-t)/2+n}}]),e}()),Y=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;t(this,e),this.x=n,this.y=i,this.z=a,this.w=r}return n(e,[{key:"set",value:function(t,n,e,i){return this.x=t,this.y=n,this.z=e,this.w=i,this}},{key:"copy",value:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z,this.w)}},{key:"fromArray",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this.w=t[n+3],this}},{key:"toArray",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t[n+3]=this.w,t}},{key:"setAxisAngleFromQuaternion",value:function(t){this.w=2*Math.acos(t.w);var n=Math.sqrt(1-t.w*t.w);return n<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/n,this.y=t.y/n,this.z=t.z/n),this}},{key:"setAxisAngleFromRotationMatrix",value:function(t){var n=t.elements,e=n[0],i=n[4],a=n[8],r=n[1],s=n[5],o=n[9],u=n[2],l=n[6],h=n[10],c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,x=void 0,p=void 0,g=void 0,k=void 0,z=void 0;return Math.abs(i-r)<.01&&Math.abs(a-u)<.01&&Math.abs(o-l)<.01?Math.abs(i+r)<.1&&Math.abs(a+u)<.1&&Math.abs(o+l)<.1&&Math.abs(e+s+h-3)<.1?this.set(1,0,0,0):(c=Math.PI,x=(h+1)/2,p=(i+r)/4,g=(a+u)/4,k=(o+l)/4,(y=(e+1)/2)>(f=(s+1)/2)&&y>x?y<.01?(d=0,v=.707106781,m=.707106781):(v=p/(d=Math.sqrt(y)),m=g/d):f>x?f<.01?(d=.707106781,v=0,m=.707106781):(d=p/(v=Math.sqrt(f)),m=k/v):x<.01?(d=.707106781,v=.707106781,m=0):(d=g/(m=Math.sqrt(x)),v=k/m),this.set(d,v,m,c)):(z=Math.sqrt((l-o)*(l-o)+(a-u)*(a-u)+(r-i)*(r-i)),Math.abs(z)<.001&&(z=1),this.x=(l-o)/z,this.y=(a-u)/z,this.z=(r-i)/z,this.w=Math.acos((e+s+h-1)/2)),this}},{key:"add",value:function(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}},{key:"addScalar",value:function(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}},{key:"addVectors",value:function(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this.z=t.z+n.z,this.w=t.w+n.w,this}},{key:"addScaledVector",value:function(t,n){return this.x+=t.x*n,this.y+=t.y*n,this.z+=t.z*n,this.w+=t.w*n,this}},{key:"sub",value:function(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}},{key:"subScalar",value:function(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}},{key:"subVectors",value:function(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this.z=t.z-n.z,this.w=t.w-n.w,this}},{key:"multiply",value:function(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}},{key:"multiplyScalar",value:function(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}},{key:"multiplyVectors",value:function(t,n){return this.x=t.x*n.x,this.y=t.y*n.y,this.z=t.z*n.z,this.w=t.w*n.w,this}},{key:"divide",value:function(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}},{key:"divideScalar",value:function(t){return this.x/=t,this.y/=t,this.z/=t,this.w/=t,this}},{key:"applyMatrix4",value:function(t){var n=this.x,e=this.y,i=this.z,a=this.w,r=t.elements;return this.x=r[0]*n+r[4]*e+r[8]*i+r[12]*a,this.y=r[1]*n+r[5]*e+r[9]*i+r[13]*a,this.z=r[2]*n+r[6]*e+r[10]*i+r[14]*a,this.w=r[3]*n+r[7]*e+r[11]*i+r[15]*a,this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}},{key:"dot",value:function(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}},{key:"lengthSquared",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}},{key:"manhattanDistanceTo",value:function(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)+Math.abs(this.w-t.w)}},{key:"distanceToSquared",value:function(t){var n=this.x-t.x,e=this.y-t.y,i=this.z-t.z,a=this.w-t.w;return n*n+e*e+i*i+a*a}},{key:"distanceTo",value:function(t){return Math.sqrt(this.distanceToSquared(t))}},{key:"normalize",value:function(){return this.divideScalar(this.length())}},{key:"setLength",value:function(t){return this.normalize().multiplyScalar(t)}},{key:"min",value:function(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}},{key:"max",value:function(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}},{key:"clamp",value:function(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this.z=Math.max(t.z,Math.min(n.z,this.z)),this.w=Math.max(t.w,Math.min(n.w,this.w)),this}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}},{key:"lerp",value:function(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this.z+=(t.z-this.z)*n,this.w+=(t.w-this.w)*n,this}},{key:"lerpVectors",value:function(t,n,e){return this.subVectors(n,t).multiplyScalar(e).add(t)}},{key:"equals",value:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}}]),e}(),H={AIR:0,SOLID:1},Z=function(){function e(n){t(this,e),this.type=n;for(var i=arguments.length,a=Array(i>1?i-1:0),r=1;r<i;r++)a[r-1]=arguments[r];this.children=a,this.boundingBox=null}return n(e,[{key:"getBoundingBox",value:function(){return null===this.boundingBox&&(this.boundingBox=this.computeBoundingBox()),this.boundingBox}},{key:"computeBoundingBox",value:function(){var t=this.children,n=new v,e=void 0,i=void 0;for(e=0,i=t.length;e<i;++e)n.union(t[e].getBoundingBox());return n}}]),e}(),Q=function(e){i(r,Z);function r(){var n;t(this,r);for(var e=arguments.length,i=Array(e),s=0;s<e;s++)i[s]=arguments[s];return a(this,(n=r.__proto__||Object.getPrototypeOf(r)).call.apply(n,[this,l.UNION].concat(i)))}return n(r,[{key:"updateMaterialIndex",value:function(t,n,e){var i=e.materialIndices[t];i!==H.AIR&&n.setMaterialIndex(t,i)}},{key:"selectEdge",value:function(t,n,e){return e?t.t>n.t?t:n:t.t<n.t?t:n}}]),r}(),G=function(e){i(r,Z);function r(){var n;t(this,r);for(var e=arguments.length,i=Array(e),s=0;s<e;s++)i[s]=arguments[s];return a(this,(n=r.__proto__||Object.getPrototypeOf(r)).call.apply(n,[this,l.DIFFERENCE].concat(i)))}return n(r,[{key:"updateMaterialIndex",value:function(t,n,e){e.materialIndices[t]!==H.AIR&&n.setMaterialIndex(t,H.AIR)}},{key:"selectEdge",value:function(t,n,e){return e?t.t<n.t?t:n:t.t>n.t?t:n}}]),r}(),K=function(e){i(r,Z);function r(){var n;t(this,r);for(var e=arguments.length,i=Array(e),s=0;s<e;s++)i[s]=arguments[s];return a(this,(n=r.__proto__||Object.getPrototypeOf(r)).call.apply(n,[this,l.INTERSECTION].concat(i)))}return n(r,[{key:"updateMaterialIndex",value:function(t,n,e){var i=e.materialIndices[t];n.setMaterialIndex(t,n.materialIndices[t]!==H.AIR&&i!==H.AIR?i:H.AIR)}},{key:"selectEdge",value:function(t,n,e){return e?t.t<n.t?t:n:t.t>n.t?t:n}}]),r}(),W=function(e){i(r,Z);function r(n){t(this,r);var e=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,l.DENSITY_FUNCTION));return e.sdf=n,e}return n(r,[{key:"computeBoundingBox",value:function(){return this.sdf.getBoundingBox(!0)}},{key:"generateMaterialIndex",value:function(t){return this.sdf.sample(t)<=0?this.sdf.material:H.AIR}},{key:"generateEdge",value:function(t){t.approximateZeroCrossing(this.sdf),t.computeSurfaceNormal(this.sdf)}}]),r}(),J=new $,tt=function(){function e(n){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.SOLID;t(this,e),this.type=n,this.operation=null,this.material=Math.min(255,Math.max(H.SOLID,Math.trunc(i))),this.boundingBox=null,this.position=new h,this.quaternion=new C,this.scale=new h(1,1,1),this.inverseTransformation=new $,this.updateInverseTransformation(),this.children=[]}return n(e,[{key:"getTransformation",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new $).compose(this.position,this.quaternion,this.scale)}},{key:"getBoundingBox",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=this.children,e=this.boundingBox,i=void 0,a=void 0;if(null===e&&(e=this.computeBoundingBox(),this.boundingBox=e),t)for(e=e.clone(),i=0,a=n.length;i<a;++i)e.union(n[i].getBoundingBox(t));return e}},{key:"setMaterial",value:function(t){return this.material=Math.min(255,Math.max(H.SOLID,Math.trunc(t))),this}},{key:"setOperationType",value:function(t){return this.operation=t,this}},{key:"updateInverseTransformation",value:function(){return this.inverseTransformation.getInverse(this.getTransformation(J)),this.boundingBox=null,this}},{key:"union",value:function(t){return this.children.push(t.setOperationType(l.UNION)),this}},{key:"subtract",value:function(t){return this.children.push(t.setOperationType(l.DIFFERENCE)),this}},{key:"intersect",value:function(t){return this.children.push(t.setOperationType(l.INTERSECTION)),this}},{key:"toCSG",value:function(){var t=this.children,n=new W(this),e=void 0,i=void 0,a=void 0,r=void 0;for(a=0,r=t.length;a<r;++a){if(e!==(i=t[a]).operation)switch(e=i.operation){case l.UNION:n=new Q(n);break;case l.DIFFERENCE:n=new G(n);break;case l.INTERSECTION:n=new K(n)}n.children.push(i.toCSG())}return n}},{key:"serialize",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n={type:this.type,operation:this.operation,material:this.material,position:this.position.toArray(),quaternion:this.quaternion.toArray(),scale:this.scale.toArray(),parameters:null,children:[]},e=void 0,i=void 0;for(e=0,i=this.children.length;e<i;++e)n.children.push(this.children[e].serialize(t));return n}},{key:"createTransferList",value:function(){return arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]}},{key:"toJSON",value:function(){return this.serialize(!0)}},{key:"computeBoundingBox",value:function(){throw new Error("SignedDistanceFunction#computeBoundingBox method not implemented!")}},{key:"sample",value:function(t){throw new Error("SignedDistanceFunction#sample method not implemented!")}}]),e}(),nt={HEIGHTFIELD:"sdf.heightfield",FRACTAL_NOISE:"sdf.fractalnoise",SUPER_PRIMITIVE:"sdf.superprimitive"},et=function(s){i(o,tt);function o(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1];t(this,o);var i=a(this,(o.__proto__||Object.getPrototypeOf(o)).call(this,nt.PERLIN_NOISE,e));return i.min=new(Function.prototype.bind.apply(h,[null].concat(r(n.min)))),i.max=new(Function.prototype.bind.apply(h,[null].concat(r(n.max)))),i}return n(o,[{key:"computeBoundingBox",value:function(){return this.bbox=new v(this.min,this.max),this.bbox}},{key:"sample",value:function(t){}},{key:"serialize",value:function(){var t=e(o.prototype.__proto__||Object.getPrototypeOf(o.prototype),"serialize",this).call(this);return t.parameters={min:this.min.toArray(),max:this.max.toArray()},t}}]),o}();var it=function(r){i(s,tt);function s(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1];t(this,s);var i=a(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,nt.HEIGHTFIELD,e));return i.width=void 0!==n.width?n.width:1,i.height=void 0!==n.height?n.height:1,i.data=void 0!==n.data?n.data:null,i.heightmap=null,void 0!==n.image&&i.fromImage(n.image),i}return n(s,[{key:"fromImage",value:function(t){var n="undefined"==typeof document?null:function(t){var n=document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),e=n.getContext("2d");return n.width=t.width,n.height=t.height,e.drawImage(t,0,0),e.getImageData(0,0,t.width,t.height)}(t),e=null,i=void 0,a=void 0,r=void 0,s=void 0;if(null!==n){for(i=n.data,a=0,r=0,s=(e=new Uint8ClampedArray(i.length/4)).length;a<s;++a,r+=4)e[a]=i[r];this.heightmap=t,this.width=n.width,this.height=n.height,this.data=e}return this}},{key:"computeBoundingBox",value:function(){var t=new v,n=Math.min(this.width/this.height,1),e=Math.min(this.height/this.width,1);return t.min.set(0,0,0),t.max.set(n,1,e),t.applyMatrix4(this.getTransformation()),t}},{key:"sample",value:function(t){var n=this.boundingBox,e=void 0;if(n.containsPoint(t)){t.applyMatrix4(this.inverseTransformation);var i=this.width,a=this.height,r=Math.max(Math.min(Math.trunc(t.x*i),i),0),s=Math.max(Math.min(Math.trunc(t.z*a),a),0),o=this.data[s*i+r]/255;e=t.y-o}else e=n.distanceToPoint(t);return e}},{key:"serialize",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),"serialize",this).call(this);return n.parameters={width:this.width,height:this.height,data:t?null:this.data,dataUrl:t&&null!==this.heightmap?this.heightmap.toDataUrl():null,image:null},n}},{key:"createTransferList",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return t.push(this.data.buffer),t}}]),s}(),at=function(s){i(o,tt);function o(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1];t(this,o);var i=a(this,(o.__proto__||Object.getPrototypeOf(o)).call(this,nt.SUPER_PRIMITIVE,e));return i.s0=new(Function.prototype.bind.apply(Y,[null].concat(r(n.s)))),i.r0=new(Function.prototype.bind.apply(h,[null].concat(r(n.r)))),i.s=new Y,i.r=new h,i.ba=new f,i.offset=0,i.precompute(),i}return n(o,[{key:"setSize",value:function(t,n,e,i){return this.s0.set(t,n,e,i),this.precompute()}},{key:"setRadii",value:function(t,n,e){return this.r0.set(t,n,e),this.precompute()}},{key:"precompute",value:function(){var t=this.s.copy(this.s0),n=this.r.copy(this.r0),e=this.ba;t.x-=n.x,t.y-=n.x,n.x-=t.w,t.w-=n.y,t.z-=n.y,this.offset=-2*t.z,e.set(n.z,this.offset);var i=e.dot(e);return 0===i?e.set(0,-1):e.divideScalar(i),this}},{key:"computeBoundingBox",value:function(){var t=this.s0,n=new v;return n.min.x=Math.min(-t.x,-1),n.min.y=Math.min(-t.y,-1),n.min.z=Math.min(-t.z,-1),n.max.x=Math.max(t.x,1),n.max.y=Math.max(t.y,1),n.max.z=Math.max(t.z,1),n.applyMatrix4(this.getTransformation()),n}},{key:"sample",value:function(t){t.applyMatrix4(this.inverseTransformation);var n=this.s,e=this.r,i=this.ba,a=Math.abs(t.x)-n.x,r=Math.abs(t.y)-n.y,s=Math.abs(t.z)-n.z,o=Math.max(a,0),u=Math.max(r,0),l=Math.sqrt(o*o+u*u),h=t.z-n.z,c=Math.abs(l+Math.min(0,Math.max(a,r))-e.x)-n.w,d=Math.min(Math.max(c*i.x+h*i.y,0),1),v=c-e.z*d,m=h-this.offset*d,y=Math.max(c-e.z,0),f=t.z+n.z,x=Math.max(c,0),p=v*v+m*m,g=y*y+f*f,k=x*x+h*h,z=c*-i.y+h*i.x;return Math.sqrt(Math.min(p,Math.min(g,k)))*Math.sign(Math.max(z,s))-e.y}},{key:"serialize",value:function(){var t=e(o.prototype.__proto__||Object.getPrototypeOf(o.prototype),"serialize",this).call(this);return t.parameters={s:this.s0.toArray(),r:this.r0.toArray()},t}}],[{key:"create",value:function(t){var n=rt[t];return new o({s:n[0],r:n[1]})}}]),o}(),rt=[[new Float32Array([1,1,1,1]),new Float32Array([0,0,0])],[new Float32Array([1,1,1,1]),new Float32Array([1,0,0])],[new Float32Array([0,0,1,1]),new Float32Array([0,0,1])],[new Float32Array([1,1,2,1]),new Float32Array([1,1,0])],[new Float32Array([1,1,1,1]),new Float32Array([1,1,0])],[new Float32Array([1,1,.25,1]),new Float32Array([1,.25,0])],[new Float32Array([1,1,.25,.25]),new Float32Array([1,.25,0])],[new Float32Array([1,1,1,.25]),new Float32Array([1,.1,0])],[new Float32Array([1,1,1,.25]),new Float32Array([.1,.1,0])]],st=5,ot=7,ut=function(){function e(){t(this,e)}return n(e,[{key:"revive",value:function(t){var n=void 0,e=void 0,i=void 0;switch(t.type){case nt.FRACTAL_NOISE:n=new et(t.parameters,t.material);break;case nt.HEIGHTFIELD:n=new it(t.parameters,t.material);break;case nt.SUPER_PRIMITIVE:n=new at(t.parameters,t.material)}for(n.operation=t.operation,n.position.fromArray(t.position),n.quaternion.fromArray(t.quaternion),n.scale.fromArray(t.scale),n.updateInverseTransformation(),e=0,i=t.children.length;e<i;++e)n.children.push(this.revive(t.children[e]));return n}}]),e}(),lt=new(function(n){i(e,o);function e(n){t(this,e);var i=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n));return i.descriptions=null,i}return e}())("load"),ht=function(e){i(r,u);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));return n.items=0,n.descriptions=null,n.imageMap=new WeakMap,n}return n(r,[{key:"clear",value:function(){this.imageMap=new WeakMap}},{key:"handleEvent",value:function(t){switch(t.type){case"load":this.progress(t)}}},{key:"progress",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,n=null!==t?t.target:null,e=this.imageMap;null!==n&&(e.has(n)&&(e.get(n).image=n),--this.items),0===this.items&&(this.clear(),lt.descriptions=this.descriptions,this.dispatchEvent(lt))}},{key:"loadImage",value:function(t){var n=new Image;this.imageMap.set(n,t),++this.items,n.addEventListener("load",this),n.src=t.dataUrl}},{key:"inflate",value:function(t){var n=void 0;null!==t.dataUrl&&this.loadImage(t);var e=!0,i=!1,a=void 0;try{for(var r,s=t.children[Symbol.iterator]();!(e=(r=s.next()).done);e=!0)n=r.value,this.inflate(n)}catch(t){i=!0,a=t}finally{try{!e&&s.return&&s.return()}finally{if(i)throw a}}this.progress()}},{key:"load",value:function(t){var n=void 0;this.items=0,this.descriptions=t;var e=!0,i=!1,a=void 0;try{for(var r,s=t[Symbol.iterator]();!(e=(r=s.next()).done);e=!0)n=r.value,this.inflate(n)}catch(t){i=!0,a=t}finally{try{!e&&s.return&&s.return()}finally{if(i)throw a}}}}]),r}(),ct=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t(this,e),this.runLengths=n,this.data=i}return n(e,null,[{key:"encode",value:function(t){var n=[],i=[],a=t[0],r=1,s=void 0,o=void 0;for(s=1,o=t.length;s<o;++s)a!==t[s]?(n.push(r),i.push(a),a=t[s],r=1):++r;return n.push(r),i.push(a),new e(n,i)}},{key:"decode",value:function(t,n){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],i=void 0,a=void 0,r=void 0,s=void 0,o=void 0,u=0;for(a=0,s=n.length;a<s;++a)for(i=n[a],r=0,o=t[a];r<o;++r)e[u++]=i;return e}}]),e}(),dt=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t(this,e),this.value=n,this.done=i}return n(e,[{key:"reset",value:function(){this.value=null,this.done=!1}}]),e}(),vt=new h,mt=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h;t(this,e),this.min=n,this.max=i,this.children=null}return n(e,[{key:"getCenter",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getDimensions",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).subVectors(this.max,this.min)}},{key:"split",value:function(){var t=this.min,n=this.max,e=this.getCenter(vt),i=this.children=[null,null,null,null,null,null,null,null],a=void 0,r=void 0;for(a=0;a<8;++a)r=yt[a],i[a]=new this.constructor(new h(0===r[0]?t.x:e.x,0===r[1]?t.y:e.y,0===r[2]?t.z:e.z),new h(0===r[0]?e.x:n.x,0===r[1]?e.y:n.y,0===r[2]?e.z:n.z))}}]),e}(),yt=[new Uint8Array([0,0,0]),new Uint8Array([0,0,1]),new Uint8Array([0,1,0]),new Uint8Array([0,1,1]),new Uint8Array([1,0,0]),new Uint8Array([1,0,1]),new Uint8Array([1,1,0]),new Uint8Array([1,1,1])],ft=[new Uint8Array([0,4]),new Uint8Array([1,5]),new Uint8Array([2,6]),new Uint8Array([3,7]),new Uint8Array([0,2]),new Uint8Array([1,3]),new Uint8Array([4,6]),new Uint8Array([5,7]),new Uint8Array([0,1]),new Uint8Array([2,3]),new Uint8Array([4,5]),new Uint8Array([6,7])],xt=new h,pt=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t(this,e),this.min=n,this.size=i,this.children=null}return n(e,[{key:"getCenter",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).copy(this.min).addScalar(.5*this.size)}},{key:"getDimensions",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).set(this.size,this.size,this.size)}},{key:"split",value:function(){var t=this.min,n=this.getCenter(xt),e=.5*this.size,i=this.children=[null,null,null,null,null,null,null,null],a=void 0,r=void 0;for(a=0;a<8;++a)r=yt[a],i[a]=new this.constructor(new h(0===r[0]?t.x:n.x,0===r[1]?t.y:n.y,0===r[2]?t.z:n.z),e)}},{key:"max",get:function(){return this.min.clone().addScalar(this.size)}}]),e}(),gt=new v,kt=function(){function e(n){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t(this,e),this.octree=n,this.region=i,this.cull=null!==i,this.result=new dt,this.trace=null,this.indices=null,this.reset()}return n(e,[{key:"reset",value:function(){var t=this.octree.root;return this.trace=[],this.indices=[],null!==t&&(gt.min=t.min,gt.max=t.max,this.cull&&!this.region.intersectsBox(gt)||(this.trace.push(t),this.indices.push(0))),this.result.reset(),this}},{key:"next",value:function(){for(var t=this.cull,n=this.region,e=this.indices,i=this.trace,a=null,r=i.length-1,s=void 0,o=void 0,u=void 0;null===a&&r>=0;)if(s=e[r],o=i[r].children,++e[r],s<8)if(null!==o){if(u=o[s],t&&(gt.min=u.min,gt.max=u.max,!n.intersectsBox(gt)))continue;i.push(u),e.push(0),++r}else a=i.pop(),e.pop();else i.pop(),e.pop(),--r;return this.result.value=a,this.result.done=null===a,this.result}},{key:"return",value:function(t){return this.result.value=t,this.result.done=!0,this.result}},{key:Symbol.iterator,value:function(){return this}}]),e}(),zt=[new h,new h,new h],wt=new v,bt=new j,Mt=[new Uint8Array([4,2,1]),new Uint8Array([5,3,8]),new Uint8Array([6,8,3]),new Uint8Array([7,8,8]),new Uint8Array([8,6,5]),new Uint8Array([8,7,8]),new Uint8Array([8,8,7]),new Uint8Array([8,8,8])],St=0;function Ct(t,n,e,i){var a=void 0,r=0;return n<e?(a=n,r=0):(a=e,r=1),i<a&&(r=2),Mt[t][r]}var Ot=function(){function e(){t(this,e)}return n(e,null,[{key:"intersectOctree",value:function(t,n,e){var i=wt.min.set(0,0,0),a=wt.max.subVectors(t.max,t.min),r=t.getDimensions(zt[0]),s=zt[1].copy(r).multiplyScalar(.5),o=bt.origin.copy(n.ray.origin),u=bt.direction.copy(n.ray.direction),l=void 0,h=void 0,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,x=void 0;o.sub(t.getCenter(zt[2])).add(s),St=0,u.x<0&&(o.x=r.x-o.x,u.x=-u.x,St|=4),u.y<0&&(o.y=r.y-o.y,u.y=-u.y,St|=2),u.z<0&&(o.z=r.z-o.z,u.z=-u.z,St|=1),l=1/u.x,h=1/u.y,c=1/u.z,d=(i.x-o.x)*l,v=(a.x-o.x)*l,m=(i.y-o.y)*h,y=(a.y-o.y)*h,f=(i.z-o.z)*c,x=(a.z-o.z)*c,Math.max(Math.max(d,m),f)<Math.min(Math.min(v,y),x)&&function t(n,e,i,a,r,s,o,u,l){var h=n.children,c=void 0,d=void 0,v=void 0,m=void 0;if(r>=0&&s>=0&&o>=0)if(null===h)l.push(n);else{c=function(t,n,e,i,a,r){var s=0;return t>n&&t>e?(a<t&&(s|=2),r<t&&(s|=1)):n>e?(i<n&&(s|=4),r<n&&(s|=1)):(i<e&&(s|=4),a<e&&(s|=2)),s}(e,i,a,d=.5*(e+r),v=.5*(i+s),m=.5*(a+o));do{switch(c){case 0:t(h[St],e,i,a,d,v,m,u,l),c=Ct(c,d,v,m);break;case 1:t(h[1^St],e,i,m,d,v,o,u,l),c=Ct(c,d,v,o);break;case 2:t(h[2^St],e,v,a,d,s,m,u,l),c=Ct(c,d,s,m);break;case 3:t(h[3^St],e,v,m,d,s,o,u,l),c=Ct(c,d,s,o);break;case 4:t(h[4^St],d,i,a,r,v,m,u,l),c=Ct(c,r,v,m);break;case 5:t(h[5^St],d,i,m,r,v,o,u,l),c=Ct(c,r,v,o);break;case 6:t(h[6^St],d,v,a,r,s,m,u,l),c=Ct(c,r,s,m);break;case 7:t(h[7^St],d,v,m,r,s,o,u,l),c=8}}while(c<8)}}(t.root,d,m,f,v,y,x,n,e)}}]),e}(),Dt=new v;var Pt=function(){function e(n,i){t(this,e),this.root=void 0!==n&&void 0!==i?new mt(n,i):null}return n(e,[{key:"getCenter",value:function(t){return this.root.getCenter(t)}},{key:"getDimensions",value:function(t){return this.root.getDimensions(t)}},{key:"getDepth",value:function(){return function t(n){var e=n.children,i=0,a=void 0,r=void 0,s=void 0;if(null!==e)for(a=0,r=e.length;a<r;++a)(s=1+t(e[a]))>i&&(i=s);return i}(this.root)}},{key:"cull",value:function(t){var n=[];return function t(n,e,i){var a=n.children,r=void 0,s=void 0;if(Dt.min=n.min,Dt.max=n.max,e.intersectsBox(Dt))if(null!==a)for(r=0,s=a.length;r<s;++r)t(a[r],e,i);else i.push(n)}(this.root,t,n),n}},{key:"findOctantsByLevel",value:function(t){var n=[];return function t(n,e,i,a){var r=n.children,s=void 0,o=void 0;if(i===e)a.push(n);else if(null!==r)for(++i,s=0,o=r.length;s<o;++s)t(r[s],e,i,a)}(this.root,t,0,n),n}},{key:"raycast",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Ot.intersectOctree(this,t,n),n}},{key:"leaves",value:function(t){return new kt(this,t)}},{key:Symbol.iterator,value:function(){return new kt(this)}},{key:"min",get:function(){return this.root.min}},{key:"max",get:function(){return this.root.max}},{key:"children",get:function(){return this.root.children}}]),e}(),At=new h,_t=function(e){i(s,mt);function s(n,e){t(this,s);var i=a(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,n,e));return i.points=null,i.data=null,i}return n(s,[{key:"distanceToSquared",value:function(t){return At.copy(t).clamp(this.min,this.max).sub(t).lengthSquared()}},{key:"distanceToCenterSquared",value:function(t){var n=this.getCenter(At),e=t.x-n.x,i=t.y-n.x,a=t.z-n.z;return e*e+i*i+a*a}},{key:"contains",value:function(t,n){var e=this.min,i=this.max;return t.x>=e.x-n&&t.y>=e.y-n&&t.z>=e.z-n&&t.x<=i.x+n&&t.y<=i.y+n&&t.z<=i.z+n}},{key:"redistribute",value:function(t){var n=this.children,e=this.points,i=this.data,a=void 0,r=void 0,s=void 0,o=void 0,u=void 0,l=void 0,h=void 0;if(null!==n)for(a=0,s=e.length;a<s;++a)for(l=e[a],h=i[a],r=0,o=n.length;r<o;++r)if((u=n[r]).contains(l,t)){null===u.points&&(u.points=[],u.data=[]),u.points.push(l),u.data.push(h);break}this.points=null,this.data=null}},{key:"merge",value:function(){var t=this.children,n=void 0,e=void 0,i=void 0;if(null!==t){for(this.points=[],this.data=[],n=0,e=t.length;n<e;++n)if(null!==(i=t[n]).points){var a,s;(a=this.points).push.apply(a,r(i.points)),(s=this.data).push.apply(s,r(i.data))}this.children=null}}}]),s}(),Tt=function n(e,i,a){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;t(this,n),this.distance=e,this.distanceToRay=i,this.point=a,this.object=r},It=1e-6;function qt(t){var n=t.children,e=0,i=void 0,a=void 0;if(null!==n)for(i=0,a=n.length;i<a;++i)e+=qt(n[i]);else null!==t.points&&(e=t.points.length);return e}function Et(t,n,e,i,a){var r=i.children,s=!1,o=!1,u=void 0,l=void 0;if(i.contains(t,e.bias)){if(null===r){if(null===i.points)i.points=[],i.data=[];else for(u=0,l=i.points.length;!s&&u<l;++u)s=i.points[u].equals(t);s?(i.data[u-1]=n,o=!0):i.points.length<e.maxPoints||a===e.maxDepth?(i.points.push(t.clone()),i.data.push(n),++e.pointCount,o=!0):(i.split(),i.redistribute(e.bias),r=i.children)}if(null!==r)for(++a,u=0,l=r.length;!o&&u<l;++u)o=Et(t,n,e,r[u],a)}return o}function Vt(t,n,e,i){var a=e.children,r=null,s=void 0,o=void 0,u=void 0,l=void 0,h=void 0;if(e.contains(t,n.bias))if(null!==a)for(s=0,o=a.length;null===r&&s<o;++s)r=Vt(t,n,a[s],e);else if(null!==e.points)for(u=e.points,l=e.data,s=0,o=u.length;s<o;++s)if(u[s].equals(t)){h=o-1,r=l[s],s<h&&(u[s]=u[h],l[s]=l[h]),u.pop(),l.pop(),--n.pointCount,null!==i&&qt(i)<=n.maxPoints&&i.merge();break}return r}!function(r){i(s,Pt);function s(n,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:8;t(this,s);var u=a(this,(s.__proto__||Object.getPrototypeOf(s)).call(this));return u.root=new _t(n,e),u.bias=Math.max(0,i),u.maxPoints=Math.max(1,Math.round(r)),u.maxDepth=Math.max(0,Math.round(o)),u.pointCount=0,u}n(s,[{key:"countPoints",value:function(t){return qt(t)}},{key:"put",value:function(t,n){return Et(t,n,this,this.root,0)}},{key:"remove",value:function(t){return Vt(t,this,this.root,null)}},{key:"fetch",value:function(t){return function t(n,e,i){var a=i.children,r=null,s=void 0,o=void 0,u=void 0;if(i.contains(n,e.bias))if(null!==a)for(s=0,o=a.length;null===r&&s<o;++s)r=t(n,e,a[s]);else for(s=0,o=(u=i.points).length;null===r&&s<o;++s)n.distanceToSquared(u[s])<=It&&(r=i.data[s]);return r}(t,this,this.root)}},{key:"move",value:function(t,n){return function t(n,e,i,a,r,s){var o=a.children,u=null,l=void 0,h=void 0,c=void 0;if(a.contains(n,i.bias))if(a.contains(e,i.bias)){if(null!==o)for(++s,l=0,h=o.length;null===u&&l<h;++l)u=t(n,e,i,o[l],a,s);else for(l=0,h=(c=a.points).length;l<h;++l)if(n.distanceToSquared(c[l])<=It){c[l].copy(e),u=a.data[l];break}}else Et(e,u=Vt(n,i,a,r),i,r,s-1);return u}(t,n,this,this.root,null,0)}},{key:"findNearestPoint",value:function(t){return function t(n,e,i,a){var r=a.points,s=a.children,o=null,u=e,l=void 0,h=void 0,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0;if(null!==s)for(l=0,h=(v=s.map(function(t){return{octant:t,distance:t.distanceToCenterSquared(n)}}).sort(function(t,n){return t.distance-n.distance})).length;l<h;++l)(m=v[l].octant).contains(n,u)&&null!==(y=t(n,u,i,m))&&(d=y.point.distanceToSquared(n),(!i||d>0)&&d<u&&(u=d,o=y));else if(null!==r)for(l=0,h=r.length;l<h;++l)c=r[l],d=n.distanceToSquared(c),(!i||d>0)&&d<u&&(u=d,o={point:c.clone(),data:a.data[l]});return o}(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1/0,arguments.length>2&&void 0!==arguments[2]&&arguments[2],this.root)}},{key:"findPoints",value:function(t,n){var e=[];return function t(n,e,i,a,r){var s=a.points,o=a.children,u=e*e,l=void 0,h=void 0,c=void 0,d=void 0,v=void 0;if(null!==o)for(l=0,h=o.length;l<h;++l)(v=o[l]).contains(n,e)&&t(n,e,i,v,r);else if(null!==s)for(l=0,h=s.length;l<h;++l)c=s[l],d=n.distanceToSquared(c),(!i||d>0)&&d<=u&&r.push({point:c.clone(),data:a.data[l]})}(t,n,arguments.length>2&&void 0!==arguments[2]&&arguments[2],this.root,e),e}},{key:"raycast",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],i=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),"raycast",this).call(this,t);return i.length>0&&this.testPoints(i,t,n),n}},{key:"testPoints",value:function(t,n,e){var i=n.params.Points.threshold,a=i*i,r=void 0,s=void 0,o=void 0,u=void 0,l=void 0,h=void 0,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0;for(l=0,c=t.length;l<c;++l)if(null!==(m=(v=t[l]).points))for(h=0,d=m.length;h<d;++h)y=m[h],(u=n.ray.distanceSqToPoint(y))<a&&(r=n.ray.closestPointToPoint(y),(s=n.ray.origin.distanceTo(r))>=n.near&&s<=n.far&&(o=Math.sqrt(u),e.push(new Tt(s,o,r,v.data[h]))))}}])}();var Ft=new v,Bt=new h,Rt=new h,Ut=new h,Lt=(function(){function e(){t(this,e)}n(e,null,[{key:"recycleOctants",value:function(t,n){var e=t.min,i=t.getCenter(Rt),a=t.getDimensions(Ut).multiplyScalar(.5),r=t.children,s=n.length,o=void 0,u=void 0,l=void 0,h=void 0;for(o=0;o<8;++o)for(l=yt[o],Ft.min.addVectors(e,Bt.fromArray(l).multiply(a)),Ft.max.addVectors(i,Bt.fromArray(l).multiply(a)),u=0;u<s;++u)if(null!==(h=n[u])&&Ft.min.equals(h.min)&&Ft.max.equals(h.max)){r[o]=h,n[u]=null;break}}}])}(),new h),$t=new h,Nt=new h,jt=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h;t(this,e),this.a=n,this.b=i,this.index=-1,this.coordinates=new h,this.t=0,this.n=new h}return n(e,[{key:"approximateZeroCrossing",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:8,e=Math.max(1,n-1),i=0,a=1,r=0,s=0,o=void 0,u=void 0;for(Lt.subVectors(this.b,this.a);s<=e&&(r=(i+a)/2,$t.addVectors(this.a,Nt.copy(Lt).multiplyScalar(r)),u=t.sample($t),!(Math.abs(u)<=1e-4||(a-i)/2<=1e-6));)$t.addVectors(this.a,Nt.copy(Lt).multiplyScalar(i)),o=t.sample($t),Math.sign(u)===Math.sign(o)?i=r:a=r,++s;this.t=r}},{key:"computeZeroCrossingPosition",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).subVectors(this.b,this.a).multiplyScalar(this.t).add(this.a)}},{key:"computeSurfaceNormal",value:function(t){var n=this.computeZeroCrossingPosition(Lt),e=t.sample($t.addVectors(n,Nt.set(.001,0,0)))-t.sample($t.subVectors(n,Nt.set(.001,0,0))),i=t.sample($t.addVectors(n,Nt.set(0,.001,0)))-t.sample($t.subVectors(n,Nt.set(0,.001,0))),a=t.sample($t.addVectors(n,Nt.set(0,0,.001)))-t.sample($t.subVectors(n,Nt.set(0,0,.001)));this.n.set(e,i,a).normalize()}}]),e}(),Xt=new jt,Yt=new h,Ht=new h,Zt=function(){function e(n,i,a){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:3;t(this,e),this.edgeData=n,this.cellPosition=i,this.cellSize=a,this.indices=null,this.zeroCrossings=null,this.normals=null,this.axes=null,this.lengths=null,this.result=new dt,this.initialC=r,this.c=r,this.initialD=s,this.d=s,this.i=0,this.l=0,this.reset()}return n(e,[{key:"reset",value:function(){var t=this.edgeData,n=[],e=[],i=[],a=[],r=[],s=void 0,o=void 0,u=void 0,l=void 0;for(this.i=0,this.c=0,this.d=0,s=4>>(o=this.initialC),u=this.initialD;o<u;++o,s>>=1)(l=t.indices[o].length)>0&&(n.push(t.indices[o]),e.push(t.zeroCrossings[o]),i.push(t.normals[o]),a.push(yt[s]),r.push(l),++this.d);return this.l=r.length>0?r[0]:0,this.indices=n,this.zeroCrossings=e,this.normals=i,this.axes=a,this.lengths=r,this.result.reset(),this}},{key:"next",value:function(){var t=this.cellSize,n=Wt.resolution,e=n+1,i=e*e,a=this.result,r=this.cellPosition,s=void 0,o=void 0,u=void 0,l=void 0,h=void 0,c=void 0,d=void 0;return this.i===this.l&&(this.l=++this.c<this.d?this.lengths[this.c]:0,this.i=0),this.i<this.l?(c=this.c,d=this.i,s=this.axes[c],o=this.indices[c][d],Xt.index=o,u=o%e,l=Math.trunc(o%i/e),h=Math.trunc(o/i),Xt.coordinates.set(u,l,h),Yt.set(u*t/n,l*t/n,h*t/n),Ht.set((u+s[0])*t/n,(l+s[1])*t/n,(h+s[2])*t/n),Xt.a.addVectors(r,Yt),Xt.b.addVectors(r,Ht),Xt.t=this.zeroCrossings[c][d],Xt.n.fromArray(this.normals[c],3*d),a.value=Xt,++this.i):(a.value=null,a.done=!0),a}},{key:"return",value:function(t){return this.result.value=t,this.result.done=!0,this.result}},{key:Symbol.iterator,value:function(){return this}}]),e}(),Qt=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:n;t(this,e),this.indices=n<=0?null:[new Uint32Array(n),new Uint32Array(i),new Uint32Array(a)],this.zeroCrossings=n<=0?null:[new Float32Array(n),new Float32Array(i),new Float32Array(a)],this.normals=n<=0?null:[new Float32Array(3*n),new Float32Array(3*i),new Float32Array(3*a)]}return n(e,[{key:"serialize",value:function(){return{edges:this.edges,zeroCrossings:this.zeroCrossings,normals:this.normals}}},{key:"deserialize",value:function(t){var n=this;return null!==t?(this.edges=t.edges,this.zeroCrossings=t.zeroCrossings,this.normals=t.normals):n=null,n}},{key:"createTransferList",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=[this.edges[0],this.edges[1],this.edges[2],this.zeroCrossings[0],this.zeroCrossings[1],this.zeroCrossings[2],this.normals[0],this.normals[1],this.normals[2]],e=void 0,i=void 0,a=void 0;for(i=0,a=n.length;i<a;++i)null!==(e=n[i])&&t.push(e.buffer);return t}},{key:"edges",value:function(t,n){return new Zt(this,t,n)}},{key:"edgesX",value:function(t,n){return new Zt(this,t,n,0,1)}},{key:"edgesY",value:function(t,n){return new Zt(this,t,n,1,2)}},{key:"edgesZ",value:function(t,n){return new Zt(this,t,n,2,3)}}],[{key:"calculate1DEdgeCount",value:function(t){return Math.pow(t+1,2)*t}}]),e}(),Gt=0,Kt=0;var Wt=function(){function e(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];t(this,e),this.materials=0,this.materialIndices=n?new Uint8Array(Kt):null,this.runLengths=null,this.edgeData=null}return n(e,[{key:"set",value:function(t){return this.materials=t.materials,this.materialIndices=t.materialIndices,this.runLengths=t.runLengths,this.edgeData=t.edgeData,this}},{key:"clear",value:function(){return this.materials=0,this.materialIndices=null,this.runLengths=null,this.edgeData=null,this}},{key:"setMaterialIndex",value:function(t,n){this.materialIndices[t]===H.AIR?n!==H.AIR&&++this.materials:n===H.AIR&&--this.materials,this.materialIndices[t]=n}},{key:"compress",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this,n=void 0;return this.compressed?(t.materialIndices=this.materialIndices,t.runLengths=this.runLengths):(n=this.full?new ct([this.materialIndices.length],[H.SOLID]):ct.encode(this.materialIndices),t.materialIndices=new Uint8Array(n.data),t.runLengths=new Uint32Array(n.runLengths)),t.materials=this.materials,t}},{key:"decompress",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this;return t.materialIndices=this.compressed?ct.decode(this.runLengths,this.materialIndices,new Uint8Array(Kt)):this.materialIndices,t.runLengths=null,t.materials=this.materials,t}},{key:"serialize",value:function(){return{materials:this.materials,materialIndices:this.materialIndices,runLengths:this.runLengths,edgeData:null!==this.edgeData?this.edgeData.serialize():null}}},{key:"deserialize",value:function(t){var n=this;return null!==t?(this.materials=t.materials,this.materialIndices=t.materialIndices,this.runLengths=t.runLengths,null!==t.edgeData?(null===this.edgeData&&(this.edgeData=new Qt),this.edgeData.deserialize(t.edgeData)):this.edgeData=null):n=null,n}},{key:"createTransferList",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return null!==this.edgeData&&this.edgeData.createTransferList(t),null!==this.materialIndices&&t.push(this.materialIndices.buffer),null!==this.runLengths&&t.push(this.runLengths.buffer),t}},{key:"empty",get:function(){return 0===this.materials}},{key:"full",get:function(){return this.materials===Kt}},{key:"compressed",get:function(){return null!==this.runLengths}},{key:"neutered",get:function(){return!this.empty&&null===this.materialIndices}}],[{key:"resolution",get:function(){return Gt},set:function(t){Gt=Math.max(1,Math.min(256,(n=t,Math.pow(2,Math.max(0,Math.ceil(Math.log2(n)))))));var n;Kt=Math.pow(Gt+1,3)}}]),e}(),Jt=function(){function e(){t(this,e)}return n(e,null,[{key:"parseBin",value:function(t){return parseInt(t,2)}},{key:"createBinaryString",value:function(t){for(var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:64,e=t<0?"-":"",i=Math.abs(t).toString(2);i.length<n;)i="0"+i;return e+i}}]),e}(),tn=function(){function e(n,i,a){t(this,e),this.keyDesign=n,this.min=i,this.max=a,this.keyBase=new h,this.key=new h,this.limit=new h,this.result=new dt,this.reset()}return n(e,[{key:"reset",value:function(){var t=this.keyDesign,n=this.min,e=this.max;return n.x<=e.x&&n.y<=e.y&&n.z<=e.z?(this.keyBase.set(n.x,n.y*t.rangeX,n.z*t.rangeXY),this.limit.set(e.x,e.y*t.rangeX,e.z*t.rangeXY),this.key.copy(this.keyBase)):(this.keyBase.set(1,1,1),this.limit.set(0,0,0),this.key.copy(this.keyBase),console.error("Invalid key range",n,e)),this.result.reset(),this}},{key:"next",value:function(){var t=this.result,n=this.keyDesign,e=this.keyBase,i=this.limit,a=this.key;return a.z<=i.z?(t.value=a.z+a.y+a.x,++a.x,a.x>i.x&&(a.x=e.x,a.y+=n.rangeX,a.y>i.y&&(a.y=e.y,a.z+=n.rangeXY))):(t.value=null,t.done=!0),t}},{key:"return",value:function(t){return this.result.value=t,this.result.done=!0,this.result}},{key:Symbol.iterator,value:function(){return this}}]),e}(),nn=Math.pow(2,32),en=53,an=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Math.round(.4*en),i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Math.round(.2*en),a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:n;t(this,e),this.x=0,this.y=0,this.z=0,this.rangeX=0,this.rangeY=0,this.rangeZ=0,this.rangeXY=0,this.halfRange=null,this.maskX=[0,0],this.maskY=[0,0],this.maskZ=[0,0],this.set(n,i,a)}return n(e,[{key:"set",value:function(t,n,e){(t+n+e>en||t>32||n>32||e>32)&&(console.warn("Invalid bit allotment"),t=Math.round(.4*en),n=Math.round(.2*en),e=t),this.x=t,this.y=n,this.z=e,this.rangeX=Math.pow(2,t),this.rangeY=Math.pow(2,n),this.rangeZ=Math.pow(2,e),this.rangeXY=Math.pow(2,t+n),this.halfRange=new h(this.rangeX/2,this.rangeY/2,this.rangeZ/2),this.updateBitMasks()}},{key:"updateBitMasks",value:function(){var t=this.x,n=this.y,e=this.z,i=this.maskX,a=this.maskY,r=this.maskZ,s=32-Math.max(0,t-32),o=32-Math.max(0,n+t-32),u=32-Math.max(0,e+n+t-32);i[1]=s<32?-1>>>s:0,i[0]=-1>>>Math.max(0,32-t),a[1]=((o<32?-1>>>o:0)&~i[1])>>>0,a[0]=(-1>>>Math.max(0,32-(t+n))&~i[0])>>>0,r[1]=((u<32?-1>>>u:0)&~a[1]&~i[1])>>>0,r[0]=(-1>>>Math.max(0,32-(t+n+e))&~a[0]&~i[0])>>>0}},{key:"unpackKey",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=this.maskX,i=this.maskY,a=this.maskZ,r=Math.trunc(t/nn),s=t%nn;return n.set((r&e[1])*nn+((s&e[0])>>>0),((r&i[1])*nn+((s&i[0])>>>0))/this.rangeX,((r&a[1])*nn+((s&a[0])>>>0))/this.rangeXY)}},{key:"packKey",value:function(t){return t.z*this.rangeXY+t.y*this.rangeX+t.x}},{key:"keyRange",value:function(t,n){return new tn(this,t,n)}},{key:"toString",value:function(){var t=this.maskX,n=this.maskY,e=this.maskZ;return"Key Design\\n\\nX-Bits: "+this.x+"\\nY-Bits: "+this.y+"\\nZ-Bits: "+this.z+"\\n\\n"+Jt.createBinaryString(t[1],32)+" "+t[1]+" (HI-Mask X)\\n"+Jt.createBinaryString(t[0],32)+" "+t[0]+" (LO-Mask X)\\n\\n"+Jt.createBinaryString(n[1],32)+" "+n[1]+" (HI-Mask Y)\\n"+Jt.createBinaryString(n[0],32)+" "+n[0]+" (LO-Mask Y)\\n\\n"+Jt.createBinaryString(e[1],32)+" "+e[1]+" (HI-Mask Z)\\n"+Jt.createBinaryString(e[0],32)+" "+e[0]+" (LO-Mask Z)\\n"}}],[{key:"BITS",get:function(){return en}},{key:"HI_BITS",get:function(){return 21}},{key:"LO_BITS",get:function(){return 32}}]),e}(),rn=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;t(this,e),this.octant=n,this.min=new h,this.max=new h}return n(e,[{key:"getCenter",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getDimensions",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).subVectors(this.max,this.min)}},{key:"containsPoint",value:function(t){var n=this.min,e=this.max;return t.x>=n.x&&t.y>=n.y&&t.z>=n.z&&t.x<=e.x&&t.y<=e.y&&t.z<=e.z}}]),e}(),sn=function(){function e(n){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t(this,e),this.world=n,this.lod=i,this.cellSize=0,this.iterator=null,this.octantWrapper=new rn,this.result=new dt,this.reset()}return n(e,[{key:"reset",value:function(){var t=this.lod,n=this.world,e=n.getGrid(t);return void 0!==e?(this.cellSize=n.getCellSize(t),this.iterator=e.entries(),this.result.reset()):console.error("Invalid LOD",t),this}},{key:"next",value:function(){var t=this.result,n=this.octantWrapper,e=this.iterator.next(),i=e.value;return e.done?(t.value=null,t.done=!0):(this.keyDesign.unpackKey(i[0],n.min),n.min.multiplyScalar(this.cellSize),n.min.add(this.world.min),n.max.copy(n.min).addScalar(this.cellSize),n.octant=i[1],t.value=n),t}},{key:"return",value:function(t){return this.result.value=t,this.result.done=!0,this.result}},{key:Symbol.iterator,value:function(){return this}}]),e}(),on=function n(){t(this,n),this.data=null,this.csg=new s,this.mesh=null},un=function(n){i(e,on);function e(){t(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return n.children=0,n}return e}(),ln=new h,hn=new h,cn=new v,dn=new v,vn=[];function mn(t,n,e,i,a,r,s){var o=void 0,u=void 0,l=void 0,h=void 0,c=void 0,d=void 0;if(e.csg.add(n),s>0)for(--s,o=t.getGrid(s),u=t.getKeyDesign(),l=e.children,h=vn[s],i<<=1,a<<=1,r<<=1,d=0;d<8;++d)0!=(l&1<<d)&&(c=yt[d],ln.set(i+c[0],a+c[1],r+c[2]),h.containsPoint(ln)&&mn(t,n,o.get(u.packKey(ln)),ln.x,ln.y,ln.z,s))}var yn=function(){function e(){t(this,e)}return n(e,null,[{key:"applyUnion",value:function(t,n,e){var i=t.getKeyDesign(),a=t.lodZero,r=cn.min,s=cn.max,o=dn.min,u=dn.max,l=dn,h=void 0,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0;for(m=t.getDepth();m>0;--m){d=t.getGrid(m),t.calculateKeyCoordinates(n.min,m,r),t.calculateKeyCoordinates(n.max,m,s),t.calculateKeyCoordinates(n.min,m-1,o),t.calculateKeyCoordinates(n.max,m-1,u);var f=!0,x=!1,p=void 0;try{for(var g,k=i.keyRange(r,s)[Symbol.iterator]();!(f=(g=k.next()).done);f=!0)if(h=g.value,!d.has(h))for((v=new un).csg.add(e),d.set(h,v),i.unpackKey(h,hn),hn.x<<=1,hn.y<<=1,hn.z<<=1,y=0;y<8;++y)c=yt[y],ln.set(hn.x+c[0],hn.y+c[1],hn.z+c[2]),l.containsPoint(ln)&&(v.children|=1<<y)}catch(t){x=!0,p=t}finally{try{!f&&k.return&&k.return()}finally{if(x)throw p}}}t.calculateKeyCoordinates(n.min,0,r),t.calculateKeyCoordinates(n.max,0,s);var z=!0,w=!1,b=void 0;try{for(var M,S=i.keyRange(r,s)[Symbol.iterator]();!(z=(M=S.next()).done);z=!0)h=M.value,a.has(h)?v=a.get(h):(v=new on,a.set(h,v)),v.csg.add(e)}catch(t){w=!0,b=t}finally{try{!z&&S.return&&S.return()}finally{if(w)throw b}}}},{key:"applyDifference",value:function(t,n,e){var i=t.getDepth(),a=t.getKeyDesign(),r=t.getGrid(i),s=t.calculateKeyCoordinates(n.min,i,cn.min),o=t.calculateKeyCoordinates(n.max,i,cn.max),u=void 0,l=void 0,h=void 0,c=void 0;for(u=0,l=i-1;u<l;++u)u<vn.length?(h=vn[u],t.calculateKeyCoordinates(n.min,u,h.min),t.calculateKeyCoordinates(n.max,u,h.max)):vn.push(new v(t.calculateKeyCoordinates(n.min,u),t.calculateKeyCoordinates(n.max,u)));var d=!0,m=!1,y=void 0;try{for(var f,x=a.keyRange(s,o)[Symbol.iterator]();!(d=(f=x.next()).done);d=!0)c=f.value,r.has(c)&&(a.unpackKey(c,hn),mn(t,e,r.get(c),hn.x,hn.y,hn.z,i))}catch(t){m=!0,y=t}finally{try{!d&&x.return&&x.return()}finally{if(m)throw y}}}},{key:"applyIntersection",value:function(t,n){var e=void 0;for(e=t.getDepth();e>=0;--e){var i=!0,a=!1,r=void 0;try{for(var s,o=t.getGrid(e).values()[Symbol.iterator]();!(i=(s=o.next()).done);i=!0)s.value.csg.add(n)}catch(t){a=!0,r=t}finally{try{!i&&o.return&&o.return()}finally{if(a)throw r}}}}},{key:"applyCSG",value:function(t,n){var e=n.getBoundingBox(!0);switch(e.min.max(t.min),e.max.min(t.max),n.operation){case l.UNION:this.applyUnion(t,e,n);break;case l.DIFFERENCE:this.applyDifference(t,e,n);break;case l.INTERSECTION:this.applyIntersection(t,n);break;default:console.error("No CSG operation type specified",n)}}}]),e}(),fn=new h,xn=new B,pn=new v,gn=new v,kn=new j,zn=[new Uint8Array([4,2,1]),new Uint8Array([5,3,8]),new Uint8Array([6,8,3]),new Uint8Array([7,8,8]),new Uint8Array([8,6,5]),new Uint8Array([8,7,8]),new Uint8Array([8,8,7]),new Uint8Array([8,8,8])],wn=0;function bn(t,n,e,i){var a=void 0,r=0;return n<e?(a=n,r=0):(a=e,r=1),i<a&&(r=2),zn[t][r]}function Mn(t,n,e,i,a){var r=pn.min.set(0,0,0),s=pn.max.subVectors(n.max,n.min),o=n.getDimensions(gn.min),u=gn.max.copy(o).multiplyScalar(.5),l=kn.origin.copy(i.origin),h=kn.direction.copy(i.direction),c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,x=void 0,p=void 0,g=void 0;l.sub(n.getCenter(fn)).add(u),wn=0,h.x<0&&(l.x=o.x-l.x,h.x=-h.x,wn|=4),h.y<0&&(l.y=o.y-l.y,h.y=-h.y,wn|=2),h.z<0&&(l.z=o.z-l.z,h.z=-h.z,wn|=1),c=1/h.x,d=1/h.y,v=1/h.z,m=(r.x-l.x)*c,y=(s.x-l.x)*c,f=(r.y-l.y)*d,x=(s.y-l.y)*d,p=(r.z-l.z)*v,g=(s.z-l.z)*v,function t(n,e,i,a,r,s,o,u,l,h,c,d,v){var m=void 0,y=void 0,f=void 0,x=void 0,p=void 0,g=void 0,k=void 0,z=void 0,w=void 0;if(h>=0&&c>=0&&d>=0)if(0===s||null!==e.mesh)v.push(e);else if(e.children>0){m=n.getGrid(--s),y=n.getKeyDesign(),f=e.children,i<<=1,a<<=1,r<<=1,p=function(t,n,e,i,a,r){var s=0;return t>n&&t>e?(a<t&&(s|=2),r<t&&(s|=1)):n>e?(i<n&&(s|=4),r<n&&(s|=1)):(i<e&&(s|=4),a<e&&(s|=2)),s}(o,u,l,g=.5*(o+h),k=.5*(u+c),z=.5*(l+d));do{switch(w=wn^p,p){case 0:0!=(f&1<<w)&&(x=yt[w],fn.set(i+x[0],a+x[1],r+x[2]),t(n,m.get(y.packKey(fn)),fn.x,fn.y,fn.z,s,o,u,l,g,k,z,v)),p=bn(p,g,k,z);break;case 1:0!=(f&1<<w)&&(x=yt[w],fn.set(i+x[0],a+x[1],r+x[2]),t(n,m.get(y.packKey(fn)),fn.x,fn.y,fn.z,s,o,u,z,g,k,d,v)),p=bn(p,g,k,d);break;case 2:0!=(f&1<<w)&&(x=yt[w],fn.set(i+x[0],a+x[1],r+x[2]),t(n,m.get(y.packKey(fn)),fn.x,fn.y,fn.z,s,o,k,l,g,c,z,v)),p=bn(p,g,c,z);break;case 3:0!=(f&1<<w)&&(x=yt[w],fn.set(i+x[0],a+x[1],r+x[2]),t(n,m.get(y.packKey(fn)),fn.x,fn.y,fn.z,s,o,k,z,g,c,d,v)),p=bn(p,g,c,d);break;case 4:0!=(f&1<<w)&&(x=yt[w],fn.set(i+x[0],a+x[1],r+x[2]),t(n,m.get(y.packKey(fn)),fn.x,fn.y,fn.z,s,g,u,l,h,k,z,v)),p=bn(p,h,k,z);break;case 5:0!=(f&1<<w)&&(x=yt[w],fn.set(i+x[0],a+x[1],r+x[2]),t(n,m.get(y.packKey(fn)),fn.x,fn.y,fn.z,s,g,u,z,h,k,d,v)),p=bn(p,h,k,d);break;case 6:0!=(f&1<<w)&&(x=yt[w],fn.set(i+x[0],a+x[1],r+x[2]),t(n,m.get(y.packKey(fn)),fn.x,fn.y,fn.z,s,g,k,l,h,c,z,v)),p=bn(p,h,c,z);break;case 7:0!=(f&1<<w)&&(x=yt[w],fn.set(i+x[0],a+x[1],r+x[2]),t(n,m.get(y.packKey(fn)),fn.x,fn.y,fn.z,s,g,k,z,h,c,d,v)),p=8}}while(p<8)}}(t,n.octant,e.x,e.y,e.z,t.getDepth(),m,f,p,y,x,g,a)}var Sn=function(){function e(){t(this,e)}return n(e,null,[{key:"intersectWorldOctree",value:function(t,n){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],i=t.getDepth(),a=t.getGrid(i),r=t.getCellSize(i),s=t.getKeyDesign(),o=new rn,u=xn.start,l=xn.end,h=t.containsPoint(kn.copy(n).origin)?kn.origin:kn.intersectBox(t,kn.origin),c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,x=void 0,p=void 0,g=void 0,k=void 0,z=void 0,w=void 0,b=void 0,M=void 0,S=void 0,C=void 0,O=void 0,D=void 0,P=void 0,A=void 0;if(null!==h)for(v=r<<1,m=kn.at(v,fn),t.calculateKeyCoordinates(h,i,u),t.calculateKeyCoordinates(m,i,l),f=l.x-u.x,x=l.y-u.y,p=l.z-u.z,S=Math.sign(f),C=Math.sign(x),O=Math.sign(p),w=2*(g=Math.abs(f)),b=2*(k=Math.abs(x)),M=2*(z=Math.abs(p)),D=k-g,P=z-g,A=k-z,y=g+k+z;y>0;--y)c=s.packKey(u),a.has(c)&&(null===(d=a.get(c)).mesh?(o.octant=d,o.min.copy(u),o.min.multiplyScalar(r),o.min.add(t.min),o.max.copy(o.min).addScalar(r),Mn(t,o,u,n,e)):e.push(d)),D<0?P<0?(u.x+=S,D+=b,P+=M):(u.z+=O,P-=w,A+=b):A<0?(u.z+=O,P-=w,A+=b):(u.y+=C,D-=w,A-=M);return e}}]),e}(),Cn=new h;var On=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:20,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:8,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new an;for(t(this,e),i=Math.max(Math.min(Math.trunc(i),32),1),this.cellSize=Math.max(Math.min(Math.trunc(n),Math.pow(2,33-i)-1),1),this.keyDesign=a,this.grids=[];this.grids.length<i;)this.grids.push(new Map);this.bounds=new rn,this.bounds.min.copy(this.keyDesign.halfRange).multiplyScalar(-this.cellSize),this.bounds.max.copy(this.keyDesign.halfRange).multiplyScalar(this.cellSize)}return n(e,[{key:"getKeyDesign",value:function(){return this.keyDesign}},{key:"getCellSize",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.cellSize<<t>>>0}},{key:"getCenter",value:function(t){return this.bounds.getCenter(t)}},{key:"setCenter",value:function(t){this.min.copy(this.keyDesign.halfRange).multiplyScalar(-this.cellSize).add(t),this.max.copy(this.keyDesign.halfRange).multiplyScalar(this.cellSize).add(t)}},{key:"getDimensions",value:function(t){return this.bounds.getDimensions(t)}},{key:"getDepth",value:function(){return this.grids.length-1}},{key:"getGrid",value:function(t){return t>=0&&t<this.grids.length?this.grids[t]:void 0}},{key:"clear",value:function(){var t=void 0,n=void 0;for(t=0,n=this.grids.length;t<n;++t)this.grids[t].clear()}},{key:"containsPoint",value:function(t){return this.bounds.containsPoint(t)}},{key:"findOctantsByLevel",value:function(t){return this.octants(t)}},{key:"calculateKeyCoordinates",value:function(t,n){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new h,i=this.cellSize<<n;return Cn.subVectors(t,this.min),e.set(Math.trunc(Cn.x/i),Math.trunc(Cn.y/i),Math.trunc(Cn.z/i)),e}},{key:"getOctantByPoint",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.keyDesign,i=this.getGrid(n),a=void 0;return void 0!==i?this.containsPoint(t)?(this.calculateKeyCoordinates(t,n,Cn),a=i.get(e.packKey(Cn))):console.error("Position out of range",t):console.error("Invalid LOD",n),a}},{key:"removeOctant",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.keyDesign,i=this.getGrid(n),a=void 0,r=void 0,s=void 0;void 0!==i?i.has(t)?(e.unpackKey(t,Cn),a=Cn.x,r=Cn.y,s=Cn.z,function t(n,e,i,a,r,s){var o=void 0,u=void 0,l=void 0,h=void 0,c=void 0,d=void 0,v=void 0;if(s>0){for(--s,o=n.getGrid(s),u=n.getKeyDesign(),l=e.children,i<<=1,a<<=1,r<<=1,v=0;v<8;++v)0!=(l&1<<v)&&(c=yt[v],Cn.set(i+c[0],a+c[1],r+c[2]),d=u.packKey(Cn),h=o.get(d),o.delete(d),t(n,h,Cn.x,Cn.y,Cn.z,s));e.children=0}}(this,i.get(t),a,r,s,n),i.delete(t),function t(n,e,i,a,r){var s=void 0,o=void 0,u=void 0,l=void 0;++r<n.levels&&(s=n.getGrid(r),o=On.calculateOffsetIndex(e,i,a),Cn.set(e>>>1,i>>>1,a>>>1),u=n.getKeyDesign().packKey(Cn),(l=s.get(u)).children&=~(1<<o),0===l.children&&(s.delete(u),t(n,Cn.x,Cn.y,Cn.z,r)))}(this,a,r,s,n)):console.error("No octant found",t):console.error("Invalid LOD",n)}},{key:"applyCSG",value:function(t){yn.applyCSG(this,t)}},{key:"raycast",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Sn.intersectWorldOctree(this,t,n)}},{key:"octants",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return new sn(this,t)}},{key:"min",get:function(){return this.bounds.min}},{key:"max",get:function(){return this.bounds.max}},{key:"levels",get:function(){return this.grids.length}},{key:"lodZero",get:function(){return this.grids[0]}}],[{key:"calculateOffsetIndex",value:function(t,n,e){return((1&t)<<2)+((1&n)<<1)+(1&e)}}]),e}(),Dn=function(){function e(n){t(this,e)}return n(e,[{key:"clone",value:function(){return new this.constructor(this.levels)}},{key:"levels",get:function(){return this.something.length}}]),e}(),Pn=function(n){i(e,o);function e(n){t(this,e);var i=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n));return i.lod=-1,i.left=null,i.entered=null,i.error=null,i}return e}(),An=(new Pn("update"),new Pn("error"),new v,new E),_n=new $,Tn=function(e){i(r,u);function r(n){t(this,r);var e=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));return e.world=n,e.position=new h(1/0,1/0,1/0),e.currentScene=new Dn(e.world.levels),e.previousScene=e.currentScene.clone(),e.nextScene=e.currentScene.clone(),e}return n(r,[{key:"update",value:function(t){this.position.copy(t.position),An.setFromMatrix(_n.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse))}},{key:"process",value:function(){}},{key:"clear",value:function(){this.previousScene.clear(),this.currentScene.clear(),this.nextScene.clear()}}]),r}(),In={EXTRACT:"worker.extract",MODIFY:"worker.modify",CONFIGURE:"worker.config",CLOSE:"worker.close"},qn=function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;t(this,n),this.action=e,this.error=null},En=function(n){i(e,qn);function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;t(this,e);var i=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n));return i.data=null,i}return e}(),Vn=(function(n){i(e,En);function e(){return t(this,e),a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,In.EXTRACT))}}(),function(n){i(e,En);function e(){t(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,In.MODIFY));return n.sdf=null,n.cellSize=0,n.cellPosition=null,n}}(),function(n){i(e,qn);function e(){t(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,In.CONFIGURE));return n.resolution=Wt.resolution,n.errorThreshold=.01,n}return e}()),Fn=function(n){i(e,En);function e(){t(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,In.EXTRACT));return n.isosurface=null,n}return e}(),Bn=function(n){i(e,En);function e(){t(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,In.MODIFY));return n.sdf=null,n}return e}(),Rn=new(function(n){i(e,o);function e(n){t(this,e);var i=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n));return i.worker=null,i.response=null,i}return e}())("message"),Un=\'(function () {\\n  \\\'use strict\\\';\\n\\n  var classCallCheck = function (instance, Constructor) {\\n    if (!(instance instanceof Constructor)) {\\n      throw new TypeError("Cannot call a class as a function");\\n    }\\n  };\\n\\n  var createClass = function () {\\n    function defineProperties(target, props) {\\n      for (var i = 0; i < props.length; i++) {\\n        var descriptor = props[i];\\n        descriptor.enumerable = descriptor.enumerable || false;\\n        descriptor.configurable = true;\\n        if ("value" in descriptor) descriptor.writable = true;\\n        Object.defineProperty(target, descriptor.key, descriptor);\\n      }\\n    }\\n\\n    return function (Constructor, protoProps, staticProps) {\\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\\n      if (staticProps) defineProperties(Constructor, staticProps);\\n      return Constructor;\\n    };\\n  }();\\n\\n\\n\\n\\n\\n\\n\\n  var get = function get(object, property, receiver) {\\n    if (object === null) object = Function.prototype;\\n    var desc = Object.getOwnPropertyDescriptor(object, property);\\n\\n    if (desc === undefined) {\\n      var parent = Object.getPrototypeOf(object);\\n\\n      if (parent === null) {\\n        return undefined;\\n      } else {\\n        return get(parent, property, receiver);\\n      }\\n    } else if ("value" in desc) {\\n      return desc.value;\\n    } else {\\n      var getter = desc.get;\\n\\n      if (getter === undefined) {\\n        return undefined;\\n      }\\n\\n      return getter.call(receiver);\\n    }\\n  };\\n\\n  var inherits = function (subClass, superClass) {\\n    if (typeof superClass !== "function" && superClass !== null) {\\n      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);\\n    }\\n\\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\\n      constructor: {\\n        value: subClass,\\n        enumerable: false,\\n        writable: true,\\n        configurable: true\\n      }\\n    });\\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\\n  };\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  var possibleConstructorReturn = function (self, call) {\\n    if (!self) {\\n      throw new ReferenceError("this hasn\\\'t been initialised - super() hasn\\\'t been called");\\n    }\\n\\n    return call && (typeof call === "object" || typeof call === "function") ? call : self;\\n  };\\n\\n\\n\\n  var set = function set(object, property, value, receiver) {\\n    var desc = Object.getOwnPropertyDescriptor(object, property);\\n\\n    if (desc === undefined) {\\n      var parent = Object.getPrototypeOf(object);\\n\\n      if (parent !== null) {\\n        set(parent, property, value, receiver);\\n      }\\n    } else if ("value" in desc && desc.writable) {\\n      desc.value = value;\\n    } else {\\n      var setter = desc.set;\\n\\n      if (setter !== undefined) {\\n        setter.call(receiver, value);\\n      }\\n    }\\n\\n    return value;\\n  };\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  var toConsumableArray = function (arr) {\\n    if (Array.isArray(arr)) {\\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\\n\\n      return arr2;\\n    } else {\\n      return Array.from(arr);\\n    }\\n  };\\n\\n  var RunLengthEncoding = function () {\\n  \\t\\tfunction RunLengthEncoding() {\\n  \\t\\t\\t\\tvar runLengths = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\\n  \\t\\t\\t\\tvar data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\\n  \\t\\t\\t\\tclassCallCheck(this, RunLengthEncoding);\\n\\n\\n  \\t\\t\\t\\tthis.runLengths = runLengths;\\n\\n  \\t\\t\\t\\tthis.data = data;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(RunLengthEncoding, null, [{\\n  \\t\\t\\t\\tkey: "encode",\\n  \\t\\t\\t\\tvalue: function encode(array) {\\n\\n  \\t\\t\\t\\t\\t\\tvar runLengths = [];\\n  \\t\\t\\t\\t\\t\\tvar data = [];\\n\\n  \\t\\t\\t\\t\\t\\tvar previous = array[0];\\n  \\t\\t\\t\\t\\t\\tvar count = 1;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 1, l = array.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (previous !== array[i]) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\trunLengths.push(count);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdata.push(previous);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprevious = array[i];\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount = 1;\\n  \\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++count;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\trunLengths.push(count);\\n  \\t\\t\\t\\t\\t\\tdata.push(previous);\\n\\n  \\t\\t\\t\\t\\t\\treturn new RunLengthEncoding(runLengths, data);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "decode",\\n  \\t\\t\\t\\tvalue: function decode(runLengths, data) {\\n  \\t\\t\\t\\t\\t\\tvar array = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar element = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0,\\n  \\t\\t\\t\\t\\t\\t    j = void 0,\\n  \\t\\t\\t\\t\\t\\t    il = void 0,\\n  \\t\\t\\t\\t\\t\\t    jl = void 0;\\n  \\t\\t\\t\\t\\t\\tvar k = 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0, il = data.length; i < il; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\telement = data[i];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tfor (j = 0, jl = runLengths[i]; j < jl; ++j) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tarray[k++] = element;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn array;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn RunLengthEncoding;\\n  }();\\n\\n  var Vector3 = function () {\\n  \\tfunction Vector3() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tclassCallCheck(this, Vector3);\\n\\n\\n  \\t\\tthis.x = x;\\n\\n  \\t\\tthis.y = y;\\n\\n  \\t\\tthis.z = z;\\n  \\t}\\n\\n  \\tcreateClass(Vector3, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(x, y, z) {\\n\\n  \\t\\t\\tthis.x = x;\\n  \\t\\t\\tthis.y = y;\\n  \\t\\t\\tthis.z = z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(v) {\\n\\n  \\t\\t\\tthis.x = v.x;\\n  \\t\\t\\tthis.y = v.y;\\n  \\t\\t\\tthis.z = v.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor(this.x, this.y, this.z);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "fromArray",\\n  \\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tthis.x = array[offset];\\n  \\t\\t\\tthis.y = array[offset + 1];\\n  \\t\\t\\tthis.z = array[offset + 2];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "toArray",\\n  \\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tarray[offset] = this.x;\\n  \\t\\t\\tarray[offset + 1] = this.y;\\n  \\t\\t\\tarray[offset + 2] = this.z;\\n\\n  \\t\\t\\treturn array;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromSpherical",\\n  \\t\\tvalue: function setFromSpherical(s) {\\n\\n  \\t\\t\\tvar sinPhiRadius = Math.sin(s.phi) * s.radius;\\n\\n  \\t\\t\\tthis.x = sinPhiRadius * Math.sin(s.theta);\\n  \\t\\t\\tthis.y = Math.cos(s.phi) * s.radius;\\n  \\t\\t\\tthis.z = sinPhiRadius * Math.cos(s.theta);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromCylindrical",\\n  \\t\\tvalue: function setFromCylindrical(c) {\\n\\n  \\t\\t\\tthis.x = c.radius * Math.sin(c.theta);\\n  \\t\\t\\tthis.y = c.y;\\n  \\t\\t\\tthis.z = c.radius * Math.cos(c.theta);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromMatrixColumn",\\n  \\t\\tvalue: function setFromMatrixColumn(m, index) {\\n\\n  \\t\\t\\treturn this.fromArray(m.elements, index * 4);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromMatrixPosition",\\n  \\t\\tvalue: function setFromMatrixPosition(m) {\\n\\n  \\t\\t\\tvar me = m.elements;\\n\\n  \\t\\t\\tthis.x = me[12];\\n  \\t\\t\\tthis.y = me[13];\\n  \\t\\t\\tthis.z = me[14];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromMatrixScale",\\n  \\t\\tvalue: function setFromMatrixScale(m) {\\n\\n  \\t\\t\\tvar sx = this.setFromMatrixColumn(m, 0).length();\\n  \\t\\t\\tvar sy = this.setFromMatrixColumn(m, 1).length();\\n  \\t\\t\\tvar sz = this.setFromMatrixColumn(m, 2).length();\\n\\n  \\t\\t\\tthis.x = sx;\\n  \\t\\t\\tthis.y = sy;\\n  \\t\\t\\tthis.z = sz;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "add",\\n  \\t\\tvalue: function add(v) {\\n\\n  \\t\\t\\tthis.x += v.x;\\n  \\t\\t\\tthis.y += v.y;\\n  \\t\\t\\tthis.z += v.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "addScalar",\\n  \\t\\tvalue: function addScalar(s) {\\n\\n  \\t\\t\\tthis.x += s;\\n  \\t\\t\\tthis.y += s;\\n  \\t\\t\\tthis.z += s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "addVectors",\\n  \\t\\tvalue: function addVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x + b.x;\\n  \\t\\t\\tthis.y = a.y + b.y;\\n  \\t\\t\\tthis.z = a.z + b.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "addScaledVector",\\n  \\t\\tvalue: function addScaledVector(v, s) {\\n\\n  \\t\\t\\tthis.x += v.x * s;\\n  \\t\\t\\tthis.y += v.y * s;\\n  \\t\\t\\tthis.z += v.z * s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "sub",\\n  \\t\\tvalue: function sub(v) {\\n\\n  \\t\\t\\tthis.x -= v.x;\\n  \\t\\t\\tthis.y -= v.y;\\n  \\t\\t\\tthis.z -= v.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "subScalar",\\n  \\t\\tvalue: function subScalar(s) {\\n\\n  \\t\\t\\tthis.x -= s;\\n  \\t\\t\\tthis.y -= s;\\n  \\t\\t\\tthis.z -= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "subVectors",\\n  \\t\\tvalue: function subVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x - b.x;\\n  \\t\\t\\tthis.y = a.y - b.y;\\n  \\t\\t\\tthis.z = a.z - b.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "multiply",\\n  \\t\\tvalue: function multiply(v) {\\n\\n  \\t\\t\\tthis.x *= v.x;\\n  \\t\\t\\tthis.y *= v.y;\\n  \\t\\t\\tthis.z *= v.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "multiplyScalar",\\n  \\t\\tvalue: function multiplyScalar(s) {\\n\\n  \\t\\t\\tthis.x *= s;\\n  \\t\\t\\tthis.y *= s;\\n  \\t\\t\\tthis.z *= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "multiplyVectors",\\n  \\t\\tvalue: function multiplyVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x * b.x;\\n  \\t\\t\\tthis.y = a.y * b.y;\\n  \\t\\t\\tthis.z = a.z * b.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "divide",\\n  \\t\\tvalue: function divide(v) {\\n\\n  \\t\\t\\tthis.x /= v.x;\\n  \\t\\t\\tthis.y /= v.y;\\n  \\t\\t\\tthis.z /= v.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "divideScalar",\\n  \\t\\tvalue: function divideScalar(s) {\\n\\n  \\t\\t\\tthis.x /= s;\\n  \\t\\t\\tthis.y /= s;\\n  \\t\\t\\tthis.z /= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "crossVectors",\\n  \\t\\tvalue: function crossVectors(a, b) {\\n\\n  \\t\\t\\tvar ax = a.x,\\n  \\t\\t\\t    ay = a.y,\\n  \\t\\t\\t    az = a.z;\\n  \\t\\t\\tvar bx = b.x,\\n  \\t\\t\\t    by = b.y,\\n  \\t\\t\\t    bz = b.z;\\n\\n  \\t\\t\\tthis.x = ay * bz - az * by;\\n  \\t\\t\\tthis.y = az * bx - ax * bz;\\n  \\t\\t\\tthis.z = ax * by - ay * bx;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "cross",\\n  \\t\\tvalue: function cross(v) {\\n\\n  \\t\\t\\treturn this.crossVectors(this, v);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "transformDirection",\\n  \\t\\tvalue: function transformDirection(m) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z;\\n  \\t\\t\\tvar e = m.elements;\\n\\n  \\t\\t\\tthis.x = e[0] * x + e[4] * y + e[8] * z;\\n  \\t\\t\\tthis.y = e[1] * x + e[5] * y + e[9] * z;\\n  \\t\\t\\tthis.z = e[2] * x + e[6] * y + e[10] * z;\\n\\n  \\t\\t\\treturn this.normalize();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "applyMatrix3",\\n  \\t\\tvalue: function applyMatrix3(m) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z;\\n  \\t\\t\\tvar e = m.elements;\\n\\n  \\t\\t\\tthis.x = e[0] * x + e[3] * y + e[6] * z;\\n  \\t\\t\\tthis.y = e[1] * x + e[4] * y + e[7] * z;\\n  \\t\\t\\tthis.z = e[2] * x + e[5] * y + e[8] * z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "applyMatrix4",\\n  \\t\\tvalue: function applyMatrix4(m) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z;\\n  \\t\\t\\tvar e = m.elements;\\n\\n  \\t\\t\\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12];\\n  \\t\\t\\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13];\\n  \\t\\t\\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "applyQuaternion",\\n  \\t\\tvalue: function applyQuaternion(q) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z;\\n  \\t\\t\\tvar qx = q.x,\\n  \\t\\t\\t    qy = q.y,\\n  \\t\\t\\t    qz = q.z,\\n  \\t\\t\\t    qw = q.w;\\n\\n  \\t\\t\\tvar ix = qw * x + qy * z - qz * y;\\n  \\t\\t\\tvar iy = qw * y + qz * x - qx * z;\\n  \\t\\t\\tvar iz = qw * z + qx * y - qy * x;\\n  \\t\\t\\tvar iw = -qx * x - qy * y - qz * z;\\n\\n  \\t\\t\\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\\n  \\t\\t\\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\\n  \\t\\t\\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "negate",\\n  \\t\\tvalue: function negate() {\\n\\n  \\t\\t\\tthis.x = -this.x;\\n  \\t\\t\\tthis.y = -this.y;\\n  \\t\\t\\tthis.z = -this.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "dot",\\n  \\t\\tvalue: function dot(v) {\\n\\n  \\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "reflect",\\n  \\t\\tvalue: function reflect(n) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar nx = n.x;\\n  \\t\\t\\tvar ny = n.y;\\n  \\t\\t\\tvar nz = n.z;\\n\\n  \\t\\t\\tthis.sub(n.multiplyScalar(2 * this.dot(n)));\\n\\n  \\t\\t\\tn.set(nx, ny, nz);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "angleTo",\\n  \\t\\tvalue: function angleTo(v) {\\n\\n  \\t\\t\\tvar theta = this.dot(v) / Math.sqrt(this.lengthSquared() * v.lengthSquared());\\n\\n  \\t\\t\\treturn Math.acos(Math.min(Math.max(theta, -1), 1));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "manhattanLength",\\n  \\t\\tvalue: function manhattanLength() {\\n\\n  \\t\\t\\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lengthSquared",\\n  \\t\\tvalue: function lengthSquared() {\\n\\n  \\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "length",\\n  \\t\\tvalue: function length() {\\n\\n  \\t\\t\\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "manhattanDistanceTo",\\n  \\t\\tvalue: function manhattanDistanceTo(v) {\\n\\n  \\t\\t\\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceToSquared",\\n  \\t\\tvalue: function distanceToSquared(v) {\\n\\n  \\t\\t\\tvar dx = this.x - v.x;\\n  \\t\\t\\tvar dy = this.y - v.y;\\n  \\t\\t\\tvar dz = this.z - v.z;\\n\\n  \\t\\t\\treturn dx * dx + dy * dy + dz * dz;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceTo",\\n  \\t\\tvalue: function distanceTo(v) {\\n\\n  \\t\\t\\treturn Math.sqrt(this.distanceToSquared(v));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "normalize",\\n  \\t\\tvalue: function normalize() {\\n\\n  \\t\\t\\treturn this.divideScalar(this.length());\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setLength",\\n  \\t\\tvalue: function setLength(length) {\\n\\n  \\t\\t\\treturn this.normalize().multiplyScalar(length);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "min",\\n  \\t\\tvalue: function min(v) {\\n\\n  \\t\\t\\tthis.x = Math.min(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.min(this.y, v.y);\\n  \\t\\t\\tthis.z = Math.min(this.z, v.z);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "max",\\n  \\t\\tvalue: function max(v) {\\n\\n  \\t\\t\\tthis.x = Math.max(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.max(this.y, v.y);\\n  \\t\\t\\tthis.z = Math.max(this.z, v.z);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clamp",\\n  \\t\\tvalue: function clamp(min, max) {\\n\\n  \\t\\t\\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\\n  \\t\\t\\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\\n  \\t\\t\\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "floor",\\n  \\t\\tvalue: function floor() {\\n\\n  \\t\\t\\tthis.x = Math.floor(this.x);\\n  \\t\\t\\tthis.y = Math.floor(this.y);\\n  \\t\\t\\tthis.z = Math.floor(this.z);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "ceil",\\n  \\t\\tvalue: function ceil() {\\n\\n  \\t\\t\\tthis.x = Math.ceil(this.x);\\n  \\t\\t\\tthis.y = Math.ceil(this.y);\\n  \\t\\t\\tthis.z = Math.ceil(this.z);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "round",\\n  \\t\\tvalue: function round() {\\n\\n  \\t\\t\\tthis.x = Math.round(this.x);\\n  \\t\\t\\tthis.y = Math.round(this.y);\\n  \\t\\t\\tthis.z = Math.round(this.z);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lerp",\\n  \\t\\tvalue: function lerp(v, alpha) {\\n\\n  \\t\\t\\tthis.x += (v.x - this.x) * alpha;\\n  \\t\\t\\tthis.y += (v.y - this.y) * alpha;\\n  \\t\\t\\tthis.z += (v.z - this.z) * alpha;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lerpVectors",\\n  \\t\\tvalue: function lerpVectors(v1, v2, alpha) {\\n\\n  \\t\\t\\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(v) {\\n\\n  \\t\\t\\treturn v.x === this.x && v.y === this.y && v.z === this.z;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Vector3;\\n  }();\\n\\n  var v = new Vector3();\\n\\n  var points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\\n\\n  var Box3 = function () {\\n  \\tfunction Box3() {\\n  \\t\\tvar min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(Infinity, Infinity, Infinity);\\n  \\t\\tvar max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(-Infinity, -Infinity, -Infinity);\\n  \\t\\tclassCallCheck(this, Box3);\\n\\n\\n  \\t\\tthis.min = min;\\n\\n  \\t\\tthis.max = max;\\n  \\t}\\n\\n  \\tcreateClass(Box3, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(min, max) {\\n\\n  \\t\\t\\tthis.min.copy(min);\\n  \\t\\t\\tthis.max.copy(max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(b) {\\n\\n  \\t\\t\\tthis.min.copy(b.min);\\n  \\t\\t\\tthis.max.copy(b.max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "makeEmpty",\\n  \\t\\tvalue: function makeEmpty() {\\n\\n  \\t\\t\\tthis.min.x = this.min.y = this.min.z = Infinity;\\n  \\t\\t\\tthis.max.x = this.max.y = this.max.z = -Infinity;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "isEmpty",\\n  \\t\\tvalue: function isEmpty() {\\n\\n  \\t\\t\\treturn this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getCenter",\\n  \\t\\tvalue: function getCenter() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn !this.isEmpty() ? target.addVectors(this.min, this.max).multiplyScalar(0.5) : target.set(0, 0, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getSize",\\n  \\t\\tvalue: function getSize() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn !this.isEmpty() ? target.subVectors(this.max, this.min) : target.set(0, 0, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getBoundingSphere",\\n  \\t\\tvalue: function getBoundingSphere() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Sphere();\\n\\n\\n  \\t\\t\\tthis.getCenter(target.center);\\n\\n  \\t\\t\\ttarget.radius = this.getSize(v).length() * 0.5;\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "expandByPoint",\\n  \\t\\tvalue: function expandByPoint(p) {\\n\\n  \\t\\t\\tthis.min.min(p);\\n  \\t\\t\\tthis.max.max(p);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "expandByVector",\\n  \\t\\tvalue: function expandByVector(v) {\\n\\n  \\t\\t\\tthis.min.sub(v);\\n  \\t\\t\\tthis.max.add(v);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "expandByScalar",\\n  \\t\\tvalue: function expandByScalar(s) {\\n\\n  \\t\\t\\tthis.min.addScalar(-s);\\n  \\t\\t\\tthis.max.addScalar(s);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromPoints",\\n  \\t\\tvalue: function setFromPoints(points) {\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\tthis.min.set(0, 0, 0);\\n  \\t\\t\\tthis.max.set(0, 0, 0);\\n\\n  \\t\\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tthis.expandByPoint(points[i]);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromCenterAndSize",\\n  \\t\\tvalue: function setFromCenterAndSize(center, size) {\\n\\n  \\t\\t\\tvar halfSize = v.copy(size).multiplyScalar(0.5);\\n\\n  \\t\\t\\tthis.min.copy(center).sub(halfSize);\\n  \\t\\t\\tthis.max.copy(center).add(halfSize);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clampPoint",\\n  \\t\\tvalue: function clampPoint(point) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.copy(point).clamp(this.min, this.max);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceToPoint",\\n  \\t\\tvalue: function distanceToPoint(p) {\\n\\n  \\t\\t\\tvar clampedPoint = v.copy(p).clamp(this.min, this.max);\\n\\n  \\t\\t\\treturn clampedPoint.sub(p).length();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "applyMatrix4",\\n  \\t\\tvalue: function applyMatrix4(m) {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar max = this.max;\\n\\n  \\t\\t\\tif (!this.isEmpty()) {\\n\\n  \\t\\t\\t\\tpoints[0].set(min.x, min.y, min.z).applyMatrix4(m);\\n  \\t\\t\\t\\tpoints[1].set(min.x, min.y, max.z).applyMatrix4(m);\\n  \\t\\t\\t\\tpoints[2].set(min.x, max.y, min.z).applyMatrix4(m);\\n  \\t\\t\\t\\tpoints[3].set(min.x, max.y, max.z).applyMatrix4(m);\\n  \\t\\t\\t\\tpoints[4].set(max.x, min.y, min.z).applyMatrix4(m);\\n  \\t\\t\\t\\tpoints[5].set(max.x, min.y, max.z).applyMatrix4(m);\\n  \\t\\t\\t\\tpoints[6].set(max.x, max.y, min.z).applyMatrix4(m);\\n  \\t\\t\\t\\tpoints[7].set(max.x, max.y, max.z).applyMatrix4(m);\\n\\n  \\t\\t\\t\\tthis.setFromPoints(points);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "translate",\\n  \\t\\tvalue: function translate(offset) {\\n\\n  \\t\\t\\tthis.min.add(offset);\\n  \\t\\t\\tthis.max.add(offset);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersect",\\n  \\t\\tvalue: function intersect(b) {\\n\\n  \\t\\t\\tthis.min.max(b.min);\\n  \\t\\t\\tthis.max.min(b.max);\\n\\n  \\t\\t\\tif (this.isEmpty()) {\\n\\n  \\t\\t\\t\\tthis.makeEmpty();\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "union",\\n  \\t\\tvalue: function union(b) {\\n\\n  \\t\\t\\tthis.min.min(b.min);\\n  \\t\\t\\tthis.max.max(b.max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "containsPoint",\\n  \\t\\tvalue: function containsPoint(p) {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar max = this.max;\\n\\n  \\t\\t\\treturn p.x >= min.x && p.y >= min.y && p.z >= min.z && p.x <= max.x && p.y <= max.y && p.z <= max.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "containsBox",\\n  \\t\\tvalue: function containsBox(b) {\\n\\n  \\t\\t\\tvar tMin = this.min;\\n  \\t\\t\\tvar tMax = this.max;\\n  \\t\\t\\tvar bMin = b.min;\\n  \\t\\t\\tvar bMax = b.max;\\n\\n  \\t\\t\\treturn tMin.x <= bMin.x && bMax.x <= tMax.x && tMin.y <= bMin.y && bMax.y <= tMax.y && tMin.z <= bMin.z && bMax.z <= tMax.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsBox",\\n  \\t\\tvalue: function intersectsBox(b) {\\n\\n  \\t\\t\\tvar tMin = this.min;\\n  \\t\\t\\tvar tMax = this.max;\\n  \\t\\t\\tvar bMin = b.min;\\n  \\t\\t\\tvar bMax = b.max;\\n\\n  \\t\\t\\treturn bMax.x >= tMin.x && bMax.y >= tMin.y && bMax.z >= tMin.z && bMin.x <= tMax.x && bMin.y <= tMax.y && bMin.z <= tMax.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsSphere",\\n  \\t\\tvalue: function intersectsSphere(s) {\\n  \\t\\t\\tvar closestPoint = this.clampPoint(s.center, v);\\n\\n  \\t\\t\\treturn closestPoint.distanceToSquared(s.center) <= s.radius * s.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsPlane",\\n  \\t\\tvalue: function intersectsPlane(p) {\\n\\n  \\t\\t\\tvar min = void 0,\\n  \\t\\t\\t    max = void 0;\\n\\n  \\t\\t\\tif (p.normal.x > 0) {\\n\\n  \\t\\t\\t\\tmin = p.normal.x * this.min.x;\\n  \\t\\t\\t\\tmax = p.normal.x * this.max.x;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tmin = p.normal.x * this.max.x;\\n  \\t\\t\\t\\tmax = p.normal.x * this.min.x;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (p.normal.y > 0) {\\n\\n  \\t\\t\\t\\tmin += p.normal.y * this.min.y;\\n  \\t\\t\\t\\tmax += p.normal.y * this.max.y;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tmin += p.normal.y * this.max.y;\\n  \\t\\t\\t\\tmax += p.normal.y * this.min.y;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (p.normal.z > 0) {\\n\\n  \\t\\t\\t\\tmin += p.normal.z * this.min.z;\\n  \\t\\t\\t\\tmax += p.normal.z * this.max.z;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tmin += p.normal.z * this.max.z;\\n  \\t\\t\\t\\tmax += p.normal.z * this.min.z;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn min <= p.constant && max >= p.constant;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(b) {\\n\\n  \\t\\t\\treturn b.min.equals(this.min) && b.max.equals(this.max);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Box3;\\n  }();\\n\\n  var box = new Box3();\\n\\n  var Sphere = function () {\\n  \\tfunction Sphere() {\\n  \\t\\tvar center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\tvar radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tclassCallCheck(this, Sphere);\\n\\n\\n  \\t\\tthis.center = center;\\n\\n  \\t\\tthis.radius = radius;\\n  \\t}\\n\\n  \\tcreateClass(Sphere, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(center, radius) {\\n\\n  \\t\\t\\tthis.center.copy(center);\\n  \\t\\t\\tthis.radius = radius;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(s) {\\n\\n  \\t\\t\\tthis.center.copy(s.center);\\n  \\t\\t\\tthis.radius = s.radius;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromPoints",\\n  \\t\\tvalue: function setFromPoints(points) {\\n  \\t\\t\\tvar center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : box.setFromPoints(points).getCenter(this.center);\\n\\n\\n  \\t\\t\\tvar maxRadiusSq = 0;\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tthis.radius = Math.sqrt(maxRadiusSq);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getBoundingBox",\\n  \\t\\tvalue: function getBoundingBox() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Box3();\\n\\n\\n  \\t\\t\\ttarget.set(this.center, this.center);\\n  \\t\\t\\ttarget.expandByScalar(this.radius);\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "isEmpty",\\n  \\t\\tvalue: function isEmpty() {\\n\\n  \\t\\t\\treturn this.radius <= 0;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "translate",\\n  \\t\\tvalue: function translate(offset) {\\n\\n  \\t\\t\\tthis.center.add(offset);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clampPoint",\\n  \\t\\tvalue: function clampPoint(p) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar deltaLengthSq = this.center.distanceToSquared(p);\\n\\n  \\t\\t\\ttarget.copy(p);\\n\\n  \\t\\t\\tif (deltaLengthSq > this.radius * this.radius) {\\n\\n  \\t\\t\\t\\ttarget.sub(this.center).normalize();\\n  \\t\\t\\t\\ttarget.multiplyScalar(this.radius).add(this.center);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceToPoint",\\n  \\t\\tvalue: function distanceToPoint(p) {\\n\\n  \\t\\t\\treturn p.distanceTo(this.center) - this.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "containsPoint",\\n  \\t\\tvalue: function containsPoint(p) {\\n\\n  \\t\\t\\treturn p.distanceToSquared(this.center) <= this.radius * this.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsSphere",\\n  \\t\\tvalue: function intersectsSphere(s) {\\n\\n  \\t\\t\\tvar radiusSum = this.radius + s.radius;\\n\\n  \\t\\t\\treturn s.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsBox",\\n  \\t\\tvalue: function intersectsBox(b) {\\n\\n  \\t\\t\\treturn b.intersectsSphere(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsPlane",\\n  \\t\\tvalue: function intersectsPlane(p) {\\n\\n  \\t\\t\\treturn Math.abs(p.distanceToPoint(this.center)) <= this.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(s) {\\n\\n  \\t\\t\\treturn s.center.equals(this.center) && s.radius === this.radius;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Sphere;\\n  }();\\n\\n  var Vector2 = function () {\\n  \\tfunction Vector2() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tclassCallCheck(this, Vector2);\\n\\n\\n  \\t\\tthis.x = x;\\n\\n  \\t\\tthis.y = y;\\n  \\t}\\n\\n  \\tcreateClass(Vector2, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(x, y) {\\n\\n  \\t\\t\\tthis.x = x;\\n  \\t\\t\\tthis.y = y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(v) {\\n\\n  \\t\\t\\tthis.x = v.x;\\n  \\t\\t\\tthis.y = v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor(this.x, this.y);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "fromArray",\\n  \\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tthis.x = array[offset];\\n  \\t\\t\\tthis.y = array[offset + 1];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "toArray",\\n  \\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tarray[offset] = this.x;\\n  \\t\\t\\tarray[offset + 1] = this.y;\\n\\n  \\t\\t\\treturn array;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "add",\\n  \\t\\tvalue: function add(v) {\\n\\n  \\t\\t\\tthis.x += v.x;\\n  \\t\\t\\tthis.y += v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "addScalar",\\n  \\t\\tvalue: function addScalar(s) {\\n\\n  \\t\\t\\tthis.x += s;\\n  \\t\\t\\tthis.y += s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "addVectors",\\n  \\t\\tvalue: function addVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x + b.x;\\n  \\t\\t\\tthis.y = a.y + b.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "addScaledVector",\\n  \\t\\tvalue: function addScaledVector(v, s) {\\n\\n  \\t\\t\\tthis.x += v.x * s;\\n  \\t\\t\\tthis.y += v.y * s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "sub",\\n  \\t\\tvalue: function sub(v) {\\n\\n  \\t\\t\\tthis.x -= v.x;\\n  \\t\\t\\tthis.y -= v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "subScalar",\\n  \\t\\tvalue: function subScalar(s) {\\n\\n  \\t\\t\\tthis.x -= s;\\n  \\t\\t\\tthis.y -= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "subVectors",\\n  \\t\\tvalue: function subVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x - b.x;\\n  \\t\\t\\tthis.y = a.y - b.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "multiply",\\n  \\t\\tvalue: function multiply(v) {\\n\\n  \\t\\t\\tthis.x *= v.x;\\n  \\t\\t\\tthis.y *= v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "multiplyScalar",\\n  \\t\\tvalue: function multiplyScalar(s) {\\n\\n  \\t\\t\\tthis.x *= s;\\n  \\t\\t\\tthis.y *= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "divide",\\n  \\t\\tvalue: function divide(v) {\\n\\n  \\t\\t\\tthis.x /= v.x;\\n  \\t\\t\\tthis.y /= v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "divideScalar",\\n  \\t\\tvalue: function divideScalar(s) {\\n\\n  \\t\\t\\tthis.x /= s;\\n  \\t\\t\\tthis.y /= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "applyMatrix3",\\n  \\t\\tvalue: function applyMatrix3(m) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y;\\n  \\t\\t\\tvar e = m.elements;\\n\\n  \\t\\t\\tthis.x = e[0] * x + e[3] * y + e[6];\\n  \\t\\t\\tthis.y = e[1] * x + e[4] * y + e[7];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "dot",\\n  \\t\\tvalue: function dot(v) {\\n\\n  \\t\\t\\treturn this.x * v.x + this.y * v.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "manhattanLength",\\n  \\t\\tvalue: function manhattanLength() {\\n\\n  \\t\\t\\treturn Math.abs(this.x) + Math.abs(this.y);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lengthSquared",\\n  \\t\\tvalue: function lengthSquared() {\\n\\n  \\t\\t\\treturn this.x * this.x + this.y * this.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "length",\\n  \\t\\tvalue: function length() {\\n\\n  \\t\\t\\treturn Math.sqrt(this.x * this.x + this.y * this.y);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "manhattanDistanceTo",\\n  \\t\\tvalue: function manhattanDistanceTo(v) {\\n\\n  \\t\\t\\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceToSquared",\\n  \\t\\tvalue: function distanceToSquared(v) {\\n\\n  \\t\\t\\tvar dx = this.x - v.x;\\n  \\t\\t\\tvar dy = this.y - v.y;\\n\\n  \\t\\t\\treturn dx * dx + dy * dy;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceTo",\\n  \\t\\tvalue: function distanceTo(v) {\\n\\n  \\t\\t\\treturn Math.sqrt(this.distanceToSquared(v));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "normalize",\\n  \\t\\tvalue: function normalize() {\\n\\n  \\t\\t\\treturn this.divideScalar(this.length());\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setLength",\\n  \\t\\tvalue: function setLength(length) {\\n\\n  \\t\\t\\treturn this.normalize().multiplyScalar(length);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "min",\\n  \\t\\tvalue: function min(v) {\\n\\n  \\t\\t\\tthis.x = Math.min(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.min(this.y, v.y);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "max",\\n  \\t\\tvalue: function max(v) {\\n\\n  \\t\\t\\tthis.x = Math.max(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.max(this.y, v.y);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clamp",\\n  \\t\\tvalue: function clamp(min, max) {\\n\\n  \\t\\t\\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\\n  \\t\\t\\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "floor",\\n  \\t\\tvalue: function floor() {\\n\\n  \\t\\t\\tthis.x = Math.floor(this.x);\\n  \\t\\t\\tthis.y = Math.floor(this.y);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "ceil",\\n  \\t\\tvalue: function ceil() {\\n\\n  \\t\\t\\tthis.x = Math.ceil(this.x);\\n  \\t\\t\\tthis.y = Math.ceil(this.y);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "round",\\n  \\t\\tvalue: function round() {\\n\\n  \\t\\t\\tthis.x = Math.round(this.x);\\n  \\t\\t\\tthis.y = Math.round(this.y);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "negate",\\n  \\t\\tvalue: function negate() {\\n\\n  \\t\\t\\tthis.x = -this.x;\\n  \\t\\t\\tthis.y = -this.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "angle",\\n  \\t\\tvalue: function angle() {\\n\\n  \\t\\t\\tvar angle = Math.atan2(this.y, this.x);\\n\\n  \\t\\t\\tif (angle < 0) {\\n\\n  \\t\\t\\t\\tangle += 2 * Math.PI;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn angle;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lerp",\\n  \\t\\tvalue: function lerp(v, alpha) {\\n\\n  \\t\\t\\tthis.x += (v.x - this.x) * alpha;\\n  \\t\\t\\tthis.y += (v.y - this.y) * alpha;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lerpVectors",\\n  \\t\\tvalue: function lerpVectors(v1, v2, alpha) {\\n\\n  \\t\\t\\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "rotateAround",\\n  \\t\\tvalue: function rotateAround(center, angle) {\\n\\n  \\t\\t\\tvar c = Math.cos(angle),\\n  \\t\\t\\t    s = Math.sin(angle);\\n\\n  \\t\\t\\tvar x = this.x - center.x;\\n  \\t\\t\\tvar y = this.y - center.y;\\n\\n  \\t\\t\\tthis.x = x * c - y * s + center.x;\\n  \\t\\t\\tthis.y = x * s + y * c + center.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(v) {\\n\\n  \\t\\t\\treturn v.x === this.x && v.y === this.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "width",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn this.x;\\n  \\t\\t},\\n  \\t\\tset: function set$$1(value) {\\n\\n  \\t\\t\\treturn this.x = value;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "height",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn this.y;\\n  \\t\\t},\\n  \\t\\tset: function set$$1(value) {\\n\\n  \\t\\t\\treturn this.y = value;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Vector2;\\n  }();\\n\\n  var v$1 = new Vector2();\\n\\n  var Box2 = function () {\\n  \\tfunction Box2() {\\n  \\t\\tvar min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2(Infinity, Infinity);\\n  \\t\\tvar max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2(-Infinity, -Infinity);\\n  \\t\\tclassCallCheck(this, Box2);\\n\\n\\n  \\t\\tthis.min = min;\\n\\n  \\t\\tthis.max = max;\\n  \\t}\\n\\n  \\tcreateClass(Box2, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(min, max) {\\n\\n  \\t\\t\\tthis.min.copy(min);\\n  \\t\\t\\tthis.max.copy(max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(b) {\\n\\n  \\t\\t\\tthis.min.copy(b.min);\\n  \\t\\t\\tthis.max.copy(b.max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "makeEmpty",\\n  \\t\\tvalue: function makeEmpty() {\\n\\n  \\t\\t\\tthis.min.x = this.min.y = Infinity;\\n  \\t\\t\\tthis.max.x = this.max.y = -Infinity;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "isEmpty",\\n  \\t\\tvalue: function isEmpty() {\\n\\n  \\t\\t\\treturn this.max.x < this.min.x || this.max.y < this.min.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getCenter",\\n  \\t\\tvalue: function getCenter() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();\\n\\n\\n  \\t\\t\\treturn !this.isEmpty() ? target.addVectors(this.min, this.max).multiplyScalar(0.5) : target.set(0, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getSize",\\n  \\t\\tvalue: function getSize() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();\\n\\n\\n  \\t\\t\\treturn !this.isEmpty() ? target.subVectors(this.max, this.min) : target.set(0, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getBoundingSphere",\\n  \\t\\tvalue: function getBoundingSphere() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Sphere();\\n\\n\\n  \\t\\t\\tthis.getCenter(target.center);\\n\\n  \\t\\t\\ttarget.radius = this.getSize(v$1).length() * 0.5;\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "expandByPoint",\\n  \\t\\tvalue: function expandByPoint(p) {\\n\\n  \\t\\t\\tthis.min.min(p);\\n  \\t\\t\\tthis.max.max(p);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "expandByVector",\\n  \\t\\tvalue: function expandByVector(v) {\\n\\n  \\t\\t\\tthis.min.sub(v);\\n  \\t\\t\\tthis.max.add(v);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "expandByScalar",\\n  \\t\\tvalue: function expandByScalar(s) {\\n\\n  \\t\\t\\tthis.min.addScalar(-s);\\n  \\t\\t\\tthis.max.addScalar(s);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromPoints",\\n  \\t\\tvalue: function setFromPoints(points) {\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\tthis.min.set(0, 0);\\n  \\t\\t\\tthis.max.set(0, 0);\\n\\n  \\t\\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tthis.expandByPoint(points[i]);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromCenterAndSize",\\n  \\t\\tvalue: function setFromCenterAndSize(center, size) {\\n\\n  \\t\\t\\tvar halfSize = v$1.copy(size).multiplyScalar(0.5);\\n\\n  \\t\\t\\tthis.min.copy(center).sub(halfSize);\\n  \\t\\t\\tthis.max.copy(center).add(halfSize);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clampPoint",\\n  \\t\\tvalue: function clampPoint(point) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();\\n\\n\\n  \\t\\t\\treturn target.copy(point).clamp(this.min, this.max);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceToPoint",\\n  \\t\\tvalue: function distanceToPoint(p) {\\n\\n  \\t\\t\\tvar clampedPoint = v$1.copy(p).clamp(this.min, this.max);\\n\\n  \\t\\t\\treturn clampedPoint.sub(p).length();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "translate",\\n  \\t\\tvalue: function translate(offset) {\\n\\n  \\t\\t\\tthis.min.add(offset);\\n  \\t\\t\\tthis.max.add(offset);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersect",\\n  \\t\\tvalue: function intersect(b) {\\n\\n  \\t\\t\\tthis.min.max(b.min);\\n  \\t\\t\\tthis.max.min(b.max);\\n\\n  \\t\\t\\tif (this.isEmpty()) {\\n\\n  \\t\\t\\t\\tthis.makeEmpty();\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "union",\\n  \\t\\tvalue: function union(b) {\\n\\n  \\t\\t\\tthis.min.min(b.min);\\n  \\t\\t\\tthis.max.max(b.max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "containsPoint",\\n  \\t\\tvalue: function containsPoint(p) {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar max = this.max;\\n\\n  \\t\\t\\treturn p.x >= min.x && p.y >= min.y && p.x <= max.x && p.y <= max.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "containsBox",\\n  \\t\\tvalue: function containsBox(b) {\\n\\n  \\t\\t\\tvar tMin = this.min;\\n  \\t\\t\\tvar tMax = this.max;\\n  \\t\\t\\tvar bMin = b.min;\\n  \\t\\t\\tvar bMax = b.max;\\n\\n  \\t\\t\\treturn tMin.x <= bMin.x && bMax.x <= tMax.x && tMin.y <= bMin.y && bMax.y <= tMax.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsBox",\\n  \\t\\tvalue: function intersectsBox(b) {\\n\\n  \\t\\t\\tvar tMin = this.min;\\n  \\t\\t\\tvar tMax = this.max;\\n  \\t\\t\\tvar bMin = b.min;\\n  \\t\\t\\tvar bMax = b.max;\\n\\n  \\t\\t\\treturn bMax.x >= tMin.x && bMax.y >= tMin.y && bMin.x <= tMax.x && bMin.y <= tMax.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(b) {\\n\\n  \\t\\t\\treturn b.min.equals(this.min) && b.max.equals(this.max);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Box2;\\n  }();\\n\\n  var Cylindrical = function () {\\n  \\tfunction Cylindrical() {\\n  \\t\\tvar radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n  \\t\\tvar theta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tclassCallCheck(this, Cylindrical);\\n\\n\\n  \\t\\tthis.radius = radius;\\n\\n  \\t\\tthis.theta = theta;\\n\\n  \\t\\tthis.y = y;\\n  \\t}\\n\\n  \\tcreateClass(Cylindrical, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(radius, theta, y) {\\n\\n  \\t\\t\\tthis.radius = radius;\\n  \\t\\t\\tthis.theta = theta;\\n  \\t\\t\\tthis.y = y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(c) {\\n\\n  \\t\\t\\tthis.radius = c.radius;\\n  \\t\\t\\tthis.theta = c.theta;\\n  \\t\\t\\tthis.y = c.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromVector3",\\n  \\t\\tvalue: function setFromVector3(v) {\\n\\n  \\t\\t\\tthis.radius = Math.sqrt(v.x * v.x + v.z * v.z);\\n  \\t\\t\\tthis.theta = Math.atan2(v.x, v.z);\\n  \\t\\t\\tthis.y = v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Cylindrical;\\n  }();\\n\\n  var Matrix3 = function () {\\n  \\t\\tfunction Matrix3() {\\n  \\t\\t\\t\\tclassCallCheck(this, Matrix3);\\n\\n\\n  \\t\\t\\t\\tthis.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Matrix3, [{\\n  \\t\\t\\t\\tkey: "set",\\n  \\t\\t\\t\\tvalue: function set$$1(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = m00;te[3] = m01;te[6] = m02;\\n  \\t\\t\\t\\t\\t\\tte[1] = m10;te[4] = m11;te[7] = m12;\\n  \\t\\t\\t\\t\\t\\tte[2] = m20;te[5] = m21;te[8] = m22;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "identity",\\n  \\t\\t\\t\\tvalue: function identity() {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "copy",\\n  \\t\\t\\t\\tvalue: function copy(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = me[0];te[1] = me[1];te[2] = me[2];\\n  \\t\\t\\t\\t\\t\\tte[3] = me[3];te[4] = me[4];te[5] = me[5];\\n  \\t\\t\\t\\t\\t\\tte[6] = me[6];te[7] = me[7];te[8] = me[8];\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "clone",\\n  \\t\\t\\t\\tvalue: function clone() {\\n\\n  \\t\\t\\t\\t\\t\\treturn new this.constructor().fromArray(this.elements);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "fromArray",\\n  \\t\\t\\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\t\\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; i < 9; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[i] = array[i + offset];\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "toArray",\\n  \\t\\t\\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\t\\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\t\\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; i < 9; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tarray[i + offset] = te[i];\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn array;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "multiplyMatrices",\\n  \\t\\t\\t\\tvalue: function multiplyMatrices(a, b) {\\n\\n  \\t\\t\\t\\t\\t\\tvar ae = a.elements;\\n  \\t\\t\\t\\t\\t\\tvar be = b.elements;\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar a11 = ae[0],\\n  \\t\\t\\t\\t\\t\\t    a12 = ae[3],\\n  \\t\\t\\t\\t\\t\\t    a13 = ae[6];\\n  \\t\\t\\t\\t\\t\\tvar a21 = ae[1],\\n  \\t\\t\\t\\t\\t\\t    a22 = ae[4],\\n  \\t\\t\\t\\t\\t\\t    a23 = ae[7];\\n  \\t\\t\\t\\t\\t\\tvar a31 = ae[2],\\n  \\t\\t\\t\\t\\t\\t    a32 = ae[5],\\n  \\t\\t\\t\\t\\t\\t    a33 = ae[8];\\n\\n  \\t\\t\\t\\t\\t\\tvar b11 = be[0],\\n  \\t\\t\\t\\t\\t\\t    b12 = be[3],\\n  \\t\\t\\t\\t\\t\\t    b13 = be[6];\\n  \\t\\t\\t\\t\\t\\tvar b21 = be[1],\\n  \\t\\t\\t\\t\\t\\t    b22 = be[4],\\n  \\t\\t\\t\\t\\t\\t    b23 = be[7];\\n  \\t\\t\\t\\t\\t\\tvar b31 = be[2],\\n  \\t\\t\\t\\t\\t\\t    b32 = be[5],\\n  \\t\\t\\t\\t\\t\\t    b33 = be[8];\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = a11 * b11 + a12 * b21 + a13 * b31;\\n  \\t\\t\\t\\t\\t\\tte[3] = a11 * b12 + a12 * b22 + a13 * b32;\\n  \\t\\t\\t\\t\\t\\tte[6] = a11 * b13 + a12 * b23 + a13 * b33;\\n\\n  \\t\\t\\t\\t\\t\\tte[1] = a21 * b11 + a22 * b21 + a23 * b31;\\n  \\t\\t\\t\\t\\t\\tte[4] = a21 * b12 + a22 * b22 + a23 * b32;\\n  \\t\\t\\t\\t\\t\\tte[7] = a21 * b13 + a22 * b23 + a23 * b33;\\n\\n  \\t\\t\\t\\t\\t\\tte[2] = a31 * b11 + a32 * b21 + a33 * b31;\\n  \\t\\t\\t\\t\\t\\tte[5] = a31 * b12 + a32 * b22 + a33 * b32;\\n  \\t\\t\\t\\t\\t\\tte[8] = a31 * b13 + a32 * b23 + a33 * b33;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "multiply",\\n  \\t\\t\\t\\tvalue: function multiply(m) {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.multiplyMatrices(this, m);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "premultiply",\\n  \\t\\t\\t\\tvalue: function premultiply(m) {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.multiplyMatrices(m, this);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "multiplyScalar",\\n  \\t\\t\\t\\tvalue: function multiplyScalar(s) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] *= s;te[3] *= s;te[6] *= s;\\n  \\t\\t\\t\\t\\t\\tte[1] *= s;te[4] *= s;te[7] *= s;\\n  \\t\\t\\t\\t\\t\\tte[2] *= s;te[5] *= s;te[8] *= s;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "determinant",\\n  \\t\\t\\t\\tvalue: function determinant() {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar a = te[0],\\n  \\t\\t\\t\\t\\t\\t    b = te[1],\\n  \\t\\t\\t\\t\\t\\t    c = te[2];\\n  \\t\\t\\t\\t\\t\\tvar d = te[3],\\n  \\t\\t\\t\\t\\t\\t    e = te[4],\\n  \\t\\t\\t\\t\\t\\t    f = te[5];\\n  \\t\\t\\t\\t\\t\\tvar g = te[6],\\n  \\t\\t\\t\\t\\t\\t    h = te[7],\\n  \\t\\t\\t\\t\\t\\t    i = te[8];\\n\\n  \\t\\t\\t\\t\\t\\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "getInverse",\\n  \\t\\t\\t\\tvalue: function getInverse(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar n11 = me[0],\\n  \\t\\t\\t\\t\\t\\t    n21 = me[1],\\n  \\t\\t\\t\\t\\t\\t    n31 = me[2];\\n  \\t\\t\\t\\t\\t\\tvar n12 = me[3],\\n  \\t\\t\\t\\t\\t\\t    n22 = me[4],\\n  \\t\\t\\t\\t\\t\\t    n32 = me[5];\\n  \\t\\t\\t\\t\\t\\tvar n13 = me[6],\\n  \\t\\t\\t\\t\\t\\t    n23 = me[7],\\n  \\t\\t\\t\\t\\t\\t    n33 = me[8];\\n\\n  \\t\\t\\t\\t\\t\\tvar t11 = n33 * n22 - n32 * n23;\\n  \\t\\t\\t\\t\\t\\tvar t12 = n32 * n13 - n33 * n12;\\n  \\t\\t\\t\\t\\t\\tvar t13 = n23 * n12 - n22 * n13;\\n\\n  \\t\\t\\t\\t\\t\\tvar det = n11 * t11 + n21 * t12 + n31 * t13;\\n\\n  \\t\\t\\t\\t\\t\\tvar invDet = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tif (det !== 0) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tinvDet = 1.0 / det;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[0] = t11 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[1] = (n31 * n23 - n33 * n21) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[2] = (n32 * n21 - n31 * n22) * invDet;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[3] = t12 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[4] = (n33 * n11 - n31 * n13) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[5] = (n31 * n12 - n32 * n11) * invDet;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[6] = t13 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[7] = (n21 * n13 - n23 * n11) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[8] = (n22 * n11 - n21 * n12) * invDet;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tconsole.error("Can\\\'t invert matrix, determinant is zero", matrix);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.identity();\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "transpose",\\n  \\t\\t\\t\\tvalue: function transpose() {\\n\\n  \\t\\t\\t\\t\\t\\tvar me = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar t = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tt = me[1];me[1] = me[3];me[3] = t;\\n  \\t\\t\\t\\t\\t\\tt = me[2];me[2] = me[6];me[6] = t;\\n  \\t\\t\\t\\t\\t\\tt = me[5];me[5] = me[7];me[7] = t;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "scale",\\n  \\t\\t\\t\\tvalue: function scale(sx, sy) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] *= sx;te[3] *= sx;te[6] *= sx;\\n  \\t\\t\\t\\t\\t\\tte[1] *= sy;te[4] *= sy;te[7] *= sy;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "rotate",\\n  \\t\\t\\t\\tvalue: function rotate(theta) {\\n\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(theta);\\n  \\t\\t\\t\\t\\t\\tvar s = Math.sin(theta);\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar a11 = te[0],\\n  \\t\\t\\t\\t\\t\\t    a12 = te[3],\\n  \\t\\t\\t\\t\\t\\t    a13 = te[6];\\n  \\t\\t\\t\\t\\t\\tvar a21 = te[1],\\n  \\t\\t\\t\\t\\t\\t    a22 = te[4],\\n  \\t\\t\\t\\t\\t\\t    a23 = te[7];\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = c * a11 + s * a21;\\n  \\t\\t\\t\\t\\t\\tte[3] = c * a12 + s * a22;\\n  \\t\\t\\t\\t\\t\\tte[6] = c * a13 + s * a23;\\n\\n  \\t\\t\\t\\t\\t\\tte[1] = -s * a11 + c * a21;\\n  \\t\\t\\t\\t\\t\\tte[4] = -s * a12 + c * a22;\\n  \\t\\t\\t\\t\\t\\tte[7] = -s * a13 + c * a23;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "translate",\\n  \\t\\t\\t\\tvalue: function translate(tx, ty) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] += tx * te[2];te[3] += tx * te[5];te[6] += tx * te[8];\\n  \\t\\t\\t\\t\\t\\tte[1] += ty * te[2];te[4] += ty * te[5];te[7] += ty * te[8];\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "equals",\\n  \\t\\t\\t\\tvalue: function equals(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar result = true;\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; result && i < 9; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (te[i] !== me[i]) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Matrix3;\\n  }();\\n\\n  var RotationOrder = {\\n\\n    XYZ: 0,\\n    YZX: 1,\\n    ZXY: 2,\\n    XZY: 3,\\n    YXZ: 4,\\n    ZYX: 5\\n\\n  };\\n\\n  var v$2 = new Vector3();\\n\\n  var Quaternion = function () {\\n  \\tfunction Quaternion() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tvar w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\\n  \\t\\tclassCallCheck(this, Quaternion);\\n\\n\\n  \\t\\tthis.x = x;\\n\\n  \\t\\tthis.y = y;\\n\\n  \\t\\tthis.z = z;\\n\\n  \\t\\tthis.w = w;\\n  \\t}\\n\\n  \\tcreateClass(Quaternion, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(x, y, z, w) {\\n\\n  \\t\\t\\tthis.x = x;\\n  \\t\\t\\tthis.y = y;\\n  \\t\\t\\tthis.z = z;\\n  \\t\\t\\tthis.w = w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(q) {\\n\\n  \\t\\t\\tthis.x = q.x;\\n  \\t\\t\\tthis.y = q.y;\\n  \\t\\t\\tthis.z = q.z;\\n  \\t\\t\\tthis.w = q.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor(this.x, this.y, this.z, this.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "fromArray",\\n  \\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tthis.x = array[offset];\\n  \\t\\t\\tthis.y = array[offset + 1];\\n  \\t\\t\\tthis.z = array[offset + 2];\\n  \\t\\t\\tthis.w = array[offset + 3];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "toArray",\\n  \\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tarray[offset] = this.x;\\n  \\t\\t\\tarray[offset + 1] = this.y;\\n  \\t\\t\\tarray[offset + 2] = this.z;\\n  \\t\\t\\tarray[offset + 3] = this.w;\\n\\n  \\t\\t\\treturn array;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromEuler",\\n  \\t\\tvalue: function setFromEuler(euler) {\\n\\n  \\t\\t\\tvar x = euler.x;\\n  \\t\\t\\tvar y = euler.y;\\n  \\t\\t\\tvar z = euler.z;\\n\\n  \\t\\t\\tvar cos = Math.cos;\\n  \\t\\t\\tvar sin = Math.sin;\\n\\n  \\t\\t\\tvar c1 = cos(x / 2);\\n  \\t\\t\\tvar c2 = cos(y / 2);\\n  \\t\\t\\tvar c3 = cos(z / 2);\\n\\n  \\t\\t\\tvar s1 = sin(x / 2);\\n  \\t\\t\\tvar s2 = sin(y / 2);\\n  \\t\\t\\tvar s3 = sin(z / 2);\\n\\n  \\t\\t\\tswitch (euler.order) {\\n\\n  \\t\\t\\t\\tcase RotationOrder.XYZ:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\tcase RotationOrder.YXZ:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\tcase RotationOrder.ZXY:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\tcase RotationOrder.ZYX:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\tcase RotationOrder.YZX:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\tcase RotationOrder.XZY:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromAxisAngle",\\n  \\t\\tvalue: function setFromAxisAngle(axis, angle) {\\n\\n  \\t\\t\\tvar halfAngle = angle / 2.0;\\n  \\t\\t\\tvar s = Math.sin(halfAngle);\\n\\n  \\t\\t\\tthis.x = axis.x * s;\\n  \\t\\t\\tthis.y = axis.y * s;\\n  \\t\\t\\tthis.z = axis.z * s;\\n  \\t\\t\\tthis.w = Math.cos(halfAngle);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromRotationMatrix",\\n  \\t\\tvalue: function setFromRotationMatrix(m) {\\n\\n  \\t\\t\\tvar te = m.elements;\\n\\n  \\t\\t\\tvar m00 = te[0],\\n  \\t\\t\\t    m01 = te[4],\\n  \\t\\t\\t    m02 = te[8];\\n  \\t\\t\\tvar m10 = te[1],\\n  \\t\\t\\t    m11 = te[5],\\n  \\t\\t\\t    m12 = te[9];\\n  \\t\\t\\tvar m20 = te[2],\\n  \\t\\t\\t    m21 = te[6],\\n  \\t\\t\\t    m22 = te[10];\\n\\n  \\t\\t\\tvar trace = m00 + m11 + m22;\\n\\n  \\t\\t\\tvar s = void 0;\\n\\n  \\t\\t\\tif (trace > 0) {\\n\\n  \\t\\t\\t\\ts = 0.5 / Math.sqrt(trace + 1.0);\\n\\n  \\t\\t\\t\\tthis.w = 0.25 / s;\\n  \\t\\t\\t\\tthis.x = (m21 - m12) * s;\\n  \\t\\t\\t\\tthis.y = (m02 - m20) * s;\\n  \\t\\t\\t\\tthis.z = (m10 - m01) * s;\\n  \\t\\t\\t} else if (m00 > m11 && m00 > m22) {\\n\\n  \\t\\t\\t\\ts = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);\\n\\n  \\t\\t\\t\\tthis.w = (m21 - m12) / s;\\n  \\t\\t\\t\\tthis.x = 0.25 * s;\\n  \\t\\t\\t\\tthis.y = (m01 + m10) / s;\\n  \\t\\t\\t\\tthis.z = (m02 + m20) / s;\\n  \\t\\t\\t} else if (m11 > m22) {\\n\\n  \\t\\t\\t\\ts = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);\\n\\n  \\t\\t\\t\\tthis.w = (m02 - m20) / s;\\n  \\t\\t\\t\\tthis.x = (m01 + m10) / s;\\n  \\t\\t\\t\\tthis.y = 0.25 * s;\\n  \\t\\t\\t\\tthis.z = (m12 + m21) / s;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\ts = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);\\n\\n  \\t\\t\\t\\tthis.w = (m10 - m01) / s;\\n  \\t\\t\\t\\tthis.x = (m02 + m20) / s;\\n  \\t\\t\\t\\tthis.y = (m12 + m21) / s;\\n  \\t\\t\\t\\tthis.z = 0.25 * s;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromUnitVectors",\\n  \\t\\tvalue: function setFromUnitVectors(vFrom, vTo) {\\n\\n  \\t\\t\\tvar r = vFrom.dot(vTo) + 1;\\n\\n  \\t\\t\\tif (r < 1e-6) {\\n\\n  \\t\\t\\t\\tr = 0;\\n\\n  \\t\\t\\t\\tif (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\\n\\n  \\t\\t\\t\\t\\tv$2.set(-vFrom.y, vFrom.x, 0);\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tv$2.set(0, -vFrom.z, vFrom.y);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tv$2.crossVectors(vFrom, vTo);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tthis.x = v$2.x;\\n  \\t\\t\\tthis.y = v$2.y;\\n  \\t\\t\\tthis.z = v$2.z;\\n  \\t\\t\\tthis.w = r;\\n\\n  \\t\\t\\treturn this.normalize();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "invert",\\n  \\t\\tvalue: function invert() {\\n\\n  \\t\\t\\treturn this.conjugate().normalize();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "conjugate",\\n  \\t\\tvalue: function conjugate() {\\n\\n  \\t\\t\\tthis.x *= -1;\\n  \\t\\t\\tthis.y *= -1;\\n  \\t\\t\\tthis.z *= -1;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lengthSquared",\\n  \\t\\tvalue: function lengthSquared() {\\n\\n  \\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "length",\\n  \\t\\tvalue: function length() {\\n\\n  \\t\\t\\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "normalize",\\n  \\t\\tvalue: function normalize() {\\n\\n  \\t\\t\\tvar l = this.length();\\n\\n  \\t\\t\\tvar invLength = void 0;\\n\\n  \\t\\t\\tif (l === 0) {\\n\\n  \\t\\t\\t\\tthis.x = 0;\\n  \\t\\t\\t\\tthis.y = 0;\\n  \\t\\t\\t\\tthis.z = 0;\\n  \\t\\t\\t\\tthis.w = 1;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tinvLength = 1.0 / l;\\n\\n  \\t\\t\\t\\tthis.x = this.x * invLength;\\n  \\t\\t\\t\\tthis.y = this.y * invLength;\\n  \\t\\t\\t\\tthis.z = this.z * invLength;\\n  \\t\\t\\t\\tthis.w = this.w * invLength;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "dot",\\n  \\t\\tvalue: function dot(v) {\\n\\n  \\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "multiplyQuaternions",\\n  \\t\\tvalue: function multiplyQuaternions(a, b) {\\n\\n  \\t\\t\\tvar qax = a.x,\\n  \\t\\t\\t    qay = a.y,\\n  \\t\\t\\t    qaz = a.z,\\n  \\t\\t\\t    qaw = a.w;\\n  \\t\\t\\tvar qbx = b.x,\\n  \\t\\t\\t    qby = b.y,\\n  \\t\\t\\t    qbz = b.z,\\n  \\t\\t\\t    qbw = b.w;\\n\\n  \\t\\t\\tthis.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\\n  \\t\\t\\tthis.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\\n  \\t\\t\\tthis.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\n  \\t\\t\\tthis.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "multiply",\\n  \\t\\tvalue: function multiply(q) {\\n\\n  \\t\\t\\treturn this.multiplyQuaternions(this, q);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "premultiply",\\n  \\t\\tvalue: function premultiply(q) {\\n\\n  \\t\\t\\treturn this.multiplyQuaternions(q, this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "slerp",\\n  \\t\\tvalue: function slerp(q, t) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z,\\n  \\t\\t\\t    w = this.w;\\n\\n  \\t\\t\\tvar cosHalfTheta = void 0,\\n  \\t\\t\\t    sinHalfTheta = void 0;\\n  \\t\\t\\tvar halfTheta = void 0,\\n  \\t\\t\\t    ratioA = void 0,\\n  \\t\\t\\t    ratioB = void 0;\\n\\n  \\t\\t\\tif (t === 1) {\\n\\n  \\t\\t\\t\\tthis.copy(q);\\n  \\t\\t\\t} else if (t > 0) {\\n\\n  \\t\\t\\t\\tcosHalfTheta = w * q.w + x * q.x + y * q.y + z * q.z;\\n\\n  \\t\\t\\t\\tif (cosHalfTheta < 0) {\\n\\n  \\t\\t\\t\\t\\tthis.w = -q.w;\\n  \\t\\t\\t\\t\\tthis.x = -q.x;\\n  \\t\\t\\t\\t\\tthis.y = -q.y;\\n  \\t\\t\\t\\t\\tthis.z = -q.z;\\n\\n  \\t\\t\\t\\t\\tcosHalfTheta = -cosHalfTheta;\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tthis.copy(q);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (cosHalfTheta >= 1.0) {\\n\\n  \\t\\t\\t\\t\\tthis.w = w;\\n  \\t\\t\\t\\t\\tthis.x = x;\\n  \\t\\t\\t\\t\\tthis.y = y;\\n  \\t\\t\\t\\t\\tthis.z = z;\\n\\n  \\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tsinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);\\n\\n  \\t\\t\\t\\tif (Math.abs(sinHalfTheta) < 1e-3) {\\n\\n  \\t\\t\\t\\t\\tthis.w = 0.5 * (w + this.w);\\n  \\t\\t\\t\\t\\tthis.x = 0.5 * (x + this.x);\\n  \\t\\t\\t\\t\\tthis.y = 0.5 * (y + this.y);\\n  \\t\\t\\t\\t\\tthis.z = 0.5 * (z + this.z);\\n\\n  \\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\thalfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\\n  \\t\\t\\t\\tratioA = Math.sin((1.0 - t) * halfTheta) / sinHalfTheta;\\n  \\t\\t\\t\\tratioB = Math.sin(t * halfTheta) / sinHalfTheta;\\n\\n  \\t\\t\\t\\tthis.w = w * ratioA + this.w * ratioB;\\n  \\t\\t\\t\\tthis.x = x * ratioA + this.x * ratioB;\\n  \\t\\t\\t\\tthis.y = y * ratioA + this.y * ratioB;\\n  \\t\\t\\t\\tthis.z = z * ratioA + this.z * ratioB;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(q) {\\n\\n  \\t\\t\\treturn q.x === this.x && q.y === this.y && q.z === this.z && q.w === this.w;\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: "slerp",\\n  \\t\\tvalue: function slerp(qa, qb, qr, t) {\\n\\n  \\t\\t\\treturn qr.copy(qa).slerp(qb, t);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "slerpFlat",\\n  \\t\\tvalue: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\\n\\n  \\t\\t\\tvar x1 = src1[srcOffset1];\\n  \\t\\t\\tvar y1 = src1[srcOffset1 + 1];\\n  \\t\\t\\tvar z1 = src1[srcOffset1 + 2];\\n  \\t\\t\\tvar w1 = src1[srcOffset1 + 3];\\n\\n  \\t\\t\\tvar x0 = src0[srcOffset0];\\n  \\t\\t\\tvar y0 = src0[srcOffset0 + 1];\\n  \\t\\t\\tvar z0 = src0[srcOffset0 + 2];\\n  \\t\\t\\tvar w0 = src0[srcOffset0 + 3];\\n\\n  \\t\\t\\tvar s = void 0,\\n  \\t\\t\\t    f = void 0;\\n  \\t\\t\\tvar sin = void 0,\\n  \\t\\t\\t    cos = void 0,\\n  \\t\\t\\t    sqrSin = void 0;\\n  \\t\\t\\tvar dir = void 0,\\n  \\t\\t\\t    len = void 0,\\n  \\t\\t\\t    tDir = void 0;\\n\\n  \\t\\t\\tif (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\\n\\n  \\t\\t\\t\\ts = 1.0 - t;\\n  \\t\\t\\t\\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;\\n\\n  \\t\\t\\t\\tdir = cos >= 0 ? 1 : -1;\\n  \\t\\t\\t\\tsqrSin = 1.0 - cos * cos;\\n\\n  \\t\\t\\t\\tif (sqrSin > Number.EPSILON) {\\n\\n  \\t\\t\\t\\t\\tsin = Math.sqrt(sqrSin);\\n  \\t\\t\\t\\t\\tlen = Math.atan2(sin, cos * dir);\\n\\n  \\t\\t\\t\\t\\ts = Math.sin(s * len) / sin;\\n  \\t\\t\\t\\t\\tt = Math.sin(t * len) / sin;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\ttDir = t * dir;\\n\\n  \\t\\t\\t\\tx0 = x0 * s + x1 * tDir;\\n  \\t\\t\\t\\ty0 = y0 * s + y1 * tDir;\\n  \\t\\t\\t\\tz0 = z0 * s + z1 * tDir;\\n  \\t\\t\\t\\tw0 = w0 * s + w1 * tDir;\\n\\n  \\t\\t\\t\\tif (s === 1.0 - t) {\\n\\n  \\t\\t\\t\\t\\tf = 1.0 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\\n\\n  \\t\\t\\t\\t\\tx0 *= f;\\n  \\t\\t\\t\\t\\ty0 *= f;\\n  \\t\\t\\t\\t\\tz0 *= f;\\n  \\t\\t\\t\\t\\tw0 *= f;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tdst[dstOffset] = x0;\\n  \\t\\t\\tdst[dstOffset + 1] = y0;\\n  \\t\\t\\tdst[dstOffset + 2] = z0;\\n  \\t\\t\\tdst[dstOffset + 3] = w0;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Quaternion;\\n  }();\\n\\n  function clamp(value, min, max) {\\n\\n  \\treturn Math.max(Math.min(value, max), min);\\n  }\\n\\n  var m = new Matrix3();\\n\\n  var q = new Quaternion();\\n\\n  var Euler = function () {\\n  \\tfunction Euler() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tclassCallCheck(this, Euler);\\n\\n\\n  \\t\\tthis.x = x;\\n\\n  \\t\\tthis.y = y;\\n\\n  \\t\\tthis.z = z;\\n\\n  \\t\\tthis.order = Euler.defaultOrder;\\n  \\t}\\n\\n  \\tcreateClass(Euler, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(x, y, z, order) {\\n\\n  \\t\\t\\tthis.x = x;\\n  \\t\\t\\tthis.y = y;\\n  \\t\\t\\tthis.z = z;\\n  \\t\\t\\tthis.order = order;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(e) {\\n\\n  \\t\\t\\tthis.x = e.x;\\n  \\t\\t\\tthis.y = e.y;\\n  \\t\\t\\tthis.z = e.z;\\n  \\t\\t\\tthis.order = e.order;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor(this.x, this.y, this.z, this.order);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "fromArray",\\n  \\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tthis.x = array[offset];\\n  \\t\\t\\tthis.y = array[offset + 1];\\n  \\t\\t\\tthis.z = array[offset + 2];\\n  \\t\\t\\tthis.order = array[offset + 3];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "toArray",\\n  \\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tarray[offset] = this.x;\\n  \\t\\t\\tarray[offset + 1] = this.y;\\n  \\t\\t\\tarray[offset + 2] = this.z;\\n  \\t\\t\\tarray[offset + 3] = this.order;\\n\\n  \\t\\t\\treturn array;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "toVector3",\\n  \\t\\tvalue: function toVector3() {\\n  \\t\\t\\tvar vector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn vector.set(this.x, this.y, this.z);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromRotationMatrix",\\n  \\t\\tvalue: function setFromRotationMatrix(m) {\\n  \\t\\t\\tvar order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.order;\\n\\n\\n  \\t\\t\\tvar te = m.elements;\\n  \\t\\t\\tvar m00 = te[0],\\n  \\t\\t\\t    m01 = te[4],\\n  \\t\\t\\t    m02 = te[8];\\n  \\t\\t\\tvar m10 = te[1],\\n  \\t\\t\\t    m11 = te[5],\\n  \\t\\t\\t    m12 = te[9];\\n  \\t\\t\\tvar m20 = te[2],\\n  \\t\\t\\t    m21 = te[6],\\n  \\t\\t\\t    m22 = te[10];\\n\\n  \\t\\t\\tvar THRESHOLD = 1.0 - 1e-5;\\n\\n  \\t\\t\\tswitch (order) {\\n\\n  \\t\\t\\t\\tcase RotationOrder.XYZ:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.y = Math.asin(clamp(m02, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m02) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(-m12, m22);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(-m01, m00);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(m21, m11);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = 0;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcase RotationOrder.YXZ:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.x = Math.asin(-clamp(m12, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m12) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(m02, m22);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(m10, m11);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(-m20, m00);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = 0;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcase RotationOrder.ZXY:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.x = Math.asin(clamp(m21, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m21) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(-m20, m22);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(-m01, m11);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = 0;\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(m10, m00);\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcase RotationOrder.ZYX:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.y = Math.asin(-clamp(m20, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m20) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(m21, m22);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(m10, m00);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = 0;\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(-m01, m11);\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcase RotationOrder.YZX:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.z = Math.asin(clamp(m10, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m10) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(-m12, m11);\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(-m20, m00);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = 0;\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(m02, m22);\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcase RotationOrder.XZY:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.z = Math.asin(-clamp(m01, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m01) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(m21, m11);\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(m02, m00);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(-m12, m22);\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = 0;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tthis.order = order;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromQuaternion",\\n  \\t\\tvalue: function setFromQuaternion(q, order) {\\n\\n  \\t\\t\\tm.makeRotationFromQuaternion(q);\\n\\n  \\t\\t\\treturn this.setFromRotationMatrix(m, order);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromVector3",\\n  \\t\\tvalue: function setFromVector3(v) {\\n  \\t\\t\\tvar order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.order;\\n\\n\\n  \\t\\t\\treturn this.set(v.x, v.y, v.z, order);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "reorder",\\n  \\t\\tvalue: function reorder(newOrder) {\\n\\n  \\t\\t\\tq.setFromEuler(this);\\n\\n  \\t\\t\\treturn this.setFromQuaternion(q, newOrder);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(e) {\\n\\n  \\t\\t\\treturn e.x === this.x && e.y === this.y && e.z === this.z && e.order === this.order;\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: "defaultOrder",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn RotationOrder.XYZ;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Euler;\\n  }();\\n\\n  var a = new Vector3();\\n\\n  var b = new Vector3();\\n\\n  var Plane = function () {\\n  \\tfunction Plane() {\\n  \\t\\tvar normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(1, 0, 0);\\n  \\t\\tvar constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tclassCallCheck(this, Plane);\\n\\n\\n  \\t\\tthis.normal = normal;\\n\\n  \\t\\tthis.constant = constant;\\n  \\t}\\n\\n  \\tcreateClass(Plane, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(normal, constant) {\\n\\n  \\t\\t\\tthis.normal.copy(normal);\\n  \\t\\t\\tthis.constant = constant;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setComponents",\\n  \\t\\tvalue: function setComponents(x, y, z, w) {\\n\\n  \\t\\t\\tthis.normal.set(x, y, z);\\n  \\t\\t\\tthis.constant = w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(p) {\\n\\n  \\t\\t\\tthis.normal.copy(p.normal);\\n  \\t\\t\\tthis.constant = p.constant;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromNormalAndCoplanarPoint",\\n  \\t\\tvalue: function setFromNormalAndCoplanarPoint(n, p) {\\n\\n  \\t\\t\\tthis.normal.copy(n);\\n  \\t\\t\\tthis.constant = -p.dot(this.normal);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromCoplanarPoints",\\n  \\t\\tvalue: function setFromCoplanarPoints(p0, p1, p2) {\\n\\n  \\t\\t\\tvar normal = a.subVectors(p2, p1).cross(b.subVectors(p0, p1)).normalize();\\n\\n  \\t\\t\\tthis.setFromNormalAndCoplanarPoint(normal, a);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "normalize",\\n  \\t\\tvalue: function normalize() {\\n\\n  \\t\\t\\tvar inverseNormalLength = 1.0 / this.normal.length();\\n\\n  \\t\\t\\tthis.normal.multiplyScalar(inverseNormalLength);\\n  \\t\\t\\tthis.constant *= inverseNormalLength;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "negate",\\n  \\t\\tvalue: function negate() {\\n\\n  \\t\\t\\tthis.normal.negate();\\n  \\t\\t\\tthis.constant = -this.constant;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceToPoint",\\n  \\t\\tvalue: function distanceToPoint(p) {\\n\\n  \\t\\t\\treturn this.normal.dot(p) + this.constant;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceToSphere",\\n  \\t\\tvalue: function distanceToSphere(s) {\\n\\n  \\t\\t\\treturn this.distanceToPoint(s.center) - s.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "projectPoint",\\n  \\t\\tvalue: function projectPoint(p, target) {\\n\\n  \\t\\t\\treturn target.copy(this.normal).multiplyScalar(-this.distanceToPoint(p)).add(p);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "coplanarPoint",\\n  \\t\\tvalue: function coplanarPoint(target) {\\n\\n  \\t\\t\\treturn target.copy(this.normal).multiplyScalar(-this.constant);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "translate",\\n  \\t\\tvalue: function translate(offset) {\\n\\n  \\t\\t\\tthis.constant -= offset.dot(this.normal);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectLine",\\n  \\t\\tvalue: function intersectLine(l, target) {\\n\\n  \\t\\t\\tvar direction = l.delta(a);\\n  \\t\\t\\tvar denominator = this.normal.dot(direction);\\n\\n  \\t\\t\\tif (denominator === 0) {\\n  \\t\\t\\t\\tif (this.distanceToPoint(l.start) === 0) {\\n\\n  \\t\\t\\t\\t\\ttarget.copy(l.start);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tvar t = -(l.start.dot(this.normal) + this.constant) / denominator;\\n\\n  \\t\\t\\t\\tif (t >= 0 && t <= 1) {\\n\\n  \\t\\t\\t\\t\\ttarget.copy(direction).multiplyScalar(t).add(l.start);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsLine",\\n  \\t\\tvalue: function intersectsLine(l) {\\n\\n  \\t\\t\\tvar startSign = this.distanceToPoint(l.start);\\n  \\t\\t\\tvar endSign = this.distanceToPoint(l.end);\\n\\n  \\t\\t\\treturn startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsBox",\\n  \\t\\tvalue: function intersectsBox(b) {\\n\\n  \\t\\t\\treturn b.intersectsPlane(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsSphere",\\n  \\t\\tvalue: function intersectsSphere(s) {\\n\\n  \\t\\t\\treturn s.intersectsPlane(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(p) {\\n\\n  \\t\\t\\treturn p.normal.equals(this.normal) && p.constant === this.constant;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Plane;\\n  }();\\n\\n  var v0 = new Vector3();\\n\\n  var v1 = new Vector3();\\n\\n  var Frustum = function () {\\n  \\tfunction Frustum() {\\n  \\t\\tvar p0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Plane();\\n  \\t\\tvar p1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Plane();\\n  \\t\\tvar p2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Plane();\\n  \\t\\tvar p3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Plane();\\n  \\t\\tvar p4 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Plane();\\n  \\t\\tvar p5 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Plane();\\n  \\t\\tclassCallCheck(this, Frustum);\\n\\n\\n  \\t\\tthis.planes = [p0, p1, p2, p3, p4, p5];\\n  \\t}\\n\\n  \\tcreateClass(Frustum, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(p0, p1, p2, p3, p4, p5) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n\\n  \\t\\t\\tplanes[0].copy(p0);\\n  \\t\\t\\tplanes[1].copy(p1);\\n  \\t\\t\\tplanes[2].copy(p2);\\n  \\t\\t\\tplanes[3].copy(p3);\\n  \\t\\t\\tplanes[4].copy(p4);\\n  \\t\\t\\tplanes[5].copy(p5);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(frustum) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n\\n  \\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 6; ++i) {\\n\\n  \\t\\t\\t\\tplanes[i].copy(frustum.planes[i]);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromMatrix",\\n  \\t\\tvalue: function setFromMatrix(m) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n\\n  \\t\\t\\tvar me = m.elements;\\n  \\t\\t\\tvar me0 = me[0],\\n  \\t\\t\\t    me1 = me[1],\\n  \\t\\t\\t    me2 = me[2],\\n  \\t\\t\\t    me3 = me[3];\\n  \\t\\t\\tvar me4 = me[4],\\n  \\t\\t\\t    me5 = me[5],\\n  \\t\\t\\t    me6 = me[6],\\n  \\t\\t\\t    me7 = me[7];\\n  \\t\\t\\tvar me8 = me[8],\\n  \\t\\t\\t    me9 = me[9],\\n  \\t\\t\\t    me10 = me[10],\\n  \\t\\t\\t    me11 = me[11];\\n  \\t\\t\\tvar me12 = me[12],\\n  \\t\\t\\t    me13 = me[13],\\n  \\t\\t\\t    me14 = me[14],\\n  \\t\\t\\t    me15 = me[15];\\n\\n  \\t\\t\\tplanes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\\n  \\t\\t\\tplanes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\\n  \\t\\t\\tplanes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\\n  \\t\\t\\tplanes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\\n  \\t\\t\\tplanes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\\n  \\t\\t\\tplanes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsSphere",\\n  \\t\\tvalue: function intersectsSphere(sphere) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n  \\t\\t\\tvar center = sphere.center;\\n  \\t\\t\\tvar negativeRadius = -sphere.radius;\\n\\n  \\t\\t\\tvar result = true;\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    d = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 6; ++i) {\\n\\n  \\t\\t\\t\\td = planes[i].distanceToPoint(center);\\n\\n  \\t\\t\\t\\tif (d < negativeRadius) {\\n\\n  \\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsBox",\\n  \\t\\tvalue: function intersectsBox(box) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n  \\t\\t\\tvar min = box.min;\\n  \\t\\t\\tvar max = box.max;\\n\\n  \\t\\t\\tvar result = true;\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    d0 = void 0,\\n  \\t\\t\\t    d1 = void 0;\\n  \\t\\t\\tvar plane = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 6; ++i) {\\n\\n  \\t\\t\\t\\tplane = planes[i];\\n\\n  \\t\\t\\t\\tv0.x = plane.normal.x > 0 ? min.x : max.x;\\n  \\t\\t\\t\\tv1.x = plane.normal.x > 0 ? max.x : min.x;\\n  \\t\\t\\t\\tv0.y = plane.normal.y > 0 ? min.y : max.y;\\n  \\t\\t\\t\\tv1.y = plane.normal.y > 0 ? max.y : min.y;\\n  \\t\\t\\t\\tv0.z = plane.normal.z > 0 ? min.z : max.z;\\n  \\t\\t\\t\\tv1.z = plane.normal.z > 0 ? max.z : min.z;\\n\\n  \\t\\t\\t\\td0 = plane.distanceToPoint(v0);\\n  \\t\\t\\t\\td1 = plane.distanceToPoint(v1);\\n\\n  \\t\\t\\t\\tif (d0 < 0 && d1 < 0) {\\n\\n  \\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "containsPoint",\\n  \\t\\tvalue: function containsPoint(point) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n\\n  \\t\\t\\tvar result = true;\\n  \\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 6; ++i) {\\n\\n  \\t\\t\\t\\tif (planes[i].distanceToPoint(point) < 0) {\\n\\n  \\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Frustum;\\n  }();\\n\\n  var a$1 = new Vector3();\\n\\n  var b$1 = new Vector3();\\n\\n  var Line3 = function () {\\n  \\tfunction Line3() {\\n  \\t\\tvar start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\tvar end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n  \\t\\tclassCallCheck(this, Line3);\\n\\n\\n  \\t\\tthis.start = start;\\n\\n  \\t\\tthis.end = end;\\n  \\t}\\n\\n  \\tcreateClass(Line3, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(start, end) {\\n\\n  \\t\\t\\tthis.start.copy(start);\\n  \\t\\t\\tthis.end.copy(end);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(l) {\\n\\n  \\t\\t\\tthis.start.copy(l.start);\\n  \\t\\t\\tthis.end.copy(l.end);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getCenter",\\n  \\t\\tvalue: function getCenter() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.addVectors(this.start, this.end).multiplyScalar(0.5);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "delta",\\n  \\t\\tvalue: function delta() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.subVectors(this.end, this.start);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lengthSquared",\\n  \\t\\tvalue: function lengthSquared() {\\n\\n  \\t\\t\\treturn this.start.distanceToSquared(this.end);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "length",\\n  \\t\\tvalue: function length() {\\n\\n  \\t\\t\\treturn this.start.distanceTo(this.end);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "at",\\n  \\t\\tvalue: function at(d, target) {\\n\\n  \\t\\t\\treturn this.delta(target).multiplyScalar(d).add(this.start);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "closestPointToPointParameter",\\n  \\t\\tvalue: function closestPointToPointParameter(p, clampToLine) {\\n\\n  \\t\\t\\ta$1.subVectors(p, this.start);\\n  \\t\\t\\tb$1.subVectors(this.end, this.start);\\n\\n  \\t\\t\\tvar bb = b$1.dot(b$1);\\n  \\t\\t\\tvar ba = b$1.dot(a$1);\\n\\n  \\t\\t\\tvar t = clampToLine ? Math.min(Math.max(ba / bb, 0), 1) : ba / bb;\\n\\n  \\t\\t\\treturn t;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "closestPointToPoint",\\n  \\t\\tvalue: function closestPointToPoint(p) {\\n  \\t\\t\\tvar clampToLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n  \\t\\t\\tvar target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\\n\\n\\n  \\t\\t\\tvar t = this.closestPointToPointParameter(p, clampToLine);\\n\\n  \\t\\t\\treturn this.delta(target).multiplyScalar(t).add(this.start);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(l) {\\n\\n  \\t\\t\\treturn l.start.equals(this.start) && l.end.equals(this.end);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Line3;\\n  }();\\n\\n  var a$2 = new Vector3();\\n\\n  var b$2 = new Vector3();\\n\\n  var c = new Vector3();\\n\\n  var Matrix4 = function () {\\n  \\t\\tfunction Matrix4() {\\n  \\t\\t\\t\\tclassCallCheck(this, Matrix4);\\n\\n\\n  \\t\\t\\t\\tthis.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Matrix4, [{\\n  \\t\\t\\t\\tkey: "set",\\n  \\t\\t\\t\\tvalue: function set$$1(n00, n01, n02, n03, n10, n11, n12, n13, n20, n21, n22, n23, n30, n31, n32, n33) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = n00;te[4] = n01;te[8] = n02;te[12] = n03;\\n  \\t\\t\\t\\t\\t\\tte[1] = n10;te[5] = n11;te[9] = n12;te[13] = n13;\\n  \\t\\t\\t\\t\\t\\tte[2] = n20;te[6] = n21;te[10] = n22;te[14] = n23;\\n  \\t\\t\\t\\t\\t\\tte[3] = n30;te[7] = n31;te[11] = n32;te[15] = n33;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "identity",\\n  \\t\\t\\t\\tvalue: function identity() {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "copy",\\n  \\t\\t\\t\\tvalue: function copy(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = me[0];te[1] = me[1];te[2] = me[2];te[3] = me[3];\\n  \\t\\t\\t\\t\\t\\tte[4] = me[4];te[5] = me[5];te[6] = me[6];te[7] = me[7];\\n  \\t\\t\\t\\t\\t\\tte[8] = me[8];te[9] = me[9];te[10] = me[10];te[11] = me[11];\\n  \\t\\t\\t\\t\\t\\tte[12] = me[12];te[13] = me[13];te[14] = me[14];te[15] = me[15];\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "clone",\\n  \\t\\t\\t\\tvalue: function clone() {\\n\\n  \\t\\t\\t\\t\\t\\treturn new this.constructor().fromArray(this.elements);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "fromArray",\\n  \\t\\t\\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\t\\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; i < 16; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[i] = array[i + offset];\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "toArray",\\n  \\t\\t\\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\t\\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\t\\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; i < 16; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tarray[i + offset] = te[i];\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn array;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "getMaxScaleOnAxis",\\n  \\t\\t\\t\\tvalue: function getMaxScaleOnAxis() {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\\n  \\t\\t\\t\\t\\t\\tvar scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\\n  \\t\\t\\t\\t\\t\\tvar scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\\n\\n  \\t\\t\\t\\t\\t\\treturn Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "copyPosition",\\n  \\t\\t\\t\\tvalue: function copyPosition(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[12] = me[12];\\n  \\t\\t\\t\\t\\t\\tte[13] = me[13];\\n  \\t\\t\\t\\t\\t\\tte[14] = me[14];\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "setPosition",\\n  \\t\\t\\t\\tvalue: function setPosition(p) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[12] = p.x;\\n  \\t\\t\\t\\t\\t\\tte[13] = p.y;\\n  \\t\\t\\t\\t\\t\\tte[14] = p.z;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "extractBasis",\\n  \\t\\t\\t\\tvalue: function extractBasis(xAxis, yAxis, zAxis) {\\n\\n  \\t\\t\\t\\t\\t\\txAxis.setFromMatrixColumn(this, 0);\\n  \\t\\t\\t\\t\\t\\tyAxis.setFromMatrixColumn(this, 1);\\n  \\t\\t\\t\\t\\t\\tzAxis.setFromMatrixColumn(this, 2);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makeBasis",\\n  \\t\\t\\t\\tvalue: function makeBasis(xAxis, yAxis, zAxis) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "extractRotation",\\n  \\t\\t\\t\\tvalue: function extractRotation(m) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar me = m.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar scaleX = 1.0 / a$2.setFromMatrixColumn(m, 0).length();\\n  \\t\\t\\t\\t\\t\\tvar scaleY = 1.0 / a$2.setFromMatrixColumn(m, 1).length();\\n  \\t\\t\\t\\t\\t\\tvar scaleZ = 1.0 / a$2.setFromMatrixColumn(m, 2).length();\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = me[0] * scaleX;\\n  \\t\\t\\t\\t\\t\\tte[1] = me[1] * scaleX;\\n  \\t\\t\\t\\t\\t\\tte[2] = me[2] * scaleX;\\n\\n  \\t\\t\\t\\t\\t\\tte[4] = me[4] * scaleY;\\n  \\t\\t\\t\\t\\t\\tte[5] = me[5] * scaleY;\\n  \\t\\t\\t\\t\\t\\tte[6] = me[6] * scaleY;\\n\\n  \\t\\t\\t\\t\\t\\tte[8] = me[8] * scaleZ;\\n  \\t\\t\\t\\t\\t\\tte[9] = me[9] * scaleZ;\\n  \\t\\t\\t\\t\\t\\tte[10] = me[10] * scaleZ;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makeRotationFromEuler",\\n  \\t\\t\\t\\tvalue: function makeRotationFromEuler(euler) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar x = euler.x;\\n  \\t\\t\\t\\t\\t\\tvar y = euler.y;\\n  \\t\\t\\t\\t\\t\\tvar z = euler.z;\\n\\n  \\t\\t\\t\\t\\t\\tvar a = Math.cos(x),\\n  \\t\\t\\t\\t\\t\\t    b = Math.sin(x);\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(y),\\n  \\t\\t\\t\\t\\t\\t    d = Math.sin(y);\\n  \\t\\t\\t\\t\\t\\tvar e = Math.cos(z),\\n  \\t\\t\\t\\t\\t\\t    f = Math.sin(z);\\n\\n  \\t\\t\\t\\t\\t\\tvar ae = void 0,\\n  \\t\\t\\t\\t\\t\\t    af = void 0,\\n  \\t\\t\\t\\t\\t\\t    be = void 0,\\n  \\t\\t\\t\\t\\t\\t    bf = void 0;\\n  \\t\\t\\t\\t\\t\\tvar ce = void 0,\\n  \\t\\t\\t\\t\\t\\t    cf = void 0,\\n  \\t\\t\\t\\t\\t\\t    de = void 0,\\n  \\t\\t\\t\\t\\t\\t    df = void 0;\\n  \\t\\t\\t\\t\\t\\tvar ac = void 0,\\n  \\t\\t\\t\\t\\t\\t    ad = void 0,\\n  \\t\\t\\t\\t\\t\\t    bc = void 0,\\n  \\t\\t\\t\\t\\t\\t    bd = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tswitch (euler.order) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.XYZ:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tae = a * e, af = a * f, be = b * e, bf = b * f;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = c * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = -c * f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = d;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = af + be * d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = ae - bf * d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = -b * c;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = bf - ae * d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = be + af * d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = a * c;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.YXZ:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tce = c * e, cf = c * f, de = d * e, df = d * f;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = ce + df * b;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = de * b - cf;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = a * d;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = a * f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = a * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = -b;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = cf * b - de;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = df + ce * b;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = a * c;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.ZXY:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tce = c * e, cf = c * f, de = d * e, df = d * f;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = ce - df * b;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = -a * f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = de + cf * b;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = cf + de * b;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = a * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = df - ce * b;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = -a * d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = b;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = a * c;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.ZYX:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tae = a * e, af = a * f, be = b * e, bf = b * f;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = c * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = be * d - af;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = ae * d + bf;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = c * f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = bf * d + ae;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = af * d - be;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = -d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = b * c;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = a * c;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.YZX:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tac = a * c, ad = a * d, bc = b * c, bd = b * d;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = c * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = bd - ac * f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = bc * f + ad;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = a * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = -b * e;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = -d * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = ad * f + bc;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = ac - bd * f;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.XZY:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tac = a * c, ad = a * d, bc = b * c, bd = b * d;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = c * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = -f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = d * e;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = ac * f + bd;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = a * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = ad * f - bc;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = bc * f - ad;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = b * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = bd * f + ac;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tte[3] = 0;\\n  \\t\\t\\t\\t\\t\\tte[7] = 0;\\n  \\t\\t\\t\\t\\t\\tte[11] = 0;\\n\\n  \\t\\t\\t\\t\\t\\tte[12] = 0;\\n  \\t\\t\\t\\t\\t\\tte[13] = 0;\\n  \\t\\t\\t\\t\\t\\tte[14] = 0;\\n  \\t\\t\\t\\t\\t\\tte[15] = 1;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makeRotationFromQuaternion",\\n  \\t\\t\\t\\tvalue: function makeRotationFromQuaternion(q) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar x = q.x,\\n  \\t\\t\\t\\t\\t\\t    y = q.y,\\n  \\t\\t\\t\\t\\t\\t    z = q.z,\\n  \\t\\t\\t\\t\\t\\t    w = q.w;\\n  \\t\\t\\t\\t\\t\\tvar x2 = x + x,\\n  \\t\\t\\t\\t\\t\\t    y2 = y + y,\\n  \\t\\t\\t\\t\\t\\t    z2 = z + z;\\n  \\t\\t\\t\\t\\t\\tvar xx = x * x2,\\n  \\t\\t\\t\\t\\t\\t    xy = x * y2,\\n  \\t\\t\\t\\t\\t\\t    xz = x * z2;\\n  \\t\\t\\t\\t\\t\\tvar yy = y * y2,\\n  \\t\\t\\t\\t\\t\\t    yz = y * z2,\\n  \\t\\t\\t\\t\\t\\t    zz = z * z2;\\n  \\t\\t\\t\\t\\t\\tvar wx = w * x2,\\n  \\t\\t\\t\\t\\t\\t    wy = w * y2,\\n  \\t\\t\\t\\t\\t\\t    wz = w * z2;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = 1 - (yy + zz);\\n  \\t\\t\\t\\t\\t\\tte[4] = xy - wz;\\n  \\t\\t\\t\\t\\t\\tte[8] = xz + wy;\\n\\n  \\t\\t\\t\\t\\t\\tte[1] = xy + wz;\\n  \\t\\t\\t\\t\\t\\tte[5] = 1 - (xx + zz);\\n  \\t\\t\\t\\t\\t\\tte[9] = yz - wx;\\n\\n  \\t\\t\\t\\t\\t\\tte[2] = xz - wy;\\n  \\t\\t\\t\\t\\t\\tte[6] = yz + wx;\\n  \\t\\t\\t\\t\\t\\tte[10] = 1 - (xx + yy);\\n\\n  \\t\\t\\t\\t\\t\\tte[3] = 0;\\n  \\t\\t\\t\\t\\t\\tte[7] = 0;\\n  \\t\\t\\t\\t\\t\\tte[11] = 0;\\n\\n  \\t\\t\\t\\t\\t\\tte[12] = 0;\\n  \\t\\t\\t\\t\\t\\tte[13] = 0;\\n  \\t\\t\\t\\t\\t\\tte[14] = 0;\\n  \\t\\t\\t\\t\\t\\tte[15] = 1;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "lookAt",\\n  \\t\\t\\t\\tvalue: function lookAt(eye, target, up) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar x = a$2,\\n  \\t\\t\\t\\t\\t\\t    y = b$2,\\n  \\t\\t\\t\\t\\t\\t    z = c;\\n\\n  \\t\\t\\t\\t\\t\\tz.subVectors(eye, target);\\n\\n  \\t\\t\\t\\t\\t\\tif (z.lengthSquared() === 0) {\\n  \\t\\t\\t\\t\\t\\t\\t\\tz.z = 1;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tz.normalize();\\n  \\t\\t\\t\\t\\t\\tx.crossVectors(up, z);\\n\\n  \\t\\t\\t\\t\\t\\tif (x.lengthSquared() === 0) {\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (Math.abs(up.z) === 1) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tz.x += 1e-4;\\n  \\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tz.z += 1e-4;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tz.normalize();\\n  \\t\\t\\t\\t\\t\\t\\t\\tx.crossVectors(up, z);\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tx.normalize();\\n  \\t\\t\\t\\t\\t\\ty.crossVectors(z, x);\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = x.x;te[4] = y.x;te[8] = z.x;\\n  \\t\\t\\t\\t\\t\\tte[1] = x.y;te[5] = y.y;te[9] = z.y;\\n  \\t\\t\\t\\t\\t\\tte[2] = x.z;te[6] = y.z;te[10] = z.z;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "multiplyMatrices",\\n  \\t\\t\\t\\tvalue: function multiplyMatrices(a, b) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar ae = a.elements;\\n  \\t\\t\\t\\t\\t\\tvar be = b.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar a00 = ae[0],\\n  \\t\\t\\t\\t\\t\\t    a01 = ae[4],\\n  \\t\\t\\t\\t\\t\\t    a02 = ae[8],\\n  \\t\\t\\t\\t\\t\\t    a03 = ae[12];\\n  \\t\\t\\t\\t\\t\\tvar a10 = ae[1],\\n  \\t\\t\\t\\t\\t\\t    a11 = ae[5],\\n  \\t\\t\\t\\t\\t\\t    a12 = ae[9],\\n  \\t\\t\\t\\t\\t\\t    a13 = ae[13];\\n  \\t\\t\\t\\t\\t\\tvar a20 = ae[2],\\n  \\t\\t\\t\\t\\t\\t    a21 = ae[6],\\n  \\t\\t\\t\\t\\t\\t    a22 = ae[10],\\n  \\t\\t\\t\\t\\t\\t    a23 = ae[14];\\n  \\t\\t\\t\\t\\t\\tvar a30 = ae[3],\\n  \\t\\t\\t\\t\\t\\t    a31 = ae[7],\\n  \\t\\t\\t\\t\\t\\t    a32 = ae[11],\\n  \\t\\t\\t\\t\\t\\t    a33 = ae[15];\\n\\n  \\t\\t\\t\\t\\t\\tvar b00 = be[0],\\n  \\t\\t\\t\\t\\t\\t    b01 = be[4],\\n  \\t\\t\\t\\t\\t\\t    b02 = be[8],\\n  \\t\\t\\t\\t\\t\\t    b03 = be[12];\\n  \\t\\t\\t\\t\\t\\tvar b10 = be[1],\\n  \\t\\t\\t\\t\\t\\t    b11 = be[5],\\n  \\t\\t\\t\\t\\t\\t    b12 = be[9],\\n  \\t\\t\\t\\t\\t\\t    b13 = be[13];\\n  \\t\\t\\t\\t\\t\\tvar b20 = be[2],\\n  \\t\\t\\t\\t\\t\\t    b21 = be[6],\\n  \\t\\t\\t\\t\\t\\t    b22 = be[10],\\n  \\t\\t\\t\\t\\t\\t    b23 = be[14];\\n  \\t\\t\\t\\t\\t\\tvar b30 = be[3],\\n  \\t\\t\\t\\t\\t\\t    b31 = be[7],\\n  \\t\\t\\t\\t\\t\\t    b32 = be[11],\\n  \\t\\t\\t\\t\\t\\t    b33 = be[15];\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\\n  \\t\\t\\t\\t\\t\\tte[4] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\\n  \\t\\t\\t\\t\\t\\tte[8] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\\n  \\t\\t\\t\\t\\t\\tte[12] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\\n\\n  \\t\\t\\t\\t\\t\\tte[1] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\\n  \\t\\t\\t\\t\\t\\tte[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\\n  \\t\\t\\t\\t\\t\\tte[9] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\\n  \\t\\t\\t\\t\\t\\tte[13] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\\n\\n  \\t\\t\\t\\t\\t\\tte[2] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\\n  \\t\\t\\t\\t\\t\\tte[6] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\\n  \\t\\t\\t\\t\\t\\tte[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\\n  \\t\\t\\t\\t\\t\\tte[14] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\\n\\n  \\t\\t\\t\\t\\t\\tte[3] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\\n  \\t\\t\\t\\t\\t\\tte[7] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\\n  \\t\\t\\t\\t\\t\\tte[11] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\\n  \\t\\t\\t\\t\\t\\tte[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "multiply",\\n  \\t\\t\\t\\tvalue: function multiply(m) {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.multiplyMatrices(this, m);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "premultiply",\\n  \\t\\t\\t\\tvalue: function premultiply(m) {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.multiplyMatrices(m, this);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "multiplyScalar",\\n  \\t\\t\\t\\tvalue: function multiplyScalar(s) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] *= s;te[4] *= s;te[8] *= s;te[12] *= s;\\n  \\t\\t\\t\\t\\t\\tte[1] *= s;te[5] *= s;te[9] *= s;te[13] *= s;\\n  \\t\\t\\t\\t\\t\\tte[2] *= s;te[6] *= s;te[10] *= s;te[14] *= s;\\n  \\t\\t\\t\\t\\t\\tte[3] *= s;te[7] *= s;te[11] *= s;te[15] *= s;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "determinant",\\n  \\t\\t\\t\\tvalue: function determinant() {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar n00 = te[0],\\n  \\t\\t\\t\\t\\t\\t    n01 = te[4],\\n  \\t\\t\\t\\t\\t\\t    n02 = te[8],\\n  \\t\\t\\t\\t\\t\\t    n03 = te[12];\\n  \\t\\t\\t\\t\\t\\tvar n10 = te[1],\\n  \\t\\t\\t\\t\\t\\t    n11 = te[5],\\n  \\t\\t\\t\\t\\t\\t    n12 = te[9],\\n  \\t\\t\\t\\t\\t\\t    n13 = te[13];\\n  \\t\\t\\t\\t\\t\\tvar n20 = te[2],\\n  \\t\\t\\t\\t\\t\\t    n21 = te[6],\\n  \\t\\t\\t\\t\\t\\t    n22 = te[10],\\n  \\t\\t\\t\\t\\t\\t    n23 = te[14];\\n  \\t\\t\\t\\t\\t\\tvar n30 = te[3],\\n  \\t\\t\\t\\t\\t\\t    n31 = te[7],\\n  \\t\\t\\t\\t\\t\\t    n32 = te[11],\\n  \\t\\t\\t\\t\\t\\t    n33 = te[15];\\n\\n  \\t\\t\\t\\t\\t\\tvar n00n11 = n00 * n11,\\n  \\t\\t\\t\\t\\t\\t    n00n12 = n00 * n12,\\n  \\t\\t\\t\\t\\t\\t    n00n13 = n00 * n13;\\n  \\t\\t\\t\\t\\t\\tvar n01n10 = n01 * n10,\\n  \\t\\t\\t\\t\\t\\t    n01n12 = n01 * n12,\\n  \\t\\t\\t\\t\\t\\t    n01n13 = n01 * n13;\\n  \\t\\t\\t\\t\\t\\tvar n02n10 = n02 * n10,\\n  \\t\\t\\t\\t\\t\\t    n02n11 = n02 * n11,\\n  \\t\\t\\t\\t\\t\\t    n02n13 = n02 * n13;\\n  \\t\\t\\t\\t\\t\\tvar n03n10 = n03 * n10,\\n  \\t\\t\\t\\t\\t\\t    n03n11 = n03 * n11,\\n  \\t\\t\\t\\t\\t\\t    n03n12 = n03 * n12;\\n\\n  \\t\\t\\t\\t\\t\\treturn n30 * (n03n12 * n21 - n02n13 * n21 - n03n11 * n22 + n01n13 * n22 + n02n11 * n23 - n01n12 * n23) + n31 * (n00n12 * n23 - n00n13 * n22 + n03n10 * n22 - n02n10 * n23 + n02n13 * n20 - n03n12 * n20) + n32 * (n00n13 * n21 - n00n11 * n23 - n03n10 * n21 + n01n10 * n23 + n03n11 * n20 - n01n13 * n20) + n33 * (-n02n11 * n20 - n00n12 * n21 + n00n11 * n22 + n02n10 * n21 - n01n10 * n22 + n01n12 * n20);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "getInverse",\\n  \\t\\t\\t\\tvalue: function getInverse(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar n00 = me[0],\\n  \\t\\t\\t\\t\\t\\t    n10 = me[1],\\n  \\t\\t\\t\\t\\t\\t    n20 = me[2],\\n  \\t\\t\\t\\t\\t\\t    n30 = me[3];\\n  \\t\\t\\t\\t\\t\\tvar n01 = me[4],\\n  \\t\\t\\t\\t\\t\\t    n11 = me[5],\\n  \\t\\t\\t\\t\\t\\t    n21 = me[6],\\n  \\t\\t\\t\\t\\t\\t    n31 = me[7];\\n  \\t\\t\\t\\t\\t\\tvar n02 = me[8],\\n  \\t\\t\\t\\t\\t\\t    n12 = me[9],\\n  \\t\\t\\t\\t\\t\\t    n22 = me[10],\\n  \\t\\t\\t\\t\\t\\t    n32 = me[11];\\n  \\t\\t\\t\\t\\t\\tvar n03 = me[12],\\n  \\t\\t\\t\\t\\t\\t    n13 = me[13],\\n  \\t\\t\\t\\t\\t\\t    n23 = me[14],\\n  \\t\\t\\t\\t\\t\\t    n33 = me[15];\\n\\n  \\t\\t\\t\\t\\t\\tvar t00 = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\\n  \\t\\t\\t\\t\\t\\tvar t01 = n03 * n22 * n31 - n02 * n23 * n31 - n03 * n21 * n32 + n01 * n23 * n32 + n02 * n21 * n33 - n01 * n22 * n33;\\n  \\t\\t\\t\\t\\t\\tvar t02 = n02 * n13 * n31 - n03 * n12 * n31 + n03 * n11 * n32 - n01 * n13 * n32 - n02 * n11 * n33 + n01 * n12 * n33;\\n  \\t\\t\\t\\t\\t\\tvar t03 = n03 * n12 * n21 - n02 * n13 * n21 - n03 * n11 * n22 + n01 * n13 * n22 + n02 * n11 * n23 - n01 * n12 * n23;\\n\\n  \\t\\t\\t\\t\\t\\tvar det = n00 * t00 + n10 * t01 + n20 * t02 + n30 * t03;\\n\\n  \\t\\t\\t\\t\\t\\tvar invDet = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tif (det !== 0) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tinvDet = 1.0 / det;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[0] = t00 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[1] = (n13 * n22 * n30 - n12 * n23 * n30 - n13 * n20 * n32 + n10 * n23 * n32 + n12 * n20 * n33 - n10 * n22 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[2] = (n11 * n23 * n30 - n13 * n21 * n30 + n13 * n20 * n31 - n10 * n23 * n31 - n11 * n20 * n33 + n10 * n21 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[3] = (n12 * n21 * n30 - n11 * n22 * n30 - n12 * n20 * n31 + n10 * n22 * n31 + n11 * n20 * n32 - n10 * n21 * n32) * invDet;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[4] = t01 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[5] = (n02 * n23 * n30 - n03 * n22 * n30 + n03 * n20 * n32 - n00 * n23 * n32 - n02 * n20 * n33 + n00 * n22 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[6] = (n03 * n21 * n30 - n01 * n23 * n30 - n03 * n20 * n31 + n00 * n23 * n31 + n01 * n20 * n33 - n00 * n21 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[7] = (n01 * n22 * n30 - n02 * n21 * n30 + n02 * n20 * n31 - n00 * n22 * n31 - n01 * n20 * n32 + n00 * n21 * n32) * invDet;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[8] = t02 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[9] = (n03 * n12 * n30 - n02 * n13 * n30 - n03 * n10 * n32 + n00 * n13 * n32 + n02 * n10 * n33 - n00 * n12 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[10] = (n01 * n13 * n30 - n03 * n11 * n30 + n03 * n10 * n31 - n00 * n13 * n31 - n01 * n10 * n33 + n00 * n11 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[11] = (n02 * n11 * n30 - n01 * n12 * n30 - n02 * n10 * n31 + n00 * n12 * n31 + n01 * n10 * n32 - n00 * n11 * n32) * invDet;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[12] = t03 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[13] = (n02 * n13 * n20 - n03 * n12 * n20 + n03 * n10 * n22 - n00 * n13 * n22 - n02 * n10 * n23 + n00 * n12 * n23) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[14] = (n03 * n11 * n20 - n01 * n13 * n20 - n03 * n10 * n21 + n00 * n13 * n21 + n01 * n10 * n23 - n00 * n11 * n23) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[15] = (n01 * n12 * n20 - n02 * n11 * n20 + n02 * n10 * n21 - n00 * n12 * n21 - n01 * n10 * n22 + n00 * n11 * n22) * invDet;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tconsole.error("Can\\\'t invert matrix, determinant is zero", matrix);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.identity();\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "transpose",\\n  \\t\\t\\t\\tvalue: function transpose() {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar t = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tt = te[1];te[1] = te[4];te[4] = t;\\n  \\t\\t\\t\\t\\t\\tt = te[2];te[2] = te[8];te[8] = t;\\n  \\t\\t\\t\\t\\t\\tt = te[6];te[6] = te[9];te[9] = t;\\n\\n  \\t\\t\\t\\t\\t\\tt = te[3];te[3] = te[12];te[12] = t;\\n  \\t\\t\\t\\t\\t\\tt = te[7];te[7] = te[13];te[13] = t;\\n  \\t\\t\\t\\t\\t\\tt = te[11];te[11] = te[14];te[14] = t;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "scale",\\n  \\t\\t\\t\\tvalue: function scale(sx, sy, sz) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] *= sx;te[4] *= sy;te[8] *= sz;\\n  \\t\\t\\t\\t\\t\\tte[1] *= sx;te[5] *= sy;te[9] *= sz;\\n  \\t\\t\\t\\t\\t\\tte[2] *= sx;te[6] *= sy;te[10] *= sz;\\n  \\t\\t\\t\\t\\t\\tte[3] *= sx;te[7] *= sy;te[11] *= sz;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makeScale",\\n  \\t\\t\\t\\tvalue: function makeScale(x, y, z) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makeTranslation",\\n  \\t\\t\\t\\tvalue: function makeTranslation(x, y, z) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makeRotationX",\\n  \\t\\t\\t\\tvalue: function makeRotationX(theta) {\\n\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(theta),\\n  \\t\\t\\t\\t\\t\\t    s = Math.sin(theta);\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makeRotationY",\\n  \\t\\t\\t\\tvalue: function makeRotationY(theta) {\\n\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(theta),\\n  \\t\\t\\t\\t\\t\\t    s = Math.sin(theta);\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makeRotationZ",\\n  \\t\\t\\t\\tvalue: function makeRotationZ(theta) {\\n\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(theta),\\n  \\t\\t\\t\\t\\t\\t    s = Math.sin(theta);\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makeRotationAxis",\\n  \\t\\t\\t\\tvalue: function makeRotationAxis(axis, angle) {\\n\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(angle);\\n  \\t\\t\\t\\t\\t\\tvar s = Math.sin(angle);\\n\\n  \\t\\t\\t\\t\\t\\tvar t = 1.0 - c;\\n\\n  \\t\\t\\t\\t\\t\\tvar x = axis.x,\\n  \\t\\t\\t\\t\\t\\t    y = axis.y,\\n  \\t\\t\\t\\t\\t\\t    z = axis.z;\\n  \\t\\t\\t\\t\\t\\tvar tx = t * x,\\n  \\t\\t\\t\\t\\t\\t    ty = t * y;\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makeShear",\\n  \\t\\t\\t\\tvalue: function makeShear(x, y, z) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "compose",\\n  \\t\\t\\t\\tvalue: function compose(position, quaternion, scale) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.makeRotationFromQuaternion(quaternion);\\n  \\t\\t\\t\\t\\t\\tthis.scale(scale.x, scale.y, scale.z);\\n  \\t\\t\\t\\t\\t\\tthis.setPosition(position);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "decompose",\\n  \\t\\t\\t\\tvalue: function decompose(position, quaternion, scale) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar n00 = te[0],\\n  \\t\\t\\t\\t\\t\\t    n10 = te[1],\\n  \\t\\t\\t\\t\\t\\t    n20 = te[2];\\n  \\t\\t\\t\\t\\t\\tvar n01 = te[4],\\n  \\t\\t\\t\\t\\t\\t    n11 = te[5],\\n  \\t\\t\\t\\t\\t\\t    n21 = te[6];\\n  \\t\\t\\t\\t\\t\\tvar n02 = te[8],\\n  \\t\\t\\t\\t\\t\\t    n12 = te[9],\\n  \\t\\t\\t\\t\\t\\t    n22 = te[10];\\n\\n  \\t\\t\\t\\t\\t\\tvar det = this.determinant();\\n\\n  \\t\\t\\t\\t\\t\\tvar sx = a$2.set(n00, n10, n20).length() * (det < 0 ? -1 : 1);\\n  \\t\\t\\t\\t\\t\\tvar sy = a$2.set(n01, n11, n21).length();\\n  \\t\\t\\t\\t\\t\\tvar sz = a$2.set(n02, n12, n22).length();\\n\\n  \\t\\t\\t\\t\\t\\tvar invSX = 1.0 / sx;\\n  \\t\\t\\t\\t\\t\\tvar invSY = 1.0 / sy;\\n  \\t\\t\\t\\t\\t\\tvar invSZ = 1.0 / sz;\\n\\n  \\t\\t\\t\\t\\t\\tposition.x = te[12];\\n  \\t\\t\\t\\t\\t\\tposition.y = te[13];\\n  \\t\\t\\t\\t\\t\\tposition.z = te[14];\\n\\n  \\t\\t\\t\\t\\t\\tte[0] *= invSX;te[1] *= invSX;te[2] *= invSX;\\n  \\t\\t\\t\\t\\t\\tte[4] *= invSY;te[5] *= invSY;te[6] *= invSY;\\n  \\t\\t\\t\\t\\t\\tte[8] *= invSZ;te[9] *= invSZ;te[10] *= invSZ;\\n\\n  \\t\\t\\t\\t\\t\\tquaternion.setFromRotationMatrix(this);\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = n00;te[1] = n10;te[2] = n20;\\n  \\t\\t\\t\\t\\t\\tte[4] = n01;te[5] = n11;te[6] = n21;\\n  \\t\\t\\t\\t\\t\\tte[8] = n02;te[9] = n12;te[10] = n22;\\n\\n  \\t\\t\\t\\t\\t\\tscale.x = sx;\\n  \\t\\t\\t\\t\\t\\tscale.y = sy;\\n  \\t\\t\\t\\t\\t\\tscale.z = sz;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makePerspective",\\n  \\t\\t\\t\\tvalue: function makePerspective(left, right, top, bottom, near, far) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar x = 2 * near / (right - left);\\n  \\t\\t\\t\\t\\t\\tvar y = 2 * near / (top - bottom);\\n\\n  \\t\\t\\t\\t\\t\\tvar a = (right + left) / (right - left);\\n  \\t\\t\\t\\t\\t\\tvar b = (top + bottom) / (top - bottom);\\n  \\t\\t\\t\\t\\t\\tvar c = -(far + near) / (far - near);\\n  \\t\\t\\t\\t\\t\\tvar d = -2 * far * near / (far - near);\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = x;te[4] = 0;te[8] = a;te[12] = 0;\\n  \\t\\t\\t\\t\\t\\tte[1] = 0;te[5] = y;te[9] = b;te[13] = 0;\\n  \\t\\t\\t\\t\\t\\tte[2] = 0;te[6] = 0;te[10] = c;te[14] = d;\\n  \\t\\t\\t\\t\\t\\tte[3] = 0;te[7] = 0;te[11] = -1;te[15] = 0;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "makeOrthographic",\\n  \\t\\t\\t\\tvalue: function makeOrthographic(left, right, top, bottom, near, far) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar w = 1.0 / (right - left);\\n  \\t\\t\\t\\t\\t\\tvar h = 1.0 / (top - bottom);\\n  \\t\\t\\t\\t\\t\\tvar p = 1.0 / (far - near);\\n\\n  \\t\\t\\t\\t\\t\\tvar x = (right + left) * w;\\n  \\t\\t\\t\\t\\t\\tvar y = (top + bottom) * h;\\n  \\t\\t\\t\\t\\t\\tvar z = (far + near) * p;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = 2 * w;te[4] = 0;te[8] = 0;te[12] = -x;\\n  \\t\\t\\t\\t\\t\\tte[1] = 0;te[5] = 2 * h;te[9] = 0;te[13] = -y;\\n  \\t\\t\\t\\t\\t\\tte[2] = 0;te[6] = 0;te[10] = -2 * p;te[14] = -z;\\n  \\t\\t\\t\\t\\t\\tte[3] = 0;te[7] = 0;te[11] = 0;te[15] = 1;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "equals",\\n  \\t\\t\\t\\tvalue: function equals(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar result = true;\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; result && i < 16; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (te[i] !== me[i]) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Matrix4;\\n  }();\\n\\n  var v$3 = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];\\n\\n  var Ray = function () {\\n  \\tfunction Ray() {\\n  \\t\\tvar origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\tvar direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n  \\t\\tclassCallCheck(this, Ray);\\n\\n\\n  \\t\\tthis.origin = origin;\\n\\n  \\t\\tthis.direction = direction;\\n  \\t}\\n\\n  \\tcreateClass(Ray, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(origin, direction) {\\n\\n  \\t\\t\\tthis.origin.copy(origin);\\n  \\t\\t\\tthis.direction.copy(direction);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(r) {\\n\\n  \\t\\t\\tthis.origin.copy(r.origin);\\n  \\t\\t\\tthis.direction.copy(r.direction);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "at",\\n  \\t\\tvalue: function at(t) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.copy(this.direction).multiplyScalar(t).add(this.origin);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lookAt",\\n  \\t\\tvalue: function lookAt(target) {\\n\\n  \\t\\t\\tthis.direction.copy(target).sub(this.origin).normalize();\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "recast",\\n  \\t\\tvalue: function recast(t) {\\n\\n  \\t\\t\\tthis.origin.copy(this.at(t, v$3[0]));\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "closestPointToPoint",\\n  \\t\\tvalue: function closestPointToPoint(p) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar directionDistance = target.subVectors(p, this.origin).dot(this.direction);\\n\\n  \\t\\t\\treturn directionDistance >= 0.0 ? target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin) : target.copy(this.origin);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceSquaredToPoint",\\n  \\t\\tvalue: function distanceSquaredToPoint(p) {\\n\\n  \\t\\t\\tvar directionDistance = v$3[0].subVectors(p, this.origin).dot(this.direction);\\n\\n  \\t\\t\\treturn directionDistance < 0.0 ? this.origin.distanceToSquared(p) : v$3[0].copy(this.direction).multiplyScalar(directionDistance).add(this.origin).distanceToSquared(p);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceToPoint",\\n  \\t\\tvalue: function distanceToPoint(p) {\\n\\n  \\t\\t\\treturn Math.sqrt(this.distanceSquaredToPoint(p));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceToPlane",\\n  \\t\\tvalue: function distanceToPlane(p) {\\n\\n  \\t\\t\\tvar denominator = p.normal.dot(this.direction);\\n\\n  \\t\\t\\tvar t = denominator !== 0.0 ? -(this.origin.dot(p.normal) + p.constant) / denominator : p.distanceToPoint(this.origin) === 0.0 ? 0.0 : -1.0;\\n\\n  \\t\\t\\treturn t >= 0.0 ? t : null;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceSquaredToSegment",\\n  \\t\\tvalue: function distanceSquaredToSegment(v0, v1, pointOnRay, pointOnSegment) {\\n\\n  \\t\\t\\tvar segCenter = v$3[0].copy(v0).add(v1).multiplyScalar(0.5);\\n  \\t\\t\\tvar segDir = v$3[1].copy(v1).sub(v0).normalize();\\n  \\t\\t\\tvar diff = v$3[2].copy(this.origin).sub(segCenter);\\n\\n  \\t\\t\\tvar segExtent = v0.distanceTo(v1) * 0.5;\\n  \\t\\t\\tvar a01 = -this.direction.dot(segDir);\\n  \\t\\t\\tvar b0 = diff.dot(this.direction);\\n  \\t\\t\\tvar b1 = -diff.dot(segDir);\\n  \\t\\t\\tvar c = diff.lengthSq();\\n  \\t\\t\\tvar det = Math.abs(1.0 - a01 * a01);\\n\\n  \\t\\t\\tvar s0 = void 0,\\n  \\t\\t\\t    s1 = void 0,\\n  \\t\\t\\t    extDet = void 0,\\n  \\t\\t\\t    invDet = void 0,\\n  \\t\\t\\t    sqrDist = void 0;\\n\\n  \\t\\t\\tif (det > 0.0) {\\n  \\t\\t\\t\\ts0 = a01 * b1 - b0;\\n  \\t\\t\\t\\ts1 = a01 * b0 - b1;\\n  \\t\\t\\t\\textDet = segExtent * det;\\n\\n  \\t\\t\\t\\tif (s0 >= 0.0) {\\n\\n  \\t\\t\\t\\t\\tif (s1 >= -extDet) {\\n\\n  \\t\\t\\t\\t\\t\\tif (s1 <= extDet) {\\n  \\t\\t\\t\\t\\t\\t\\tinvDet = 1.0 / det;\\n  \\t\\t\\t\\t\\t\\t\\ts0 *= invDet;\\n  \\t\\t\\t\\t\\t\\t\\ts1 *= invDet;\\n  \\t\\t\\t\\t\\t\\t\\tsqrDist = s0 * (s0 + a01 * s1 + 2.0 * b0) + s1 * (a01 * s0 + s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\t\\ts1 = segExtent;\\n  \\t\\t\\t\\t\\t\\t\\ts0 = Math.max(0.0, -(a01 * s1 + b0));\\n  \\t\\t\\t\\t\\t\\t\\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\ts1 = -segExtent;\\n  \\t\\t\\t\\t\\t\\ts0 = Math.max(0.0, -(a01 * s1 + b0));\\n  \\t\\t\\t\\t\\t\\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tif (s1 <= -extDet) {\\n  \\t\\t\\t\\t\\t\\ts0 = Math.max(0.0, -(-a01 * segExtent + b0));\\n  \\t\\t\\t\\t\\t\\ts1 = s0 > 0.0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\\n  \\t\\t\\t\\t\\t\\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t} else if (s1 <= extDet) {\\n  \\t\\t\\t\\t\\t\\ts0 = 0.0;\\n  \\t\\t\\t\\t\\t\\ts1 = Math.min(Math.max(-segExtent, -b1), segExtent);\\n  \\t\\t\\t\\t\\t\\tsqrDist = s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\ts0 = Math.max(0.0, -(a01 * segExtent + b0));\\n  \\t\\t\\t\\t\\t\\ts1 = s0 > 0.0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\\n  \\t\\t\\t\\t\\t\\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n  \\t\\t\\t\\ts1 = a01 > 0.0 ? -segExtent : segExtent;\\n  \\t\\t\\t\\ts0 = Math.max(0.0, -(a01 * s1 + b0));\\n  \\t\\t\\t\\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (pointOnRay !== undefined) {\\n\\n  \\t\\t\\t\\tpointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (pointOnSegment !== undefined) {\\n\\n  \\t\\t\\t\\tpointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn sqrDist;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectSphere",\\n  \\t\\tvalue: function intersectSphere(s) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar ab = v$3[0].subVectors(s.center, this.origin);\\n  \\t\\t\\tvar tca = ab.dot(this.direction);\\n  \\t\\t\\tvar d2 = ab.dot(ab) - tca * tca;\\n  \\t\\t\\tvar radius2 = s.radius * s.radius;\\n\\n  \\t\\t\\tvar result = null;\\n  \\t\\t\\tvar thc = void 0,\\n  \\t\\t\\t    t0 = void 0,\\n  \\t\\t\\t    t1 = void 0;\\n\\n  \\t\\t\\tif (d2 <= radius2) {\\n\\n  \\t\\t\\t\\tthc = Math.sqrt(radius2 - d2);\\n\\n  \\t\\t\\t\\tt0 = tca - thc;\\n\\n  \\t\\t\\t\\tt1 = tca + thc;\\n\\n  \\t\\t\\t\\tif (t0 >= 0.0 || t1 >= 0.0) {\\n  \\t\\t\\t\\t\\tresult = t0 < 0.0 ? this.at(t1, target) : this.at(t0, target);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsSphere",\\n  \\t\\tvalue: function intersectsSphere(s) {\\n\\n  \\t\\t\\treturn this.distanceToPoint(s.center) <= s.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectPlane",\\n  \\t\\tvalue: function intersectPlane(p) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar t = this.distanceToPlane(p);\\n\\n  \\t\\t\\treturn t === null ? null : this.at(t, target);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsPlane",\\n  \\t\\tvalue: function intersectsPlane(p) {\\n\\n  \\t\\t\\tvar distanceToPoint = p.distanceToPoint(this.origin);\\n\\n  \\t\\t\\treturn distanceToPoint === 0.0 || p.normal.dot(this.direction) * distanceToPoint < 0.0;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectBox",\\n  \\t\\tvalue: function intersectBox(b) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar origin = this.origin;\\n  \\t\\t\\tvar direction = this.direction;\\n  \\t\\t\\tvar min = b.min;\\n  \\t\\t\\tvar max = b.max;\\n\\n  \\t\\t\\tvar invDirX = 1.0 / direction.x;\\n  \\t\\t\\tvar invDirY = 1.0 / direction.y;\\n  \\t\\t\\tvar invDirZ = 1.0 / direction.z;\\n\\n  \\t\\t\\tvar result = null;\\n  \\t\\t\\tvar tmin = void 0,\\n  \\t\\t\\t    tmax = void 0,\\n  \\t\\t\\t    tymin = void 0,\\n  \\t\\t\\t    tymax = void 0,\\n  \\t\\t\\t    tzmin = void 0,\\n  \\t\\t\\t    tzmax = void 0;\\n\\n  \\t\\t\\tif (invDirX >= 0.0) {\\n\\n  \\t\\t\\t\\ttmin = (min.x - origin.x) * invDirX;\\n  \\t\\t\\t\\ttmax = (max.x - origin.x) * invDirX;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\ttmin = (max.x - origin.x) * invDirX;\\n  \\t\\t\\t\\ttmax = (min.x - origin.x) * invDirX;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (invDirY >= 0.0) {\\n\\n  \\t\\t\\t\\ttymin = (min.y - origin.y) * invDirY;\\n  \\t\\t\\t\\ttymax = (max.y - origin.y) * invDirY;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\ttymin = (max.y - origin.y) * invDirY;\\n  \\t\\t\\t\\ttymax = (min.y - origin.y) * invDirY;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (tmin <= tymax && tymin <= tmax) {\\n  \\t\\t\\t\\tif (tymin > tmin || tmin !== tmin) {\\n\\n  \\t\\t\\t\\t\\ttmin = tymin;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (tymax < tmax || tmax !== tmax) {\\n\\n  \\t\\t\\t\\t\\ttmax = tymax;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (invDirZ >= 0.0) {\\n\\n  \\t\\t\\t\\t\\ttzmin = (min.z - origin.z) * invDirZ;\\n  \\t\\t\\t\\t\\ttzmax = (max.z - origin.z) * invDirZ;\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\ttzmin = (max.z - origin.z) * invDirZ;\\n  \\t\\t\\t\\t\\ttzmax = (min.z - origin.z) * invDirZ;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (tmin <= tzmax && tzmin <= tmax) {\\n\\n  \\t\\t\\t\\t\\tif (tzmin > tmin || tmin !== tmin) {\\n\\n  \\t\\t\\t\\t\\t\\ttmin = tzmin;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tif (tzmax < tmax || tmax !== tmax) {\\n\\n  \\t\\t\\t\\t\\t\\ttmax = tzmax;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tif (tmax >= 0.0) {\\n\\n  \\t\\t\\t\\t\\t\\tresult = this.at(tmin >= 0.0 ? tmin : tmax, target);\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectsBox",\\n  \\t\\tvalue: function intersectsBox(b) {\\n\\n  \\t\\t\\treturn this.intersectBox(b, v$3[0]) !== null;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "intersectTriangle",\\n  \\t\\tvalue: function intersectTriangle(a, b, c, backfaceCulling, target) {\\n\\n  \\t\\t\\tvar direction = this.direction;\\n\\n  \\t\\t\\tvar diff = v$3[0];\\n  \\t\\t\\tvar edge1 = v$3[1];\\n  \\t\\t\\tvar edge2 = v$3[2];\\n  \\t\\t\\tvar normal = v$3[3];\\n\\n  \\t\\t\\tvar result = null;\\n  \\t\\t\\tvar DdN = void 0,\\n  \\t\\t\\t    sign = void 0,\\n  \\t\\t\\t    DdQxE2 = void 0,\\n  \\t\\t\\t    DdE1xQ = void 0,\\n  \\t\\t\\t    QdN = void 0;\\n\\n  \\t\\t\\tedge1.subVectors(b, a);\\n  \\t\\t\\tedge2.subVectors(c, a);\\n  \\t\\t\\tnormal.crossVectors(edge1, edge2);\\n\\n  \\t\\t\\tDdN = direction.dot(normal);\\n\\n  \\t\\t\\tif (DdN !== 0.0 && !(backfaceCulling && DdN > 0.0)) {\\n\\n  \\t\\t\\t\\tif (DdN > 0.0) {\\n\\n  \\t\\t\\t\\t\\tsign = 1.0;\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tsign = -1.0;\\n  \\t\\t\\t\\t\\tDdN = -DdN;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tdiff.subVectors(this.origin, a);\\n  \\t\\t\\t\\tDdQxE2 = sign * direction.dot(edge2.crossVectors(diff, edge2));\\n\\n  \\t\\t\\t\\tif (DdQxE2 >= 0.0) {\\n\\n  \\t\\t\\t\\t\\tDdE1xQ = sign * direction.dot(edge1.cross(diff));\\n\\n  \\t\\t\\t\\t\\tif (DdE1xQ >= 0.0 && DdQxE2 + DdE1xQ <= DdN) {\\n  \\t\\t\\t\\t\\t\\tQdN = -sign * diff.dot(normal);\\n\\n  \\t\\t\\t\\t\\t\\tif (QdN >= 0.0) {\\n  \\t\\t\\t\\t\\t\\t\\tresult = this.at(QdN / DdN, target);\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "applyMatrix4",\\n  \\t\\tvalue: function applyMatrix4(m) {\\n\\n  \\t\\t\\tthis.origin.applyMatrix4(m);\\n  \\t\\t\\tthis.direction.transformDirection(m);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(r) {\\n\\n  \\t\\t\\treturn r.origin.equals(this.origin) && r.direction.equals(this.direction);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Ray;\\n  }();\\n\\n  var Spherical = function () {\\n  \\tfunction Spherical() {\\n  \\t\\tvar radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n  \\t\\tvar phi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar theta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tclassCallCheck(this, Spherical);\\n\\n\\n  \\t\\tthis.radius = radius;\\n\\n  \\t\\tthis.phi = phi;\\n\\n  \\t\\tthis.theta = theta;\\n  \\t}\\n\\n  \\tcreateClass(Spherical, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(radius, phi, theta) {\\n\\n  \\t\\t\\tthis.radius = radius;\\n  \\t\\t\\tthis.phi = phi;\\n  \\t\\t\\tthis.theta = theta;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(s) {\\n\\n  \\t\\t\\tthis.radius = s.radius;\\n  \\t\\t\\tthis.phi = s.phi;\\n  \\t\\t\\tthis.theta = s.theta;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setFromVector3",\\n  \\t\\tvalue: function setFromVector3(v) {\\n\\n  \\t\\t\\tthis.radius = v.length();\\n\\n  \\t\\t\\tif (this.radius === 0) {\\n\\n  \\t\\t\\t\\tthis.theta = 0;\\n  \\t\\t\\t\\tthis.phi = 0;\\n  \\t\\t\\t} else {\\n  \\t\\t\\t\\tthis.theta = Math.atan2(v.x, v.z);\\n\\n  \\t\\t\\t\\tthis.phi = Math.acos(Math.min(Math.max(v.y / this.radius, -1), 1));\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this.makeSafe();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "makeSafe",\\n  \\t\\tvalue: function makeSafe() {\\n\\n  \\t\\t\\tthis.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi));\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Spherical;\\n  }();\\n\\n  var SymmetricMatrix3 = function () {\\n  \\tfunction SymmetricMatrix3() {\\n  \\t\\tclassCallCheck(this, SymmetricMatrix3);\\n\\n\\n  \\t\\tthis.elements = new Float32Array([1, 0, 0, 1, 0, 1]);\\n  \\t}\\n\\n  \\tcreateClass(SymmetricMatrix3, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(m00, m01, m02, m11, m12, m22) {\\n\\n  \\t\\t\\tvar e = this.elements;\\n\\n  \\t\\t\\te[0] = m00;\\n  \\t\\t\\te[1] = m01;e[3] = m11;\\n  \\t\\t\\te[2] = m02;e[4] = m12;e[5] = m22;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "identity",\\n  \\t\\tvalue: function identity() {\\n\\n  \\t\\t\\tthis.set(1, 0, 0, 1, 0, 1);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(m) {\\n\\n  \\t\\t\\tvar me = m.elements;\\n\\n  \\t\\t\\tthis.set(me[0], me[1], me[2], me[3], me[4], me[5]);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "toMatrix3",\\n  \\t\\tvalue: function toMatrix3(m) {\\n\\n  \\t\\t\\tvar me = m.elements;\\n\\n  \\t\\t\\tm.set(me[0], me[1], me[2], me[1], me[3], me[4], me[2], me[4], me[5]);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "add",\\n  \\t\\tvalue: function add(m) {\\n\\n  \\t\\t\\tvar te = this.elements;\\n  \\t\\t\\tvar me = m.elements;\\n\\n  \\t\\t\\tte[0] += me[0];\\n  \\t\\t\\tte[1] += me[1];te[3] += me[3];\\n  \\t\\t\\tte[2] += me[2];te[4] += me[4];te[5] += me[5];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "norm",\\n  \\t\\tvalue: function norm() {\\n\\n  \\t\\t\\tvar e = this.elements;\\n\\n  \\t\\t\\tvar m01m01 = e[1] * e[1];\\n  \\t\\t\\tvar m02m02 = e[2] * e[2];\\n  \\t\\t\\tvar m12m12 = e[4] * e[4];\\n\\n  \\t\\t\\treturn Math.sqrt(e[0] * e[0] + m01m01 + m02m02 + m01m01 + e[3] * e[3] + m12m12 + m02m02 + m12m12 + e[5] * e[5]);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "off",\\n  \\t\\tvalue: function off() {\\n\\n  \\t\\t\\tvar e = this.elements;\\n\\n  \\t\\t\\treturn Math.sqrt(2 * (e[1] * e[1] + e[2] * e[2] + e[4] * e[4]));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "applyToVector3",\\n  \\t\\tvalue: function applyToVector3(v) {\\n\\n  \\t\\t\\tvar x = v.x,\\n  \\t\\t\\t    y = v.y,\\n  \\t\\t\\t    z = v.z;\\n  \\t\\t\\tvar e = this.elements;\\n\\n  \\t\\t\\tv.x = e[0] * x + e[1] * y + e[2] * z;\\n  \\t\\t\\tv.y = e[1] * x + e[3] * y + e[4] * z;\\n  \\t\\t\\tv.z = e[2] * x + e[4] * y + e[5] * z;\\n\\n  \\t\\t\\treturn v;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(matrix) {\\n\\n  \\t\\t\\tvar te = this.elements;\\n  \\t\\t\\tvar me = matrix.elements;\\n\\n  \\t\\t\\tvar result = true;\\n  \\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\tfor (i = 0; result && i < 6; ++i) {\\n\\n  \\t\\t\\t\\tif (te[i] !== me[i]) {\\n\\n  \\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: "calculateIndex",\\n  \\t\\tvalue: function calculateIndex(i, j) {\\n\\n  \\t\\t\\treturn 3 - (3 - i) * (2 - i) / 2 + j;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn SymmetricMatrix3;\\n  }();\\n\\n  var Vector4 = function () {\\n  \\tfunction Vector4() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tvar w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\\n  \\t\\tclassCallCheck(this, Vector4);\\n\\n\\n  \\t\\tthis.x = x;\\n\\n  \\t\\tthis.y = y;\\n\\n  \\t\\tthis.z = z;\\n\\n  \\t\\tthis.w = w;\\n  \\t}\\n\\n  \\tcreateClass(Vector4, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(x, y, z, w) {\\n\\n  \\t\\t\\tthis.x = x;\\n  \\t\\t\\tthis.y = y;\\n  \\t\\t\\tthis.z = z;\\n  \\t\\t\\tthis.w = w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "copy",\\n  \\t\\tvalue: function copy(v) {\\n\\n  \\t\\t\\tthis.x = v.x;\\n  \\t\\t\\tthis.y = v.y;\\n  \\t\\t\\tthis.z = v.z;\\n  \\t\\t\\tthis.w = v.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clone",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor(this.x, this.y, this.z, this.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "fromArray",\\n  \\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tthis.x = array[offset];\\n  \\t\\t\\tthis.y = array[offset + 1];\\n  \\t\\t\\tthis.z = array[offset + 2];\\n  \\t\\t\\tthis.w = array[offset + 3];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "toArray",\\n  \\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tarray[offset] = this.x;\\n  \\t\\t\\tarray[offset + 1] = this.y;\\n  \\t\\t\\tarray[offset + 2] = this.z;\\n  \\t\\t\\tarray[offset + 3] = this.w;\\n\\n  \\t\\t\\treturn array;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setAxisAngleFromQuaternion",\\n  \\t\\tvalue: function setAxisAngleFromQuaternion(q) {\\n\\n  \\t\\t\\tthis.w = 2 * Math.acos(q.w);\\n\\n  \\t\\t\\tvar s = Math.sqrt(1 - q.w * q.w);\\n\\n  \\t\\t\\tif (s < 1e-4) {\\n\\n  \\t\\t\\t\\tthis.x = 1;\\n  \\t\\t\\t\\tthis.y = 0;\\n  \\t\\t\\t\\tthis.z = 0;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tthis.x = q.x / s;\\n  \\t\\t\\t\\tthis.y = q.y / s;\\n  \\t\\t\\t\\tthis.z = q.z / s;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setAxisAngleFromRotationMatrix",\\n  \\t\\tvalue: function setAxisAngleFromRotationMatrix(m) {\\n  \\t\\t\\tvar E = 0.01;\\n\\n  \\t\\t\\tvar H = 0.1;\\n\\n  \\t\\t\\tvar me = m.elements;\\n  \\t\\t\\tvar m00 = me[0],\\n  \\t\\t\\t    m01 = me[4],\\n  \\t\\t\\t    m02 = me[8];\\n  \\t\\t\\tvar m10 = me[1],\\n  \\t\\t\\t    m11 = me[5],\\n  \\t\\t\\t    m12 = me[9];\\n  \\t\\t\\tvar m20 = me[2],\\n  \\t\\t\\t    m21 = me[6],\\n  \\t\\t\\t    m22 = me[10];\\n\\n  \\t\\t\\tvar angle = void 0;\\n  \\t\\t\\tvar x = void 0,\\n  \\t\\t\\t    y = void 0,\\n  \\t\\t\\t    z = void 0;\\n  \\t\\t\\tvar xx = void 0,\\n  \\t\\t\\t    yy = void 0,\\n  \\t\\t\\t    zz = void 0;\\n  \\t\\t\\tvar xy = void 0,\\n  \\t\\t\\t    xz = void 0,\\n  \\t\\t\\t    yz = void 0;\\n  \\t\\t\\tvar s = void 0;\\n\\n  \\t\\t\\tif (Math.abs(m01 - m10) < E && Math.abs(m02 - m20) < E && Math.abs(m12 - m21) < E) {\\n  \\t\\t\\t\\tif (Math.abs(m01 + m10) < H && Math.abs(m02 + m20) < H && Math.abs(m12 + m21) < H && Math.abs(m00 + m11 + m22 - 3) < H) {\\n  \\t\\t\\t\\t\\tthis.set(1, 0, 0, 0);\\n  \\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\tangle = Math.PI;\\n\\n  \\t\\t\\t\\t\\txx = (m00 + 1) / 2;\\n  \\t\\t\\t\\t\\tyy = (m11 + 1) / 2;\\n  \\t\\t\\t\\t\\tzz = (m22 + 1) / 2;\\n  \\t\\t\\t\\t\\txy = (m01 + m10) / 4;\\n  \\t\\t\\t\\t\\txz = (m02 + m20) / 4;\\n  \\t\\t\\t\\t\\tyz = (m12 + m21) / 4;\\n\\n  \\t\\t\\t\\t\\tif (xx > yy && xx > zz) {\\n  \\t\\t\\t\\t\\t\\tif (xx < E) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tx = 0;\\n  \\t\\t\\t\\t\\t\\t\\ty = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t\\tz = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tx = Math.sqrt(xx);\\n  \\t\\t\\t\\t\\t\\t\\ty = xy / x;\\n  \\t\\t\\t\\t\\t\\t\\tz = xz / x;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t} else if (yy > zz) {\\n  \\t\\t\\t\\t\\t\\tif (yy < E) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tx = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t\\ty = 0;\\n  \\t\\t\\t\\t\\t\\t\\tz = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\ty = Math.sqrt(yy);\\n  \\t\\t\\t\\t\\t\\t\\tx = xy / y;\\n  \\t\\t\\t\\t\\t\\t\\tz = yz / y;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\tif (zz < E) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tx = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t\\ty = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t\\tz = 0;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tz = Math.sqrt(zz);\\n  \\t\\t\\t\\t\\t\\t\\tx = xz / z;\\n  \\t\\t\\t\\t\\t\\t\\ty = yz / z;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tthis.set(x, y, z, angle);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n  \\t\\t\\t\\ts = Math.sqrt((m21 - m12) * (m21 - m12) + (m02 - m20) * (m02 - m20) + (m10 - m01) * (m10 - m01));\\n\\n  \\t\\t\\t\\tif (Math.abs(s) < 0.001) {\\n\\n  \\t\\t\\t\\t\\ts = 1;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tthis.x = (m21 - m12) / s;\\n  \\t\\t\\t\\tthis.y = (m02 - m20) / s;\\n  \\t\\t\\t\\tthis.z = (m10 - m01) / s;\\n  \\t\\t\\t\\tthis.w = Math.acos((m00 + m11 + m22 - 1) / 2);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "add",\\n  \\t\\tvalue: function add(v) {\\n\\n  \\t\\t\\tthis.x += v.x;\\n  \\t\\t\\tthis.y += v.y;\\n  \\t\\t\\tthis.z += v.z;\\n  \\t\\t\\tthis.w += v.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "addScalar",\\n  \\t\\tvalue: function addScalar(s) {\\n\\n  \\t\\t\\tthis.x += s;\\n  \\t\\t\\tthis.y += s;\\n  \\t\\t\\tthis.z += s;\\n  \\t\\t\\tthis.w += s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "addVectors",\\n  \\t\\tvalue: function addVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x + b.x;\\n  \\t\\t\\tthis.y = a.y + b.y;\\n  \\t\\t\\tthis.z = a.z + b.z;\\n  \\t\\t\\tthis.w = a.w + b.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "addScaledVector",\\n  \\t\\tvalue: function addScaledVector(v, s) {\\n\\n  \\t\\t\\tthis.x += v.x * s;\\n  \\t\\t\\tthis.y += v.y * s;\\n  \\t\\t\\tthis.z += v.z * s;\\n  \\t\\t\\tthis.w += v.w * s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "sub",\\n  \\t\\tvalue: function sub(v) {\\n\\n  \\t\\t\\tthis.x -= v.x;\\n  \\t\\t\\tthis.y -= v.y;\\n  \\t\\t\\tthis.z -= v.z;\\n  \\t\\t\\tthis.w -= v.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "subScalar",\\n  \\t\\tvalue: function subScalar(s) {\\n\\n  \\t\\t\\tthis.x -= s;\\n  \\t\\t\\tthis.y -= s;\\n  \\t\\t\\tthis.z -= s;\\n  \\t\\t\\tthis.w -= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "subVectors",\\n  \\t\\tvalue: function subVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x - b.x;\\n  \\t\\t\\tthis.y = a.y - b.y;\\n  \\t\\t\\tthis.z = a.z - b.z;\\n  \\t\\t\\tthis.w = a.w - b.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "multiply",\\n  \\t\\tvalue: function multiply(v) {\\n\\n  \\t\\t\\tthis.x *= v.x;\\n  \\t\\t\\tthis.y *= v.y;\\n  \\t\\t\\tthis.z *= v.z;\\n  \\t\\t\\tthis.w *= v.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "multiplyScalar",\\n  \\t\\tvalue: function multiplyScalar(s) {\\n\\n  \\t\\t\\tthis.x *= s;\\n  \\t\\t\\tthis.y *= s;\\n  \\t\\t\\tthis.z *= s;\\n  \\t\\t\\tthis.w *= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "multiplyVectors",\\n  \\t\\tvalue: function multiplyVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x * b.x;\\n  \\t\\t\\tthis.y = a.y * b.y;\\n  \\t\\t\\tthis.z = a.z * b.z;\\n  \\t\\t\\tthis.w = a.w * b.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "divide",\\n  \\t\\tvalue: function divide(v) {\\n\\n  \\t\\t\\tthis.x /= v.x;\\n  \\t\\t\\tthis.y /= v.y;\\n  \\t\\t\\tthis.z /= v.z;\\n  \\t\\t\\tthis.w /= v.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "divideScalar",\\n  \\t\\tvalue: function divideScalar(s) {\\n\\n  \\t\\t\\tthis.x /= s;\\n  \\t\\t\\tthis.y /= s;\\n  \\t\\t\\tthis.z /= s;\\n  \\t\\t\\tthis.w /= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "applyMatrix4",\\n  \\t\\tvalue: function applyMatrix4(m) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z,\\n  \\t\\t\\t    w = this.w;\\n  \\t\\t\\tvar e = m.elements;\\n\\n  \\t\\t\\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\\n  \\t\\t\\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\\n  \\t\\t\\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\\n  \\t\\t\\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "negate",\\n  \\t\\tvalue: function negate() {\\n\\n  \\t\\t\\tthis.x = -this.x;\\n  \\t\\t\\tthis.y = -this.y;\\n  \\t\\t\\tthis.z = -this.z;\\n  \\t\\t\\tthis.w = -this.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "dot",\\n  \\t\\tvalue: function dot(v) {\\n\\n  \\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "manhattanLength",\\n  \\t\\tvalue: function manhattanLength() {\\n\\n  \\t\\t\\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lengthSquared",\\n  \\t\\tvalue: function lengthSquared() {\\n\\n  \\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "length",\\n  \\t\\tvalue: function length() {\\n\\n  \\t\\t\\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "manhattanDistanceTo",\\n  \\t\\tvalue: function manhattanDistanceTo(v) {\\n\\n  \\t\\t\\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z) + Math.abs(this.w - v.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceToSquared",\\n  \\t\\tvalue: function distanceToSquared(v) {\\n\\n  \\t\\t\\tvar dx = this.x - v.x;\\n  \\t\\t\\tvar dy = this.y - v.y;\\n  \\t\\t\\tvar dz = this.z - v.z;\\n  \\t\\t\\tvar dw = this.w - v.w;\\n\\n  \\t\\t\\treturn dx * dx + dy * dy + dz * dz + dw * dw;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceTo",\\n  \\t\\tvalue: function distanceTo(v) {\\n\\n  \\t\\t\\treturn Math.sqrt(this.distanceToSquared(v));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "normalize",\\n  \\t\\tvalue: function normalize() {\\n\\n  \\t\\t\\treturn this.divideScalar(this.length());\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setLength",\\n  \\t\\tvalue: function setLength(length) {\\n\\n  \\t\\t\\treturn this.normalize().multiplyScalar(length);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "min",\\n  \\t\\tvalue: function min(v) {\\n\\n  \\t\\t\\tthis.x = Math.min(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.min(this.y, v.y);\\n  \\t\\t\\tthis.z = Math.min(this.z, v.z);\\n  \\t\\t\\tthis.w = Math.min(this.w, v.w);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "max",\\n  \\t\\tvalue: function max(v) {\\n\\n  \\t\\t\\tthis.x = Math.max(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.max(this.y, v.y);\\n  \\t\\t\\tthis.z = Math.max(this.z, v.z);\\n  \\t\\t\\tthis.w = Math.max(this.w, v.w);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clamp",\\n  \\t\\tvalue: function clamp(min, max) {\\n\\n  \\t\\t\\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\\n  \\t\\t\\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\\n  \\t\\t\\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\\n  \\t\\t\\tthis.w = Math.max(min.w, Math.min(max.w, this.w));\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "floor",\\n  \\t\\tvalue: function floor() {\\n\\n  \\t\\t\\tthis.x = Math.floor(this.x);\\n  \\t\\t\\tthis.y = Math.floor(this.y);\\n  \\t\\t\\tthis.z = Math.floor(this.z);\\n  \\t\\t\\tthis.w = Math.floor(this.w);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "ceil",\\n  \\t\\tvalue: function ceil() {\\n\\n  \\t\\t\\tthis.x = Math.ceil(this.x);\\n  \\t\\t\\tthis.y = Math.ceil(this.y);\\n  \\t\\t\\tthis.z = Math.ceil(this.z);\\n  \\t\\t\\tthis.w = Math.ceil(this.w);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "round",\\n  \\t\\tvalue: function round() {\\n\\n  \\t\\t\\tthis.x = Math.round(this.x);\\n  \\t\\t\\tthis.y = Math.round(this.y);\\n  \\t\\t\\tthis.z = Math.round(this.z);\\n  \\t\\t\\tthis.w = Math.round(this.w);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lerp",\\n  \\t\\tvalue: function lerp(v, alpha) {\\n\\n  \\t\\t\\tthis.x += (v.x - this.x) * alpha;\\n  \\t\\t\\tthis.y += (v.y - this.y) * alpha;\\n  \\t\\t\\tthis.z += (v.z - this.z) * alpha;\\n  \\t\\t\\tthis.w += (v.w - this.w) * alpha;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "lerpVectors",\\n  \\t\\tvalue: function lerpVectors(v1, v2, alpha) {\\n\\n  \\t\\t\\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "equals",\\n  \\t\\tvalue: function equals(v) {\\n\\n  \\t\\t\\treturn v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Vector4;\\n  }();\\n\\n  var IteratorResult = function () {\\n  \\tfunction IteratorResult() {\\n  \\t\\tvar value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\\n  \\t\\tvar done = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n  \\t\\tclassCallCheck(this, IteratorResult);\\n\\n\\n  \\t\\tthis.value = value;\\n\\n  \\t\\tthis.done = done;\\n  \\t}\\n\\n  \\tcreateClass(IteratorResult, [{\\n  \\t\\tkey: "reset",\\n  \\t\\tvalue: function reset() {\\n\\n  \\t\\t\\tthis.value = null;\\n  \\t\\t\\tthis.done = false;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn IteratorResult;\\n  }();\\n\\n  var c$1 = new Vector3();\\n\\n  var Octant = function () {\\n  \\tfunction Octant() {\\n  \\t\\tvar min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\tvar max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n  \\t\\tclassCallCheck(this, Octant);\\n\\n\\n  \\t\\tthis.min = min;\\n\\n  \\t\\tthis.max = max;\\n\\n  \\t\\tthis.children = null;\\n  \\t}\\n\\n  \\tcreateClass(Octant, [{\\n  \\t\\tkey: "getCenter",\\n  \\t\\tvalue: function getCenter() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.addVectors(this.min, this.max).multiplyScalar(0.5);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getDimensions",\\n  \\t\\tvalue: function getDimensions() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.subVectors(this.max, this.min);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "split",\\n  \\t\\tvalue: function split() {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar max = this.max;\\n  \\t\\t\\tvar mid = this.getCenter(c$1);\\n\\n  \\t\\t\\tvar children = this.children = [null, null, null, null, null, null, null, null];\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    combination = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\t\\tcombination = pattern[i];\\n\\n  \\t\\t\\t\\tchildren[i] = new this.constructor(new Vector3(combination[0] === 0 ? min.x : mid.x, combination[1] === 0 ? min.y : mid.y, combination[2] === 0 ? min.z : mid.z), new Vector3(combination[0] === 0 ? mid.x : max.x, combination[1] === 0 ? mid.y : max.y, combination[2] === 0 ? mid.z : max.z));\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Octant;\\n  }();\\n\\n  var pattern = [new Uint8Array([0, 0, 0]), new Uint8Array([0, 0, 1]), new Uint8Array([0, 1, 0]), new Uint8Array([0, 1, 1]), new Uint8Array([1, 0, 0]), new Uint8Array([1, 0, 1]), new Uint8Array([1, 1, 0]), new Uint8Array([1, 1, 1])];\\n\\n  var edges = [new Uint8Array([0, 4]), new Uint8Array([1, 5]), new Uint8Array([2, 6]), new Uint8Array([3, 7]), new Uint8Array([0, 2]), new Uint8Array([1, 3]), new Uint8Array([4, 6]), new Uint8Array([5, 7]), new Uint8Array([0, 1]), new Uint8Array([2, 3]), new Uint8Array([4, 5]), new Uint8Array([6, 7])];\\n\\n  var c$2 = new Vector3();\\n\\n  var CubicOctant = function () {\\n  \\tfunction CubicOctant() {\\n  \\t\\tvar min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\tvar size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tclassCallCheck(this, CubicOctant);\\n\\n\\n  \\t\\tthis.min = min;\\n\\n  \\t\\tthis.size = size;\\n\\n  \\t\\tthis.children = null;\\n  \\t}\\n\\n  \\tcreateClass(CubicOctant, [{\\n  \\t\\tkey: "getCenter",\\n  \\t\\tvalue: function getCenter() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.copy(this.min).addScalar(this.size * 0.5);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getDimensions",\\n  \\t\\tvalue: function getDimensions() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.set(this.size, this.size, this.size);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "split",\\n  \\t\\tvalue: function split() {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar mid = this.getCenter(c$2);\\n  \\t\\t\\tvar halfSize = this.size * 0.5;\\n\\n  \\t\\t\\tvar children = this.children = [null, null, null, null, null, null, null, null];\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    combination = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\t\\tcombination = pattern[i];\\n\\n  \\t\\t\\t\\tchildren[i] = new this.constructor(new Vector3(combination[0] === 0 ? min.x : mid.x, combination[1] === 0 ? min.y : mid.y, combination[2] === 0 ? min.z : mid.z), halfSize);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "max",\\n  \\t\\tget: function get$$1() {\\n  \\t\\t\\treturn this.min.clone().addScalar(this.size);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn CubicOctant;\\n  }();\\n\\n  var b$3 = new Box3();\\n\\n  var OctantIterator = function () {\\n  \\t\\tfunction OctantIterator(octree) {\\n  \\t\\t\\t\\tvar region = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\\n  \\t\\t\\t\\tclassCallCheck(this, OctantIterator);\\n\\n\\n  \\t\\t\\t\\tthis.octree = octree;\\n\\n  \\t\\t\\t\\tthis.region = region;\\n\\n  \\t\\t\\t\\tthis.cull = region !== null;\\n\\n  \\t\\t\\t\\tthis.result = new IteratorResult();\\n\\n  \\t\\t\\t\\tthis.trace = null;\\n\\n  \\t\\t\\t\\tthis.indices = null;\\n\\n  \\t\\t\\t\\tthis.reset();\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(OctantIterator, [{\\n  \\t\\t\\t\\tkey: "reset",\\n  \\t\\t\\t\\tvalue: function reset() {\\n\\n  \\t\\t\\t\\t\\t\\tvar root = this.octree.root;\\n\\n  \\t\\t\\t\\t\\t\\tthis.trace = [];\\n  \\t\\t\\t\\t\\t\\tthis.indices = [];\\n\\n  \\t\\t\\t\\t\\t\\tif (root !== null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tb$3.min = root.min;\\n  \\t\\t\\t\\t\\t\\t\\t\\tb$3.max = root.max;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (!this.cull || this.region.intersectsBox(b$3)) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.trace.push(root);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.indices.push(0);\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tthis.result.reset();\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "next",\\n  \\t\\t\\t\\tvalue: function next() {\\n\\n  \\t\\t\\t\\t\\t\\tvar cull = this.cull;\\n  \\t\\t\\t\\t\\t\\tvar region = this.region;\\n  \\t\\t\\t\\t\\t\\tvar indices = this.indices;\\n  \\t\\t\\t\\t\\t\\tvar trace = this.trace;\\n\\n  \\t\\t\\t\\t\\t\\tvar octant = null;\\n  \\t\\t\\t\\t\\t\\tvar depth = trace.length - 1;\\n\\n  \\t\\t\\t\\t\\t\\tvar index = void 0,\\n  \\t\\t\\t\\t\\t\\t    children = void 0,\\n  \\t\\t\\t\\t\\t\\t    child = void 0;\\n\\n  \\t\\t\\t\\t\\t\\twhile (octant === null && depth >= 0) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tindex = indices[depth];\\n  \\t\\t\\t\\t\\t\\t\\t\\tchildren = trace[depth].children;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t++indices[depth];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (index < 8) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (children !== null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tchild = children[index];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (cull) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tb$3.min = child.min;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tb$3.max = child.max;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (!region.intersectsBox(b$3)) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcontinue;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttrace.push(child);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tindices.push(0);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++depth;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\toctant = trace.pop();\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tindices.pop();\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttrace.pop();\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tindices.pop();\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t--depth;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tthis.result.value = octant;\\n  \\t\\t\\t\\t\\t\\tthis.result.done = octant === null;\\n\\n  \\t\\t\\t\\t\\t\\treturn this.result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "return",\\n  \\t\\t\\t\\tvalue: function _return(value) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.result.value = value;\\n  \\t\\t\\t\\t\\t\\tthis.result.done = true;\\n\\n  \\t\\t\\t\\t\\t\\treturn this.result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: Symbol.iterator,\\n  \\t\\t\\t\\tvalue: function value() {\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn OctantIterator;\\n  }();\\n\\n  var v$4 = [new Vector3(), new Vector3(), new Vector3()];\\n\\n  var b$4 = new Box3();\\n\\n  var r = new Ray();\\n\\n  var octantTable = [new Uint8Array([4, 2, 1]), new Uint8Array([5, 3, 8]), new Uint8Array([6, 8, 3]), new Uint8Array([7, 8, 8]), new Uint8Array([8, 6, 5]), new Uint8Array([8, 7, 8]), new Uint8Array([8, 8, 7]), new Uint8Array([8, 8, 8])];\\n\\n  var flags = 0;\\n\\n  function findEntryOctant(tx0, ty0, tz0, txm, tym, tzm) {\\n\\n  \\tvar entry = 0;\\n\\n  \\tif (tx0 > ty0 && tx0 > tz0) {\\n  \\t\\tif (tym < tx0) {\\n  \\t\\t\\tentry |= 2;\\n  \\t\\t}\\n  \\t\\tif (tzm < tx0) {\\n  \\t\\t\\tentry |= 1;\\n  \\t\\t}\\n  \\t} else if (ty0 > tz0) {\\n  \\t\\tif (txm < ty0) {\\n  \\t\\t\\tentry |= 4;\\n  \\t\\t}\\n  \\t\\tif (tzm < ty0) {\\n  \\t\\t\\tentry |= 1;\\n  \\t\\t}\\n  \\t} else {\\n  \\t\\tif (txm < tz0) {\\n  \\t\\t\\tentry |= 4;\\n  \\t\\t}\\n  \\t\\tif (tym < tz0) {\\n  \\t\\t\\tentry |= 2;\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn entry;\\n  }\\n\\n  function findNextOctant(currentOctant, tx1, ty1, tz1) {\\n\\n  \\tvar min = void 0;\\n  \\tvar exit = 0;\\n\\n  \\tif (tx1 < ty1) {\\n\\n  \\t\\tmin = tx1;\\n  \\t\\texit = 0;\\n  \\t} else {\\n\\n  \\t\\tmin = ty1;\\n  \\t\\texit = 1;\\n  \\t}\\n\\n  \\tif (tz1 < min) {\\n\\n  \\t\\texit = 2;\\n  \\t}\\n\\n  \\treturn octantTable[currentOctant][exit];\\n  }\\n\\n  function raycastOctant(octant, tx0, ty0, tz0, tx1, ty1, tz1, raycaster, intersects) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar currentOctant = void 0;\\n  \\tvar txm = void 0,\\n  \\t    tym = void 0,\\n  \\t    tzm = void 0;\\n\\n  \\tif (tx1 >= 0.0 && ty1 >= 0.0 && tz1 >= 0.0) {\\n\\n  \\t\\tif (children === null) {\\n  \\t\\t\\tintersects.push(octant);\\n  \\t\\t} else {\\n  \\t\\t\\ttxm = 0.5 * (tx0 + tx1);\\n  \\t\\t\\ttym = 0.5 * (ty0 + ty1);\\n  \\t\\t\\ttzm = 0.5 * (tz0 + tz1);\\n\\n  \\t\\t\\tcurrentOctant = findEntryOctant(tx0, ty0, tz0, txm, tym, tzm);\\n\\n  \\t\\t\\tdo {\\n\\n  \\t\\t\\t\\tswitch (currentOctant) {\\n\\n  \\t\\t\\t\\t\\tcase 0:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags], tx0, ty0, tz0, txm, tym, tzm, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, txm, tym, tzm);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 1:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 1], tx0, ty0, tzm, txm, tym, tz1, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, txm, tym, tz1);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 2:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 2], tx0, tym, tz0, txm, ty1, tzm, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, txm, ty1, tzm);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 3:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 3], tx0, tym, tzm, txm, ty1, tz1, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, txm, ty1, tz1);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 4:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 4], txm, ty0, tz0, tx1, tym, tzm, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, tx1, tym, tzm);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 5:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 5], txm, ty0, tzm, tx1, tym, tz1, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, tx1, tym, tz1);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 6:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 6], txm, tym, tz0, tx1, ty1, tzm, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, tx1, ty1, tzm);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 7:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 7], txm, tym, tzm, tx1, ty1, tz1, raycaster, intersects);\\n\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = 8;\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} while (currentOctant < 8);\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  var OctreeRaycaster = function () {\\n  \\tfunction OctreeRaycaster() {\\n  \\t\\tclassCallCheck(this, OctreeRaycaster);\\n  \\t}\\n\\n  \\tcreateClass(OctreeRaycaster, null, [{\\n  \\t\\tkey: "intersectOctree",\\n  \\t\\tvalue: function intersectOctree(octree, raycaster, intersects) {\\n  \\t\\t\\tvar min = b$4.min.set(0, 0, 0);\\n  \\t\\t\\tvar max = b$4.max.subVectors(octree.max, octree.min);\\n\\n  \\t\\t\\tvar dimensions = octree.getDimensions(v$4[0]);\\n  \\t\\t\\tvar halfDimensions = v$4[1].copy(dimensions).multiplyScalar(0.5);\\n\\n  \\t\\t\\tvar origin = r.origin.copy(raycaster.ray.origin);\\n  \\t\\t\\tvar direction = r.direction.copy(raycaster.ray.direction);\\n\\n  \\t\\t\\tvar invDirX = void 0,\\n  \\t\\t\\t    invDirY = void 0,\\n  \\t\\t\\t    invDirZ = void 0;\\n  \\t\\t\\tvar tx0 = void 0,\\n  \\t\\t\\t    tx1 = void 0,\\n  \\t\\t\\t    ty0 = void 0,\\n  \\t\\t\\t    ty1 = void 0,\\n  \\t\\t\\t    tz0 = void 0,\\n  \\t\\t\\t    tz1 = void 0;\\n\\n  \\t\\t\\torigin.sub(octree.getCenter(v$4[2])).add(halfDimensions);\\n\\n  \\t\\t\\tflags = 0;\\n\\n  \\t\\t\\tif (direction.x < 0.0) {\\n\\n  \\t\\t\\t\\torigin.x = dimensions.x - origin.x;\\n  \\t\\t\\t\\tdirection.x = -direction.x;\\n  \\t\\t\\t\\tflags |= 4;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (direction.y < 0.0) {\\n\\n  \\t\\t\\t\\torigin.y = dimensions.y - origin.y;\\n  \\t\\t\\t\\tdirection.y = -direction.y;\\n  \\t\\t\\t\\tflags |= 2;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (direction.z < 0.0) {\\n\\n  \\t\\t\\t\\torigin.z = dimensions.z - origin.z;\\n  \\t\\t\\t\\tdirection.z = -direction.z;\\n  \\t\\t\\t\\tflags |= 1;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tinvDirX = 1.0 / direction.x;\\n  \\t\\t\\tinvDirY = 1.0 / direction.y;\\n  \\t\\t\\tinvDirZ = 1.0 / direction.z;\\n\\n  \\t\\t\\ttx0 = (min.x - origin.x) * invDirX;\\n  \\t\\t\\ttx1 = (max.x - origin.x) * invDirX;\\n  \\t\\t\\tty0 = (min.y - origin.y) * invDirY;\\n  \\t\\t\\tty1 = (max.y - origin.y) * invDirY;\\n  \\t\\t\\ttz0 = (min.z - origin.z) * invDirZ;\\n  \\t\\t\\ttz1 = (max.z - origin.z) * invDirZ;\\n\\n  \\t\\t\\tif (Math.max(Math.max(tx0, ty0), tz0) < Math.min(Math.min(tx1, ty1), tz1)) {\\n  \\t\\t\\t\\traycastOctant(octree.root, tx0, ty0, tz0, tx1, ty1, tz1, raycaster, intersects);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn OctreeRaycaster;\\n  }();\\n\\n  var b$5 = new Box3();\\n\\n  function _getDepth(octant) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = 0;\\n  \\tvar i = void 0,\\n  \\t    l = void 0,\\n  \\t    d = void 0;\\n\\n  \\tif (children !== null) {\\n\\n  \\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\td = 1 + _getDepth(children[i]);\\n\\n  \\t\\t\\tif (d > result) {\\n\\n  \\t\\t\\t\\tresult = d;\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _cull(octant, region, result) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tb$5.min = octant.min;\\n  \\tb$5.max = octant.max;\\n\\n  \\tif (region.intersectsBox(b$5)) {\\n\\n  \\t\\tif (children !== null) {\\n\\n  \\t\\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t_cull(children[i], region, result);\\n  \\t\\t\\t}\\n  \\t\\t} else {\\n\\n  \\t\\t\\tresult.push(octant);\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function _findOctantsByLevel(octant, level, depth, result) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tif (depth === level) {\\n\\n  \\t\\tresult.push(octant);\\n  \\t} else if (children !== null) {\\n\\n  \\t\\t++depth;\\n\\n  \\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t_findOctantsByLevel(children[i], level, depth, result);\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  var Octree = function () {\\n  \\tfunction Octree(min, max) {\\n  \\t\\tclassCallCheck(this, Octree);\\n\\n\\n  \\t\\tthis.root = min !== undefined && max !== undefined ? new Octant(min, max) : null;\\n  \\t}\\n\\n  \\tcreateClass(Octree, [{\\n  \\t\\tkey: "getCenter",\\n  \\t\\tvalue: function getCenter(target) {\\n  \\t\\t\\treturn this.root.getCenter(target);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getDimensions",\\n  \\t\\tvalue: function getDimensions(target) {\\n  \\t\\t\\treturn this.root.getDimensions(target);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "getDepth",\\n  \\t\\tvalue: function getDepth() {\\n  \\t\\t\\treturn _getDepth(this.root);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "cull",\\n  \\t\\tvalue: function cull(region) {\\n\\n  \\t\\t\\tvar result = [];\\n\\n  \\t\\t\\t_cull(this.root, region, result);\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "findOctantsByLevel",\\n  \\t\\tvalue: function findOctantsByLevel(level) {\\n\\n  \\t\\t\\tvar result = [];\\n\\n  \\t\\t\\t_findOctantsByLevel(this.root, level, 0, result);\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "raycast",\\n  \\t\\tvalue: function raycast(raycaster) {\\n  \\t\\t\\tvar intersects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\\n\\n\\n  \\t\\t\\tOctreeRaycaster.intersectOctree(this, raycaster, intersects);\\n\\n  \\t\\t\\treturn intersects;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "leaves",\\n  \\t\\tvalue: function leaves(region) {\\n\\n  \\t\\t\\treturn new OctantIterator(this, region);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: Symbol.iterator,\\n  \\t\\tvalue: function value() {\\n\\n  \\t\\t\\treturn new OctantIterator(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "min",\\n  \\t\\tget: function get$$1() {\\n  \\t\\t\\treturn this.root.min;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "max",\\n  \\t\\tget: function get$$1() {\\n  \\t\\t\\treturn this.root.max;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "children",\\n  \\t\\tget: function get$$1() {\\n  \\t\\t\\treturn this.root.children;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Octree;\\n  }();\\n\\n  var p = new Vector3();\\n\\n  var PointOctant = function (_Octant) {\\n  \\tinherits(PointOctant, _Octant);\\n\\n  \\tfunction PointOctant(min, max) {\\n  \\t\\tclassCallCheck(this, PointOctant);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (PointOctant.__proto__ || Object.getPrototypeOf(PointOctant)).call(this, min, max));\\n\\n  \\t\\t_this.points = null;\\n\\n  \\t\\t_this.data = null;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\tcreateClass(PointOctant, [{\\n  \\t\\tkey: "distanceToSquared",\\n  \\t\\tvalue: function distanceToSquared(point) {\\n\\n  \\t\\t\\tvar clampedPoint = p.copy(point).clamp(this.min, this.max);\\n\\n  \\t\\t\\treturn clampedPoint.sub(point).lengthSquared();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "distanceToCenterSquared",\\n  \\t\\tvalue: function distanceToCenterSquared(point) {\\n\\n  \\t\\t\\tvar center = this.getCenter(p);\\n\\n  \\t\\t\\tvar dx = point.x - center.x;\\n  \\t\\t\\tvar dy = point.y - center.x;\\n  \\t\\t\\tvar dz = point.z - center.z;\\n\\n  \\t\\t\\treturn dx * dx + dy * dy + dz * dz;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "contains",\\n  \\t\\tvalue: function contains(point, bias) {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar max = this.max;\\n\\n  \\t\\t\\treturn point.x >= min.x - bias && point.y >= min.y - bias && point.z >= min.z - bias && point.x <= max.x + bias && point.y <= max.y + bias && point.z <= max.z + bias;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "redistribute",\\n  \\t\\tvalue: function redistribute(bias) {\\n\\n  \\t\\t\\tvar children = this.children;\\n  \\t\\t\\tvar points = this.points;\\n  \\t\\t\\tvar data = this.data;\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    j = void 0,\\n  \\t\\t\\t    il = void 0,\\n  \\t\\t\\t    jl = void 0;\\n  \\t\\t\\tvar child = void 0,\\n  \\t\\t\\t    point = void 0,\\n  \\t\\t\\t    entry = void 0;\\n\\n  \\t\\t\\tif (children !== null) {\\n\\n  \\t\\t\\t\\tfor (i = 0, il = points.length; i < il; ++i) {\\n\\n  \\t\\t\\t\\t\\tpoint = points[i];\\n  \\t\\t\\t\\t\\tentry = data[i];\\n\\n  \\t\\t\\t\\t\\tfor (j = 0, jl = children.length; j < jl; ++j) {\\n\\n  \\t\\t\\t\\t\\t\\tchild = children[j];\\n\\n  \\t\\t\\t\\t\\t\\tif (child.contains(point, bias)) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tif (child.points === null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tchild.points = [];\\n  \\t\\t\\t\\t\\t\\t\\t\\tchild.data = [];\\n  \\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\tchild.points.push(point);\\n  \\t\\t\\t\\t\\t\\t\\tchild.data.push(entry);\\n\\n  \\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tthis.points = null;\\n  \\t\\t\\tthis.data = null;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "merge",\\n  \\t\\tvalue: function merge() {\\n\\n  \\t\\t\\tvar children = this.children;\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n  \\t\\t\\tvar child = void 0;\\n\\n  \\t\\t\\tif (children !== null) {\\n\\n  \\t\\t\\t\\tthis.points = [];\\n  \\t\\t\\t\\tthis.data = [];\\n\\n  \\t\\t\\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\tchild = children[i];\\n\\n  \\t\\t\\t\\t\\tif (child.points !== null) {\\n  \\t\\t\\t\\t\\t\\tvar _points, _data;\\n\\n  \\t\\t\\t\\t\\t\\t(_points = this.points).push.apply(_points, toConsumableArray(child.points));\\n  \\t\\t\\t\\t\\t\\t(_data = this.data).push.apply(_data, toConsumableArray(child.data));\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tthis.children = null;\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn PointOctant;\\n  }(Octant);\\n\\n  var RayPointIntersection = function RayPointIntersection(distance, distanceToRay, point) {\\n  \\t\\tvar object = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\\n  \\t\\tclassCallCheck(this, RayPointIntersection);\\n\\n\\n  \\t\\tthis.distance = distance;\\n\\n  \\t\\tthis.distanceToRay = distanceToRay;\\n\\n  \\t\\tthis.point = point;\\n\\n  \\t\\tthis.object = object;\\n  };\\n\\n  var THRESHOLD = 1e-6;\\n\\n  function _countPoints(octant) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = 0;\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tif (children !== null) {\\n\\n  \\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\tresult += _countPoints(children[i]);\\n  \\t\\t}\\n  \\t} else if (octant.points !== null) {\\n\\n  \\t\\tresult = octant.points.length;\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _put(point, data, octree, octant, depth) {\\n\\n  \\tvar children = octant.children;\\n  \\tvar exists = false;\\n  \\tvar done = false;\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tif (octant.contains(point, octree.bias)) {\\n\\n  \\t\\tif (children === null) {\\n\\n  \\t\\t\\tif (octant.points === null) {\\n\\n  \\t\\t\\t\\toctant.points = [];\\n  \\t\\t\\t\\toctant.data = [];\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tfor (i = 0, l = octant.points.length; !exists && i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\texists = octant.points[i].equals(point);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (exists) {\\n\\n  \\t\\t\\t\\toctant.data[i - 1] = data;\\n  \\t\\t\\t\\tdone = true;\\n  \\t\\t\\t} else if (octant.points.length < octree.maxPoints || depth === octree.maxDepth) {\\n\\n  \\t\\t\\t\\toctant.points.push(point.clone());\\n  \\t\\t\\t\\toctant.data.push(data);\\n  \\t\\t\\t\\t++octree.pointCount;\\n  \\t\\t\\t\\tdone = true;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\toctant.split();\\n  \\t\\t\\t\\toctant.redistribute(octree.bias);\\n  \\t\\t\\t\\tchildren = octant.children;\\n  \\t\\t\\t}\\n  \\t\\t}\\n\\n  \\t\\tif (children !== null) {\\n\\n  \\t\\t\\t++depth;\\n\\n  \\t\\t\\tfor (i = 0, l = children.length; !done && i < l; ++i) {\\n\\n  \\t\\t\\t\\tdone = _put(point, data, octree, children[i], depth);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn done;\\n  }\\n\\n  function _remove(point, octree, octant, parent) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = null;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n  \\tvar points = void 0,\\n  \\t    data = void 0,\\n  \\t    last = void 0;\\n\\n  \\tif (octant.contains(point, octree.bias)) {\\n\\n  \\t\\tif (children !== null) {\\n\\n  \\t\\t\\tfor (i = 0, l = children.length; result === null && i < l; ++i) {\\n\\n  \\t\\t\\t\\tresult = _remove(point, octree, children[i], octant);\\n  \\t\\t\\t}\\n  \\t\\t} else if (octant.points !== null) {\\n\\n  \\t\\t\\tpoints = octant.points;\\n  \\t\\t\\tdata = octant.data;\\n\\n  \\t\\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tif (points[i].equals(point)) {\\n\\n  \\t\\t\\t\\t\\tlast = l - 1;\\n  \\t\\t\\t\\t\\tresult = data[i];\\n\\n  \\t\\t\\t\\t\\tif (i < last) {\\n  \\t\\t\\t\\t\\t\\tpoints[i] = points[last];\\n  \\t\\t\\t\\t\\t\\tdata[i] = data[last];\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tpoints.pop();\\n  \\t\\t\\t\\t\\tdata.pop();\\n\\n  \\t\\t\\t\\t\\t--octree.pointCount;\\n\\n  \\t\\t\\t\\t\\tif (parent !== null && _countPoints(parent) <= octree.maxPoints) {\\n\\n  \\t\\t\\t\\t\\t\\tparent.merge();\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _fetch(point, octree, octant) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = null;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n  \\tvar points = void 0;\\n\\n  \\tif (octant.contains(point, octree.bias)) {\\n\\n  \\t\\tif (children !== null) {\\n\\n  \\t\\t\\tfor (i = 0, l = children.length; result === null && i < l; ++i) {\\n\\n  \\t\\t\\t\\tresult = _fetch(point, octree, children[i]);\\n  \\t\\t\\t}\\n  \\t\\t} else {\\n\\n  \\t\\t\\tpoints = octant.points;\\n\\n  \\t\\t\\tfor (i = 0, l = points.length; result === null && i < l; ++i) {\\n\\n  \\t\\t\\t\\tif (point.distanceToSquared(points[i]) <= THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\tresult = octant.data[i];\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _move(point, position, octree, octant, parent, depth) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = null;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n  \\tvar points = void 0;\\n\\n  \\tif (octant.contains(point, octree.bias)) {\\n\\n  \\t\\tif (octant.contains(position, octree.bias)) {\\n  \\t\\t\\tif (children !== null) {\\n\\n  \\t\\t\\t\\t++depth;\\n\\n  \\t\\t\\t\\tfor (i = 0, l = children.length; result === null && i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\tresult = _move(point, position, octree, children[i], octant, depth);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n  \\t\\t\\t\\tpoints = octant.points;\\n\\n  \\t\\t\\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\tif (point.distanceToSquared(points[i]) <= THRESHOLD) {\\n  \\t\\t\\t\\t\\t\\tpoints[i].copy(position);\\n  \\t\\t\\t\\t\\t\\tresult = octant.data[i];\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t} else {\\n  \\t\\t\\tresult = _remove(point, octree, octant, parent);\\n\\n  \\t\\t\\t_put(position, result, octree, parent, depth - 1);\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _findNearestPoint(point, maxDistance, skipSelf, octant) {\\n\\n  \\tvar points = octant.points;\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = null;\\n  \\tvar bestDist = maxDistance;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n  \\tvar p = void 0,\\n  \\t    distSq = void 0;\\n\\n  \\tvar sortedChildren = void 0;\\n  \\tvar child = void 0,\\n  \\t    childResult = void 0;\\n\\n  \\tif (children !== null) {\\n  \\t\\tsortedChildren = children.map(function (child) {\\n  \\t\\t\\treturn {\\n  \\t\\t\\t\\toctant: child,\\n  \\t\\t\\t\\tdistance: child.distanceToCenterSquared(point)\\n  \\t\\t\\t};\\n  \\t\\t}).sort(function (a, b) {\\n  \\t\\t\\treturn a.distance - b.distance;\\n  \\t\\t});\\n\\n  \\t\\tfor (i = 0, l = sortedChildren.length; i < l; ++i) {\\n  \\t\\t\\tchild = sortedChildren[i].octant;\\n\\n  \\t\\t\\tif (child.contains(point, bestDist)) {\\n\\n  \\t\\t\\t\\tchildResult = _findNearestPoint(point, bestDist, skipSelf, child);\\n\\n  \\t\\t\\t\\tif (childResult !== null) {\\n\\n  \\t\\t\\t\\t\\tdistSq = childResult.point.distanceToSquared(point);\\n\\n  \\t\\t\\t\\t\\tif ((!skipSelf || distSq > 0.0) && distSq < bestDist) {\\n\\n  \\t\\t\\t\\t\\t\\tbestDist = distSq;\\n  \\t\\t\\t\\t\\t\\tresult = childResult;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t} else if (points !== null) {\\n\\n  \\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\tp = points[i];\\n  \\t\\t\\tdistSq = point.distanceToSquared(p);\\n\\n  \\t\\t\\tif ((!skipSelf || distSq > 0.0) && distSq < bestDist) {\\n\\n  \\t\\t\\t\\tbestDist = distSq;\\n\\n  \\t\\t\\t\\tresult = {\\n  \\t\\t\\t\\t\\tpoint: p.clone(),\\n  \\t\\t\\t\\t\\tdata: octant.data[i]\\n  \\t\\t\\t\\t};\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _findPoints(point, radius, skipSelf, octant, result) {\\n\\n  \\tvar points = octant.points;\\n  \\tvar children = octant.children;\\n  \\tvar rSq = radius * radius;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tvar p = void 0,\\n  \\t    distSq = void 0;\\n  \\tvar child = void 0;\\n\\n  \\tif (children !== null) {\\n\\n  \\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\tchild = children[i];\\n\\n  \\t\\t\\tif (child.contains(point, radius)) {\\n\\n  \\t\\t\\t\\t_findPoints(point, radius, skipSelf, child, result);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t} else if (points !== null) {\\n\\n  \\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\tp = points[i];\\n  \\t\\t\\tdistSq = point.distanceToSquared(p);\\n\\n  \\t\\t\\tif ((!skipSelf || distSq > 0.0) && distSq <= rSq) {\\n\\n  \\t\\t\\t\\tresult.push({\\n  \\t\\t\\t\\t\\tpoint: p.clone(),\\n  \\t\\t\\t\\t\\tdata: octant.data[i]\\n  \\t\\t\\t\\t});\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  var PointOctree = function (_Octree) {\\n  \\tinherits(PointOctree, _Octree);\\n\\n  \\tfunction PointOctree(min, max) {\\n  \\t\\tvar bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0;\\n  \\t\\tvar maxPoints = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\\n  \\t\\tvar maxDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 8;\\n  \\t\\tclassCallCheck(this, PointOctree);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (PointOctree.__proto__ || Object.getPrototypeOf(PointOctree)).call(this));\\n\\n  \\t\\t_this.root = new PointOctant(min, max);\\n\\n  \\t\\t_this.bias = Math.max(0.0, bias);\\n\\n  \\t\\t_this.maxPoints = Math.max(1, Math.round(maxPoints));\\n\\n  \\t\\t_this.maxDepth = Math.max(0, Math.round(maxDepth));\\n\\n  \\t\\t_this.pointCount = 0;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\tcreateClass(PointOctree, [{\\n  \\t\\tkey: "countPoints",\\n  \\t\\tvalue: function countPoints(octant) {\\n\\n  \\t\\t\\treturn _countPoints(octant);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "put",\\n  \\t\\tvalue: function put(point, data) {\\n\\n  \\t\\t\\treturn _put(point, data, this, this.root, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "remove",\\n  \\t\\tvalue: function remove(point) {\\n\\n  \\t\\t\\treturn _remove(point, this, this.root, null);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "fetch",\\n  \\t\\tvalue: function fetch(point) {\\n\\n  \\t\\t\\treturn _fetch(point, this, this.root);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "move",\\n  \\t\\tvalue: function move(point, position) {\\n\\n  \\t\\t\\treturn _move(point, position, this, this.root, null, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "findNearestPoint",\\n  \\t\\tvalue: function findNearestPoint(point) {\\n  \\t\\t\\tvar maxDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\\n  \\t\\t\\tvar skipSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\\n\\n\\n  \\t\\t\\treturn _findNearestPoint(point, maxDistance, skipSelf, this.root);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "findPoints",\\n  \\t\\tvalue: function findPoints(point, radius) {\\n  \\t\\t\\tvar skipSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\\n\\n\\n  \\t\\t\\tvar result = [];\\n\\n  \\t\\t\\t_findPoints(point, radius, skipSelf, this.root, result);\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "raycast",\\n  \\t\\tvalue: function raycast(raycaster) {\\n  \\t\\t\\tvar intersects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\\n\\n\\n  \\t\\t\\tvar octants = get(PointOctree.prototype.__proto__ || Object.getPrototypeOf(PointOctree.prototype), "raycast", this).call(this, raycaster);\\n\\n  \\t\\t\\tif (octants.length > 0) {\\n  \\t\\t\\t\\tthis.testPoints(octants, raycaster, intersects);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn intersects;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "testPoints",\\n  \\t\\tvalue: function testPoints(octants, raycaster, intersects) {\\n\\n  \\t\\t\\tvar threshold = raycaster.params.Points.threshold;\\n  \\t\\t\\tvar thresholdSq = threshold * threshold;\\n\\n  \\t\\t\\tvar intersectPoint = void 0;\\n  \\t\\t\\tvar distance = void 0,\\n  \\t\\t\\t    distanceToRay = void 0;\\n  \\t\\t\\tvar rayPointDistanceSq = void 0;\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    j = void 0,\\n  \\t\\t\\t    il = void 0,\\n  \\t\\t\\t    jl = void 0;\\n  \\t\\t\\tvar octant = void 0,\\n  \\t\\t\\t    points = void 0,\\n  \\t\\t\\t    point = void 0;\\n\\n  \\t\\t\\tfor (i = 0, il = octants.length; i < il; ++i) {\\n\\n  \\t\\t\\t\\toctant = octants[i];\\n  \\t\\t\\t\\tpoints = octant.points;\\n\\n  \\t\\t\\t\\tif (points !== null) {\\n\\n  \\t\\t\\t\\t\\tfor (j = 0, jl = points.length; j < jl; ++j) {\\n\\n  \\t\\t\\t\\t\\t\\tpoint = points[j];\\n  \\t\\t\\t\\t\\t\\trayPointDistanceSq = raycaster.ray.distanceSqToPoint(point);\\n\\n  \\t\\t\\t\\t\\t\\tif (rayPointDistanceSq < thresholdSq) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tintersectPoint = raycaster.ray.closestPointToPoint(point);\\n  \\t\\t\\t\\t\\t\\t\\tdistance = raycaster.ray.origin.distanceTo(intersectPoint);\\n\\n  \\t\\t\\t\\t\\t\\t\\tif (distance >= raycaster.near && distance <= raycaster.far) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tdistanceToRay = Math.sqrt(rayPointDistanceSq);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tintersects.push(new RayPointIntersection(distance, distanceToRay, intersectPoint, octant.data[j]));\\n  \\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn PointOctree;\\n  }(Octree);\\n\\n  var b$6 = new Box3();\\n\\n  var c$3 = new Vector3();\\n\\n  var u = new Vector3();\\n\\n  var v$5 = new Vector3();\\n\\n  var OctreeUtils = function () {\\n  \\tfunction OctreeUtils() {\\n  \\t\\tclassCallCheck(this, OctreeUtils);\\n  \\t}\\n\\n  \\tcreateClass(OctreeUtils, null, [{\\n  \\t\\tkey: "recycleOctants",\\n  \\t\\tvalue: function recycleOctants(octant, octants) {\\n\\n  \\t\\t\\tvar min = octant.min;\\n  \\t\\t\\tvar mid = octant.getCenter(u);\\n  \\t\\t\\tvar halfDimensions = octant.getDimensions(v$5).multiplyScalar(0.5);\\n\\n  \\t\\t\\tvar children = octant.children;\\n  \\t\\t\\tvar l = octants.length;\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    j = void 0;\\n  \\t\\t\\tvar combination = void 0,\\n  \\t\\t\\t    candidate = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\t\\tcombination = pattern[i];\\n\\n  \\t\\t\\t\\tb$6.min.addVectors(min, c$3.fromArray(combination).multiply(halfDimensions));\\n  \\t\\t\\t\\tb$6.max.addVectors(mid, c$3.fromArray(combination).multiply(halfDimensions));\\n\\n  \\t\\t\\t\\tfor (j = 0; j < l; ++j) {\\n\\n  \\t\\t\\t\\t\\tcandidate = octants[j];\\n\\n  \\t\\t\\t\\t\\tif (candidate !== null && b$6.min.equals(candidate.min) && b$6.max.equals(candidate.max)) {\\n\\n  \\t\\t\\t\\t\\t\\tchildren[i] = candidate;\\n  \\t\\t\\t\\t\\t\\toctants[j] = null;\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn OctreeUtils;\\n  }();\\n\\n  var ISOVALUE_BIAS = 1e-4;\\n\\n  var INTERVAL_THRESHOLD = 1e-6;\\n\\n  var ab = new Vector3();\\n\\n  var p$1 = new Vector3();\\n\\n  var v$6 = new Vector3();\\n\\n  var Edge = function () {\\n  \\t\\tfunction Edge() {\\n  \\t\\t\\t\\tvar a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\t\\t\\tvar b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n  \\t\\t\\t\\tclassCallCheck(this, Edge);\\n\\n\\n  \\t\\t\\t\\tthis.a = a;\\n\\n  \\t\\t\\t\\tthis.b = b;\\n\\n  \\t\\t\\t\\tthis.index = -1;\\n\\n  \\t\\t\\t\\tthis.coordinates = new Vector3();\\n\\n  \\t\\t\\t\\tthis.t = 0.0;\\n\\n  \\t\\t\\t\\tthis.n = new Vector3();\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Edge, [{\\n  \\t\\t\\t\\tkey: "approximateZeroCrossing",\\n  \\t\\t\\t\\tvalue: function approximateZeroCrossing(sdf) {\\n  \\t\\t\\t\\t\\t\\tvar steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar s = Math.max(1, steps - 1);\\n\\n  \\t\\t\\t\\t\\t\\tvar a = 0.0;\\n  \\t\\t\\t\\t\\t\\tvar b = 1.0;\\n  \\t\\t\\t\\t\\t\\tvar c = 0.0;\\n  \\t\\t\\t\\t\\t\\tvar i = 0;\\n\\n  \\t\\t\\t\\t\\t\\tvar densityA = void 0,\\n  \\t\\t\\t\\t\\t\\t    densityC = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tab.subVectors(this.b, this.a);\\n\\n  \\t\\t\\t\\t\\t\\twhile (i <= s) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tc = (a + b) / 2;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tp$1.addVectors(this.a, v$6.copy(ab).multiplyScalar(c));\\n  \\t\\t\\t\\t\\t\\t\\t\\tdensityC = sdf.sample(p$1);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (Math.abs(densityC) <= ISOVALUE_BIAS || (b - a) / 2 <= INTERVAL_THRESHOLD) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp$1.addVectors(this.a, v$6.copy(ab).multiplyScalar(a));\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdensityA = sdf.sample(p$1);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (Math.sign(densityC) === Math.sign(densityA)) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ta = c;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tb = c;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t++i;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tthis.t = c;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "computeZeroCrossingPosition",\\n  \\t\\t\\t\\tvalue: function computeZeroCrossingPosition() {\\n  \\t\\t\\t\\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\t\\t\\t\\treturn target.subVectors(this.b, this.a).multiplyScalar(this.t).add(this.a);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "computeSurfaceNormal",\\n  \\t\\t\\t\\tvalue: function computeSurfaceNormal(sdf) {\\n\\n  \\t\\t\\t\\t\\t\\tvar position = this.computeZeroCrossingPosition(ab);\\n  \\t\\t\\t\\t\\t\\tvar E = 1e-3;\\n\\n  \\t\\t\\t\\t\\t\\tvar dx = sdf.sample(p$1.addVectors(position, v$6.set(E, 0, 0))) - sdf.sample(p$1.subVectors(position, v$6.set(E, 0, 0)));\\n  \\t\\t\\t\\t\\t\\tvar dy = sdf.sample(p$1.addVectors(position, v$6.set(0, E, 0))) - sdf.sample(p$1.subVectors(position, v$6.set(0, E, 0)));\\n  \\t\\t\\t\\t\\t\\tvar dz = sdf.sample(p$1.addVectors(position, v$6.set(0, 0, E))) - sdf.sample(p$1.subVectors(position, v$6.set(0, 0, E)));\\n\\n  \\t\\t\\t\\t\\t\\tthis.n.set(dx, dy, dz).normalize();\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Edge;\\n  }();\\n\\n  var edge = new Edge();\\n\\n  var offsetA = new Vector3();\\n\\n  var offsetB = new Vector3();\\n\\n  var EdgeIterator = function () {\\n  \\t\\tfunction EdgeIterator(edgeData, cellPosition, cellSize) {\\n  \\t\\t\\t\\tvar c = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\\n  \\t\\t\\t\\tvar d = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 3;\\n  \\t\\t\\t\\tclassCallCheck(this, EdgeIterator);\\n\\n\\n  \\t\\t\\t\\tthis.edgeData = edgeData;\\n\\n  \\t\\t\\t\\tthis.cellPosition = cellPosition;\\n\\n  \\t\\t\\t\\tthis.cellSize = cellSize;\\n\\n  \\t\\t\\t\\tthis.indices = null;\\n\\n  \\t\\t\\t\\tthis.zeroCrossings = null;\\n\\n  \\t\\t\\t\\tthis.normals = null;\\n\\n  \\t\\t\\t\\tthis.axes = null;\\n\\n  \\t\\t\\t\\tthis.lengths = null;\\n\\n  \\t\\t\\t\\tthis.result = new IteratorResult();\\n\\n  \\t\\t\\t\\tthis.initialC = c;\\n\\n  \\t\\t\\t\\tthis.c = c;\\n\\n  \\t\\t\\t\\tthis.initialD = d;\\n\\n  \\t\\t\\t\\tthis.d = d;\\n\\n  \\t\\t\\t\\tthis.i = 0;\\n\\n  \\t\\t\\t\\tthis.l = 0;\\n\\n  \\t\\t\\t\\tthis.reset();\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(EdgeIterator, [{\\n  \\t\\t\\t\\tkey: "reset",\\n  \\t\\t\\t\\tvalue: function reset() {\\n\\n  \\t\\t\\t\\t\\t\\tvar edgeData = this.edgeData;\\n  \\t\\t\\t\\t\\t\\tvar indices = [];\\n  \\t\\t\\t\\t\\t\\tvar zeroCrossings = [];\\n  \\t\\t\\t\\t\\t\\tvar normals = [];\\n  \\t\\t\\t\\t\\t\\tvar axes = [];\\n  \\t\\t\\t\\t\\t\\tvar lengths = [];\\n\\n  \\t\\t\\t\\t\\t\\tvar a = void 0,\\n  \\t\\t\\t\\t\\t\\t    c = void 0,\\n  \\t\\t\\t\\t\\t\\t    d = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tthis.i = 0;\\n  \\t\\t\\t\\t\\t\\tthis.c = 0;\\n  \\t\\t\\t\\t\\t\\tthis.d = 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (c = this.initialC, a = 4 >> c, d = this.initialD; c < d; ++c, a >>= 1) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tl = edgeData.indices[c].length;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (l > 0) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tindices.push(edgeData.indices[c]);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tzeroCrossings.push(edgeData.zeroCrossings[c]);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals.push(edgeData.normals[c]);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\taxes.push(pattern[a]);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlengths.push(l);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++this.d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tthis.l = lengths.length > 0 ? lengths[0] : 0;\\n\\n  \\t\\t\\t\\t\\t\\tthis.indices = indices;\\n  \\t\\t\\t\\t\\t\\tthis.zeroCrossings = zeroCrossings;\\n  \\t\\t\\t\\t\\t\\tthis.normals = normals;\\n  \\t\\t\\t\\t\\t\\tthis.axes = axes;\\n  \\t\\t\\t\\t\\t\\tthis.lengths = lengths;\\n\\n  \\t\\t\\t\\t\\t\\tthis.result.reset();\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "next",\\n  \\t\\t\\t\\tvalue: function next() {\\n\\n  \\t\\t\\t\\t\\t\\tvar s = this.cellSize;\\n  \\t\\t\\t\\t\\t\\tvar n = HermiteData.resolution;\\n  \\t\\t\\t\\t\\t\\tvar m = n + 1;\\n  \\t\\t\\t\\t\\t\\tvar mm = m * m;\\n\\n  \\t\\t\\t\\t\\t\\tvar result = this.result;\\n  \\t\\t\\t\\t\\t\\tvar base = this.cellPosition;\\n\\n  \\t\\t\\t\\t\\t\\tvar axis = void 0,\\n  \\t\\t\\t\\t\\t\\t    index = void 0;\\n  \\t\\t\\t\\t\\t\\tvar x = void 0,\\n  \\t\\t\\t\\t\\t\\t    y = void 0,\\n  \\t\\t\\t\\t\\t\\t    z = void 0;\\n  \\t\\t\\t\\t\\t\\tvar c = void 0,\\n  \\t\\t\\t\\t\\t\\t    i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tif (this.i === this.l) {\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.l = ++this.c < this.d ? this.lengths[this.c] : 0;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.i = 0;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tif (this.i < this.l) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tc = this.c;\\n  \\t\\t\\t\\t\\t\\t\\t\\ti = this.i;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\taxis = this.axes[c];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tindex = this.indices[c][i];\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.index = index;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tx = index % m;\\n  \\t\\t\\t\\t\\t\\t\\t\\ty = Math.trunc(index % mm / m);\\n  \\t\\t\\t\\t\\t\\t\\t\\tz = Math.trunc(index / mm);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.coordinates.set(x, y, z);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\toffsetA.set(x * s / n, y * s / n, z * s / n);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\toffsetB.set((x + axis[0]) * s / n, (y + axis[1]) * s / n, (z + axis[2]) * s / n);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.a.addVectors(base, offsetA);\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.b.addVectors(base, offsetB);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.t = this.zeroCrossings[c][i];\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.n.fromArray(this.normals[c], i * 3);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tresult.value = edge;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t++this.i;\\n  \\t\\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\t\\t\\tresult.value = null;\\n  \\t\\t\\t\\t\\t\\t\\t\\tresult.done = true;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "return",\\n  \\t\\t\\t\\tvalue: function _return(value) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.result.value = value;\\n  \\t\\t\\t\\t\\t\\tthis.result.done = true;\\n\\n  \\t\\t\\t\\t\\t\\treturn this.result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: Symbol.iterator,\\n  \\t\\t\\t\\tvalue: function value() {\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn EdgeIterator;\\n  }();\\n\\n  var EdgeData = function () {\\n  \\tfunction EdgeData() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\\n  \\t\\tvar z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : x;\\n  \\t\\tclassCallCheck(this, EdgeData);\\n\\n\\n  \\t\\tthis.indices = x <= 0 ? null : [new Uint32Array(x), new Uint32Array(y), new Uint32Array(z)];\\n\\n  \\t\\tthis.zeroCrossings = x <= 0 ? null : [new Float32Array(x), new Float32Array(y), new Float32Array(z)];\\n\\n  \\t\\tthis.normals = x <= 0 ? null : [new Float32Array(x * 3), new Float32Array(y * 3), new Float32Array(z * 3)];\\n  \\t}\\n\\n  \\tcreateClass(EdgeData, [{\\n  \\t\\tkey: "serialize",\\n  \\t\\tvalue: function serialize() {\\n  \\t\\t\\treturn {\\n  \\t\\t\\t\\tedges: this.edges,\\n  \\t\\t\\t\\tzeroCrossings: this.zeroCrossings,\\n  \\t\\t\\t\\tnormals: this.normals\\n  \\t\\t\\t};\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "deserialize",\\n  \\t\\tvalue: function deserialize(object) {\\n\\n  \\t\\t\\tvar result = this;\\n\\n  \\t\\t\\tif (object !== null) {\\n\\n  \\t\\t\\t\\tthis.edges = object.edges;\\n  \\t\\t\\t\\tthis.zeroCrossings = object.zeroCrossings;\\n  \\t\\t\\t\\tthis.normals = object.normals;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tresult = null;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "createTransferList",\\n  \\t\\tvalue: function createTransferList() {\\n  \\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\tvar arrays = [this.edges[0], this.edges[1], this.edges[2], this.zeroCrossings[0], this.zeroCrossings[1], this.zeroCrossings[2], this.normals[0], this.normals[1], this.normals[2]];\\n\\n  \\t\\t\\tvar array = void 0;\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\tfor (i = 0, l = arrays.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tarray = arrays[i];\\n\\n  \\t\\t\\t\\tif (array !== null) {\\n\\n  \\t\\t\\t\\t\\ttransferList.push(array.buffer);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn transferList;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "edges",\\n  \\t\\tvalue: function edges(cellPosition, cellSize) {\\n\\n  \\t\\t\\treturn new EdgeIterator(this, cellPosition, cellSize);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "edgesX",\\n  \\t\\tvalue: function edgesX(cellPosition, cellSize) {\\n\\n  \\t\\t\\treturn new EdgeIterator(this, cellPosition, cellSize, 0, 1);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "edgesY",\\n  \\t\\tvalue: function edgesY(cellPosition, cellSize) {\\n\\n  \\t\\t\\treturn new EdgeIterator(this, cellPosition, cellSize, 1, 2);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "edgesZ",\\n  \\t\\tvalue: function edgesZ(cellPosition, cellSize) {\\n\\n  \\t\\t\\treturn new EdgeIterator(this, cellPosition, cellSize, 2, 3);\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: "calculate1DEdgeCount",\\n  \\t\\tvalue: function calculate1DEdgeCount(n) {\\n\\n  \\t\\t\\treturn Math.pow(n + 1, 2) * n;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn EdgeData;\\n  }();\\n\\n  var Material = {\\n\\n    AIR: 0,\\n    SOLID: 1\\n\\n  };\\n\\n  var resolution = 0;\\n\\n  var indexCount = 0;\\n\\n  function ceil2(n) {\\n\\n  \\treturn Math.pow(2, Math.max(0, Math.ceil(Math.log2(n))));\\n  }\\n\\n  var HermiteData = function () {\\n  \\tfunction HermiteData() {\\n  \\t\\tvar initialize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\\n  \\t\\tclassCallCheck(this, HermiteData);\\n\\n\\n  \\t\\tthis.materials = 0;\\n\\n  \\t\\tthis.materialIndices = initialize ? new Uint8Array(indexCount) : null;\\n\\n  \\t\\tthis.runLengths = null;\\n\\n  \\t\\tthis.edgeData = null;\\n  \\t}\\n\\n  \\tcreateClass(HermiteData, [{\\n  \\t\\tkey: "set",\\n  \\t\\tvalue: function set$$1(data) {\\n\\n  \\t\\t\\tthis.materials = data.materials;\\n  \\t\\t\\tthis.materialIndices = data.materialIndices;\\n  \\t\\t\\tthis.runLengths = data.runLengths;\\n  \\t\\t\\tthis.edgeData = data.edgeData;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "clear",\\n  \\t\\tvalue: function clear() {\\n\\n  \\t\\t\\tthis.materials = 0;\\n  \\t\\t\\tthis.materialIndices = null;\\n  \\t\\t\\tthis.runLengths = null;\\n  \\t\\t\\tthis.edgeData = null;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setMaterialIndex",\\n  \\t\\tvalue: function setMaterialIndex(index, value) {\\n  \\t\\t\\tif (this.materialIndices[index] === Material.AIR) {\\n\\n  \\t\\t\\t\\tif (value !== Material.AIR) {\\n\\n  \\t\\t\\t\\t\\t++this.materials;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else if (value === Material.AIR) {\\n\\n  \\t\\t\\t\\t--this.materials;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tthis.materialIndices[index] = value;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "compress",\\n  \\t\\tvalue: function compress() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\\n\\n\\n  \\t\\t\\tvar encoding = void 0;\\n\\n  \\t\\t\\tif (!this.compressed) {\\n  \\t\\t\\t\\tif (this.full) {\\n  \\t\\t\\t\\t\\tencoding = new RunLengthEncoding([this.materialIndices.length], [Material.SOLID]);\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tencoding = RunLengthEncoding.encode(this.materialIndices);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\ttarget.materialIndices = new Uint8Array(encoding.data);\\n  \\t\\t\\t\\ttarget.runLengths = new Uint32Array(encoding.runLengths);\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\ttarget.materialIndices = this.materialIndices;\\n  \\t\\t\\t\\ttarget.runLengths = this.runLengths;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\ttarget.materials = this.materials;\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "decompress",\\n  \\t\\tvalue: function decompress() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\\n\\n\\n  \\t\\t\\ttarget.materialIndices = !this.compressed ? this.materialIndices : RunLengthEncoding.decode(this.runLengths, this.materialIndices, new Uint8Array(indexCount));\\n\\n  \\t\\t\\ttarget.runLengths = null;\\n  \\t\\t\\ttarget.materials = this.materials;\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "serialize",\\n  \\t\\tvalue: function serialize() {\\n  \\t\\t\\treturn {\\n  \\t\\t\\t\\tmaterials: this.materials,\\n  \\t\\t\\t\\tmaterialIndices: this.materialIndices,\\n  \\t\\t\\t\\trunLengths: this.runLengths,\\n  \\t\\t\\t\\tedgeData: this.edgeData !== null ? this.edgeData.serialize() : null\\n  \\t\\t\\t};\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "deserialize",\\n  \\t\\tvalue: function deserialize(object) {\\n\\n  \\t\\t\\tvar result = this;\\n\\n  \\t\\t\\tif (object !== null) {\\n\\n  \\t\\t\\t\\tthis.materials = object.materials;\\n  \\t\\t\\t\\tthis.materialIndices = object.materialIndices;\\n  \\t\\t\\t\\tthis.runLengths = object.runLengths;\\n\\n  \\t\\t\\t\\tif (object.edgeData !== null) {\\n\\n  \\t\\t\\t\\t\\tif (this.edgeData === null) {\\n  \\t\\t\\t\\t\\t\\tthis.edgeData = new EdgeData();\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tthis.edgeData.deserialize(object.edgeData);\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tthis.edgeData = null;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tresult = null;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "createTransferList",\\n  \\t\\tvalue: function createTransferList() {\\n  \\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\tif (this.edgeData !== null) {\\n\\n  \\t\\t\\t\\tthis.edgeData.createTransferList(transferList);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (this.materialIndices !== null) {\\n\\n  \\t\\t\\t\\ttransferList.push(this.materialIndices.buffer);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (this.runLengths !== null) {\\n\\n  \\t\\t\\t\\ttransferList.push(this.runLengths.buffer);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn transferList;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "empty",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn this.materials === 0;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "full",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn this.materials === indexCount;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "compressed",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn this.runLengths !== null;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "neutered",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn !this.empty && this.materialIndices === null;\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: "resolution",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn resolution;\\n  \\t\\t},\\n  \\t\\tset: function set$$1(value) {\\n\\n  \\t\\t\\tresolution = Math.max(1, Math.min(256, ceil2(value)));\\n  \\t\\t\\tindexCount = Math.pow(resolution + 1, 3);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn HermiteData;\\n  }();\\n\\n  var QEFData = function () {\\n  \\t\\tfunction QEFData() {\\n  \\t\\t\\t\\tclassCallCheck(this, QEFData);\\n\\n\\n  \\t\\t\\t\\tthis.ata = new SymmetricMatrix3();\\n\\n  \\t\\t\\t\\tthis.ata.set(0, 0, 0, 0, 0, 0);\\n\\n  \\t\\t\\t\\tthis.atb = new Vector3();\\n\\n  \\t\\t\\t\\tthis.massPointSum = new Vector3();\\n\\n  \\t\\t\\t\\tthis.numPoints = 0;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(QEFData, [{\\n  \\t\\t\\t\\tkey: "set",\\n  \\t\\t\\t\\tvalue: function set$$1(ata, atb, massPointSum, numPoints) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.ata.copy(ata);\\n  \\t\\t\\t\\t\\t\\tthis.atb.copy(atb);\\n\\n  \\t\\t\\t\\t\\t\\tthis.massPointSum.copy(massPointSum);\\n  \\t\\t\\t\\t\\t\\tthis.numPoints = numPoints;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "copy",\\n  \\t\\t\\t\\tvalue: function copy(d) {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.set(d.ata, d.atb, d.massPointSum, d.numPoints);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "add",\\n  \\t\\t\\t\\tvalue: function add(p, n) {\\n\\n  \\t\\t\\t\\t\\t\\tvar nx = n.x;\\n  \\t\\t\\t\\t\\t\\tvar ny = n.y;\\n  \\t\\t\\t\\t\\t\\tvar nz = n.z;\\n\\n  \\t\\t\\t\\t\\t\\tvar b = p.dot(n);\\n\\n  \\t\\t\\t\\t\\t\\tvar ata = this.ata.elements;\\n  \\t\\t\\t\\t\\t\\tvar atb = this.atb;\\n\\n  \\t\\t\\t\\t\\t\\tata[0] += nx * nx;\\n  \\t\\t\\t\\t\\t\\tata[1] += nx * ny;ata[3] += ny * ny;\\n  \\t\\t\\t\\t\\t\\tata[2] += nx * nz;ata[4] += ny * nz;ata[5] += nz * nz;\\n\\n  \\t\\t\\t\\t\\t\\tatb.x += b * nx;\\n  \\t\\t\\t\\t\\t\\tatb.y += b * ny;\\n  \\t\\t\\t\\t\\t\\tatb.z += b * nz;\\n\\n  \\t\\t\\t\\t\\t\\tthis.massPointSum.add(p);\\n\\n  \\t\\t\\t\\t\\t\\t++this.numPoints;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "addData",\\n  \\t\\t\\t\\tvalue: function addData(d) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.ata.add(d.ata);\\n  \\t\\t\\t\\t\\t\\tthis.atb.add(d.atb);\\n\\n  \\t\\t\\t\\t\\t\\tthis.massPointSum.add(d.massPointSum);\\n  \\t\\t\\t\\t\\t\\tthis.numPoints += d.numPoints;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "clear",\\n  \\t\\t\\t\\tvalue: function clear() {\\n\\n  \\t\\t\\t\\t\\t\\tthis.ata.set(0, 0, 0, 0, 0, 0);\\n\\n  \\t\\t\\t\\t\\t\\tthis.atb.set(0, 0, 0);\\n  \\t\\t\\t\\t\\t\\tthis.massPointSum.set(0, 0, 0);\\n  \\t\\t\\t\\t\\t\\tthis.numPoints = 0;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "clone",\\n  \\t\\t\\t\\tvalue: function clone() {\\n\\n  \\t\\t\\t\\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn QEFData;\\n  }();\\n\\n  var coefficients = new Vector2();\\n\\n  var Givens = function () {\\n  \\tfunction Givens() {\\n  \\t\\tclassCallCheck(this, Givens);\\n  \\t}\\n\\n  \\tcreateClass(Givens, null, [{\\n  \\t\\tkey: "calculateCoefficients",\\n  \\t\\tvalue: function calculateCoefficients(aPP, aPQ, aQQ) {\\n\\n  \\t\\t\\tvar tau = void 0,\\n  \\t\\t\\t    stt = void 0,\\n  \\t\\t\\t    tan = void 0;\\n\\n  \\t\\t\\tif (aPQ === 0.0) {\\n\\n  \\t\\t\\t\\tcoefficients.x = 1.0;\\n  \\t\\t\\t\\tcoefficients.y = 0.0;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\ttau = (aQQ - aPP) / (2.0 * aPQ);\\n  \\t\\t\\t\\tstt = Math.sqrt(1.0 + tau * tau);\\n  \\t\\t\\t\\ttan = 1.0 / (tau >= 0.0 ? tau + stt : tau - stt);\\n\\n  \\t\\t\\t\\tcoefficients.x = 1.0 / Math.sqrt(1.0 + tan * tan);\\n  \\t\\t\\t\\tcoefficients.y = tan * coefficients.x;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn coefficients;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Givens;\\n  }();\\n\\n  var Schur = function () {\\n  \\tfunction Schur() {\\n  \\t\\tclassCallCheck(this, Schur);\\n  \\t}\\n\\n  \\tcreateClass(Schur, null, [{\\n  \\t\\tkey: "rotateXY",\\n  \\t\\tvalue: function rotateXY(a, coefficients) {\\n\\n  \\t\\t\\tvar c = coefficients.x;\\n  \\t\\t\\tvar s = coefficients.y;\\n\\n  \\t\\t\\tvar u = a.x;\\n  \\t\\t\\tvar v = a.y;\\n\\n  \\t\\t\\ta.set(c * u - s * v, s * u + c * v);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "rotateQXY",\\n  \\t\\tvalue: function rotateQXY(a, q, coefficients) {\\n\\n  \\t\\t\\tvar c = coefficients.x;\\n  \\t\\t\\tvar s = coefficients.y;\\n  \\t\\t\\tvar cc = c * c;\\n  \\t\\t\\tvar ss = s * s;\\n\\n  \\t\\t\\tvar mx = 2.0 * c * s * q;\\n\\n  \\t\\t\\tvar u = a.x;\\n  \\t\\t\\tvar v = a.y;\\n\\n  \\t\\t\\ta.set(cc * u - mx + ss * v, ss * u + mx + cc * v);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Schur;\\n  }();\\n\\n  var PSEUDOINVERSE_THRESHOLD = 1e-1;\\n\\n  var SVD_SWEEPS = 5;\\n\\n  var sm = new SymmetricMatrix3();\\n\\n  var m$1 = new Matrix3();\\n\\n  var a$3 = new Vector2();\\n\\n  var b$7 = new Vector3();\\n\\n  function rotate01(vtav, v) {\\n\\n  \\tvar se = vtav.elements;\\n  \\tvar ve = v.elements;\\n\\n  \\tvar coefficients = void 0;\\n\\n  \\tif (se[1] !== 0.0) {\\n\\n  \\t\\tcoefficients = Givens.calculateCoefficients(se[0], se[1], se[3]);\\n\\n  \\t\\tSchur.rotateQXY(a$3.set(se[0], se[3]), se[1], coefficients);\\n  \\t\\tse[0] = a$3.x;se[3] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(se[2], se[4]), coefficients);\\n  \\t\\tse[2] = a$3.x;se[4] = a$3.y;\\n\\n  \\t\\tse[1] = 0.0;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[0], ve[3]), coefficients);\\n  \\t\\tve[0] = a$3.x;ve[3] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[1], ve[4]), coefficients);\\n  \\t\\tve[1] = a$3.x;ve[4] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[2], ve[5]), coefficients);\\n  \\t\\tve[2] = a$3.x;ve[5] = a$3.y;\\n  \\t}\\n  }\\n\\n  function rotate02(vtav, v) {\\n\\n  \\tvar se = vtav.elements;\\n  \\tvar ve = v.elements;\\n\\n  \\tvar coefficients = void 0;\\n\\n  \\tif (se[2] !== 0.0) {\\n\\n  \\t\\tcoefficients = Givens.calculateCoefficients(se[0], se[2], se[5]);\\n\\n  \\t\\tSchur.rotateQXY(a$3.set(se[0], se[5]), se[2], coefficients);\\n  \\t\\tse[0] = a$3.x;se[5] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(se[1], se[4]), coefficients);\\n  \\t\\tse[1] = a$3.x;se[4] = a$3.y;\\n\\n  \\t\\tse[2] = 0.0;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[0], ve[6]), coefficients);\\n  \\t\\tve[0] = a$3.x;ve[6] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[1], ve[7]), coefficients);\\n  \\t\\tve[1] = a$3.x;ve[7] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[2], ve[8]), coefficients);\\n  \\t\\tve[2] = a$3.x;ve[8] = a$3.y;\\n  \\t}\\n  }\\n\\n  function rotate12(vtav, v) {\\n\\n  \\tvar se = vtav.elements;\\n  \\tvar ve = v.elements;\\n\\n  \\tvar coefficients = void 0;\\n\\n  \\tif (se[4] !== 0.0) {\\n\\n  \\t\\tcoefficients = Givens.calculateCoefficients(se[3], se[4], se[5]);\\n\\n  \\t\\tSchur.rotateQXY(a$3.set(se[3], se[5]), se[4], coefficients);\\n  \\t\\tse[3] = a$3.x;se[5] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(se[1], se[2]), coefficients);\\n  \\t\\tse[1] = a$3.x;se[2] = a$3.y;\\n\\n  \\t\\tse[4] = 0.0;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[3], ve[6]), coefficients);\\n  \\t\\tve[3] = a$3.x;ve[6] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[4], ve[7]), coefficients);\\n  \\t\\tve[4] = a$3.x;ve[7] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[5], ve[8]), coefficients);\\n  \\t\\tve[5] = a$3.x;ve[8] = a$3.y;\\n  \\t}\\n  }\\n\\n  function solveSymmetric(vtav, v) {\\n\\n  \\tvar e = vtav.elements;\\n\\n  \\tvar i = void 0;\\n\\n  \\tfor (i = 0; i < SVD_SWEEPS; ++i) {\\n  \\t\\trotate01(vtav, v);\\n  \\t\\trotate02(vtav, v);\\n  \\t\\trotate12(vtav, v);\\n  \\t}\\n\\n  \\treturn b$7.set(e[0], e[3], e[5]);\\n  }\\n\\n  function invert(x) {\\n\\n  \\tvar invX = Math.abs(x) < PSEUDOINVERSE_THRESHOLD ? 0.0 : 1.0 / x;\\n\\n  \\treturn Math.abs(invX) < PSEUDOINVERSE_THRESHOLD ? 0.0 : invX;\\n  }\\n\\n  function pseudoInverse(v, sigma) {\\n\\n  \\tvar ve = v.elements;\\n\\n  \\tvar v00 = ve[0],\\n  \\t    v01 = ve[3],\\n  \\t    v02 = ve[6];\\n  \\tvar v10 = ve[1],\\n  \\t    v11 = ve[4],\\n  \\t    v12 = ve[7];\\n  \\tvar v20 = ve[2],\\n  \\t    v21 = ve[5],\\n  \\t    v22 = ve[8];\\n\\n  \\tvar d0 = invert(sigma.x);\\n  \\tvar d1 = invert(sigma.y);\\n  \\tvar d2 = invert(sigma.z);\\n\\n  \\treturn v.set(v00 * d0 * v00 + v01 * d1 * v01 + v02 * d2 * v02, v00 * d0 * v10 + v01 * d1 * v11 + v02 * d2 * v12, v00 * d0 * v20 + v01 * d1 * v21 + v02 * d2 * v22, v10 * d0 * v00 + v11 * d1 * v01 + v12 * d2 * v02, v10 * d0 * v10 + v11 * d1 * v11 + v12 * d2 * v12, v10 * d0 * v20 + v11 * d1 * v21 + v12 * d2 * v22, v20 * d0 * v00 + v21 * d1 * v01 + v22 * d2 * v02, v20 * d0 * v10 + v21 * d1 * v11 + v22 * d2 * v12, v20 * d0 * v20 + v21 * d1 * v21 + v22 * d2 * v22);\\n  }\\n\\n  var SingularValueDecomposition = function () {\\n  \\tfunction SingularValueDecomposition() {\\n  \\t\\tclassCallCheck(this, SingularValueDecomposition);\\n  \\t}\\n\\n  \\tcreateClass(SingularValueDecomposition, null, [{\\n  \\t\\tkey: "solve",\\n  \\t\\tvalue: function solve(ata, atb, x) {\\n\\n  \\t\\t\\tvar sigma = solveSymmetric(sm.copy(ata), m$1.identity());\\n  \\t\\t\\tvar invV = pseudoInverse(m$1, sigma);\\n\\n  \\t\\t\\tx.copy(atb).applyMatrix3(invV);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn SingularValueDecomposition;\\n  }();\\n\\n  var p$2 = new Vector3();\\n\\n  function calculateError(ata, atb, x) {\\n\\n  \\t\\tata.applyToVector3(p$2.copy(x));\\n  \\t\\tp$2.subVectors(atb, p$2);\\n\\n  \\t\\treturn p$2.dot(p$2);\\n  }\\n\\n  var QEFSolver = function () {\\n  \\t\\tfunction QEFSolver() {\\n  \\t\\t\\t\\tclassCallCheck(this, QEFSolver);\\n\\n\\n  \\t\\t\\t\\tthis.data = null;\\n\\n  \\t\\t\\t\\tthis.ata = new SymmetricMatrix3();\\n\\n  \\t\\t\\t\\tthis.atb = new Vector3();\\n\\n  \\t\\t\\t\\tthis.massPoint = new Vector3();\\n\\n  \\t\\t\\t\\tthis.hasSolution = false;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(QEFSolver, [{\\n  \\t\\t\\t\\tkey: "setData",\\n  \\t\\t\\t\\tvalue: function setData(d) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.data = d;\\n  \\t\\t\\t\\t\\t\\tthis.hasSolution = false;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "solve",\\n  \\t\\t\\t\\tvalue: function solve(x) {\\n\\n  \\t\\t\\t\\t\\t\\tvar data = this.data;\\n  \\t\\t\\t\\t\\t\\tvar massPoint = this.massPoint;\\n  \\t\\t\\t\\t\\t\\tvar ata = this.ata.copy(data.ata);\\n  \\t\\t\\t\\t\\t\\tvar atb = this.atb.copy(data.atb);\\n\\n  \\t\\t\\t\\t\\t\\tvar error = Infinity;\\n\\n  \\t\\t\\t\\t\\t\\tif (!this.hasSolution && data !== null && data.numPoints > 0) {\\n  \\t\\t\\t\\t\\t\\t\\t\\tp$2.copy(data.massPointSum).divideScalar(data.numPoints);\\n  \\t\\t\\t\\t\\t\\t\\t\\tmassPoint.copy(p$2);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tata.applyToVector3(p$2);\\n  \\t\\t\\t\\t\\t\\t\\t\\tatb.sub(p$2);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tSingularValueDecomposition.solve(ata, atb, x);\\n  \\t\\t\\t\\t\\t\\t\\t\\terror = calculateError(ata, atb, x);\\n  \\t\\t\\t\\t\\t\\t\\t\\tx.add(massPoint);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.hasSolution = true;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn error;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn QEFSolver;\\n  }();\\n\\n  var Voxel = function Voxel() {\\n  \\t\\tclassCallCheck(this, Voxel);\\n\\n\\n  \\t\\tthis.materials = 0;\\n\\n  \\t\\tthis.edgeCount = 0;\\n\\n  \\t\\tthis.index = -1;\\n\\n  \\t\\tthis.position = new Vector3();\\n\\n  \\t\\tthis.normal = new Vector3();\\n\\n  \\t\\tthis.qefData = null;\\n  };\\n\\n  var qefSolver = new QEFSolver();\\n\\n  var BIAS = 1e-1;\\n\\n  var errorThreshold = -1;\\n\\n  var VoxelCell = function (_CubicOctant) {\\n  \\tinherits(VoxelCell, _CubicOctant);\\n\\n  \\tfunction VoxelCell(min, size) {\\n  \\t\\tclassCallCheck(this, VoxelCell);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (VoxelCell.__proto__ || Object.getPrototypeOf(VoxelCell)).call(this, min, size));\\n\\n  \\t\\t_this.voxel = null;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\tcreateClass(VoxelCell, [{\\n  \\t\\tkey: "contains",\\n  \\t\\tvalue: function contains(p) {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar size = this.size;\\n\\n  \\t\\t\\treturn p.x >= min.x - BIAS && p.y >= min.y - BIAS && p.z >= min.z - BIAS && p.x <= min.x + size + BIAS && p.y <= min.y + size + BIAS && p.z <= min.z + size + BIAS;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "collapse",\\n  \\t\\tvalue: function collapse() {\\n\\n  \\t\\t\\tvar children = this.children;\\n\\n  \\t\\t\\tvar signs = [-1, -1, -1, -1, -1, -1, -1, -1];\\n\\n  \\t\\t\\tvar position = new Vector3();\\n\\n  \\t\\t\\tvar midSign = -1;\\n  \\t\\t\\tvar collapsible = children !== null;\\n\\n  \\t\\t\\tvar removedVoxels = 0;\\n\\n  \\t\\t\\tvar child = void 0,\\n  \\t\\t\\t    sign = void 0,\\n  \\t\\t\\t    voxel = void 0;\\n  \\t\\t\\tvar qefData = void 0,\\n  \\t\\t\\t    error = void 0;\\n\\n  \\t\\t\\tvar v = void 0,\\n  \\t\\t\\t    i = void 0;\\n\\n  \\t\\t\\tif (collapsible) {\\n\\n  \\t\\t\\t\\tqefData = new QEFData();\\n\\n  \\t\\t\\t\\tfor (v = 0, i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\t\\t\\tchild = children[i];\\n  \\t\\t\\t\\t\\tremovedVoxels += child.collapse();\\n  \\t\\t\\t\\t\\tvoxel = child.voxel;\\n\\n  \\t\\t\\t\\t\\tif (child.children !== null) {\\n  \\t\\t\\t\\t\\t\\tcollapsible = false;\\n  \\t\\t\\t\\t\\t} else if (voxel !== null) {\\n\\n  \\t\\t\\t\\t\\t\\tqefData.addData(voxel.qefData);\\n\\n  \\t\\t\\t\\t\\t\\tmidSign = voxel.materials >> 7 - i & 1;\\n  \\t\\t\\t\\t\\t\\tsigns[i] = voxel.materials >> i & 1;\\n\\n  \\t\\t\\t\\t\\t\\t++v;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (collapsible) {\\n\\n  \\t\\t\\t\\t\\terror = qefSolver.setData(qefData).solve(position);\\n\\n  \\t\\t\\t\\t\\tif (error <= errorThreshold) {\\n\\n  \\t\\t\\t\\t\\t\\tvoxel = new Voxel();\\n  \\t\\t\\t\\t\\t\\tvoxel.position.copy(this.contains(position) ? position : qefSolver.massPoint);\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tsign = signs[i];\\n  \\t\\t\\t\\t\\t\\t\\tchild = children[i];\\n\\n  \\t\\t\\t\\t\\t\\t\\tif (sign === -1) {\\n  \\t\\t\\t\\t\\t\\t\\t\\tvoxel.materials |= midSign << i;\\n  \\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tvoxel.materials |= sign << i;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tvoxel.normal.add(child.voxel.normal);\\n  \\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tvoxel.normal.normalize();\\n  \\t\\t\\t\\t\\t\\tvoxel.qefData = qefData;\\n\\n  \\t\\t\\t\\t\\t\\tthis.voxel = voxel;\\n  \\t\\t\\t\\t\\t\\tthis.children = null;\\n\\n  \\t\\t\\t\\t\\t\\tremovedVoxels += v - 1;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn removedVoxels;\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: "errorThreshold",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn errorThreshold;\\n  \\t\\t},\\n  \\t\\tset: function set$$1(value) {\\n\\n  \\t\\t\\terrorThreshold = value;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn VoxelCell;\\n  }(CubicOctant);\\n\\n  var Message = function Message() {\\n  \\t\\tvar action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\\n  \\t\\tclassCallCheck(this, Message);\\n\\n\\n  \\t\\tthis.action = action;\\n\\n  \\t\\tthis.error = null;\\n  };\\n\\n  var Isosurface = function () {\\n  \\t\\tfunction Isosurface(indices, positions, normals, uvs, materials) {\\n  \\t\\t\\t\\tclassCallCheck(this, Isosurface);\\n\\n\\n  \\t\\t\\t\\tthis.indices = indices;\\n\\n  \\t\\t\\t\\tthis.positions = positions;\\n\\n  \\t\\t\\t\\tthis.normals = normals;\\n\\n  \\t\\t\\t\\tthis.uvs = uvs;\\n\\n  \\t\\t\\t\\tthis.materials = materials;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Isosurface, [{\\n  \\t\\t\\t\\tkey: "serialize",\\n  \\t\\t\\t\\tvalue: function serialize() {\\n  \\t\\t\\t\\t\\t\\treturn {\\n  \\t\\t\\t\\t\\t\\t\\t\\tindices: this.indices,\\n  \\t\\t\\t\\t\\t\\t\\t\\tpositions: this.positions,\\n  \\t\\t\\t\\t\\t\\t\\t\\tnormals: this.normals,\\n  \\t\\t\\t\\t\\t\\t\\t\\tuvs: this.uvs,\\n  \\t\\t\\t\\t\\t\\t\\t\\tmaterials: this.materials\\n  \\t\\t\\t\\t\\t\\t};\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "deserialize",\\n  \\t\\t\\t\\tvalue: function deserialize(object) {\\n\\n  \\t\\t\\t\\t\\t\\tvar result = this;\\n\\n  \\t\\t\\t\\t\\t\\tif (object !== null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.indices = object.indices;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.positions = object.positions;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.normals = object.normals;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.uvs = object.uvs;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.materials = object.materials;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tresult = null;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "createTransferList",\\n  \\t\\t\\t\\tvalue: function createTransferList() {\\n  \\t\\t\\t\\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.indices.buffer);\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.positions.buffer);\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.normals.buffer);\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.uvs.buffer);\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.materials.buffer);\\n\\n  \\t\\t\\t\\t\\t\\treturn transferList;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Isosurface;\\n  }();\\n\\n  var cellProcFaceMask = [new Uint8Array([0, 4, 0]), new Uint8Array([1, 5, 0]), new Uint8Array([2, 6, 0]), new Uint8Array([3, 7, 0]), new Uint8Array([0, 2, 1]), new Uint8Array([4, 6, 1]), new Uint8Array([1, 3, 1]), new Uint8Array([5, 7, 1]), new Uint8Array([0, 1, 2]), new Uint8Array([2, 3, 2]), new Uint8Array([4, 5, 2]), new Uint8Array([6, 7, 2])];\\n\\n  var cellProcEdgeMask = [new Uint8Array([0, 1, 2, 3, 0]), new Uint8Array([4, 5, 6, 7, 0]), new Uint8Array([0, 4, 1, 5, 1]), new Uint8Array([2, 6, 3, 7, 1]), new Uint8Array([0, 2, 4, 6, 2]), new Uint8Array([1, 3, 5, 7, 2])];\\n\\n  var faceProcFaceMask = [[new Uint8Array([4, 0, 0]), new Uint8Array([5, 1, 0]), new Uint8Array([6, 2, 0]), new Uint8Array([7, 3, 0])], [new Uint8Array([2, 0, 1]), new Uint8Array([6, 4, 1]), new Uint8Array([3, 1, 1]), new Uint8Array([7, 5, 1])], [new Uint8Array([1, 0, 2]), new Uint8Array([3, 2, 2]), new Uint8Array([5, 4, 2]), new Uint8Array([7, 6, 2])]];\\n\\n  var faceProcEdgeMask = [[new Uint8Array([1, 4, 0, 5, 1, 1]), new Uint8Array([1, 6, 2, 7, 3, 1]), new Uint8Array([0, 4, 6, 0, 2, 2]), new Uint8Array([0, 5, 7, 1, 3, 2])], [new Uint8Array([0, 2, 3, 0, 1, 0]), new Uint8Array([0, 6, 7, 4, 5, 0]), new Uint8Array([1, 2, 0, 6, 4, 2]), new Uint8Array([1, 3, 1, 7, 5, 2])], [new Uint8Array([1, 1, 0, 3, 2, 0]), new Uint8Array([1, 5, 4, 7, 6, 0]), new Uint8Array([0, 1, 5, 0, 4, 1]), new Uint8Array([0, 3, 7, 2, 6, 1])]];\\n\\n  var edgeProcEdgeMask = [[new Uint8Array([3, 2, 1, 0, 0]), new Uint8Array([7, 6, 5, 4, 0])], [new Uint8Array([5, 1, 4, 0, 1]), new Uint8Array([7, 3, 6, 2, 1])], [new Uint8Array([6, 4, 2, 0, 2]), new Uint8Array([7, 5, 3, 1, 2])]];\\n\\n  var procEdgeMask = [new Uint8Array([3, 2, 1, 0]), new Uint8Array([7, 5, 6, 4]), new Uint8Array([11, 10, 9, 8])];\\n\\n  var MAX_VERTEX_COUNT = Math.pow(2, 16) - 1;\\n\\n  function contourProcessEdge(octants, dir, indexBuffer) {\\n\\n  \\tvar indices = [-1, -1, -1, -1];\\n  \\tvar signChange = [false, false, false, false];\\n\\n  \\tvar minSize = Infinity;\\n  \\tvar minIndex = 0;\\n  \\tvar flip = false;\\n\\n  \\tvar c1 = void 0,\\n  \\t    c2 = void 0,\\n  \\t    m1 = void 0,\\n  \\t    m2 = void 0;\\n  \\tvar octant = void 0,\\n  \\t    edge = void 0;\\n  \\tvar i = void 0;\\n\\n  \\tfor (i = 0; i < 4; ++i) {\\n\\n  \\t\\toctant = octants[i];\\n  \\t\\tedge = procEdgeMask[dir][i];\\n\\n  \\t\\tc1 = edges[edge][0];\\n  \\t\\tc2 = edges[edge][1];\\n\\n  \\t\\tm1 = octant.voxel.materials >> c1 & 1;\\n  \\t\\tm2 = octant.voxel.materials >> c2 & 1;\\n\\n  \\t\\tif (octant.size < minSize) {\\n\\n  \\t\\t\\tminSize = octant.size;\\n  \\t\\t\\tminIndex = i;\\n  \\t\\t\\tflip = m1 !== Material.AIR;\\n  \\t\\t}\\n\\n  \\t\\tindices[i] = octant.voxel.index;\\n  \\t\\tsignChange[i] = m1 !== m2;\\n  \\t}\\n\\n  \\tif (signChange[minIndex]) {\\n\\n  \\t\\tif (!flip) {\\n\\n  \\t\\t\\tindexBuffer.push(indices[0]);\\n  \\t\\t\\tindexBuffer.push(indices[1]);\\n  \\t\\t\\tindexBuffer.push(indices[3]);\\n\\n  \\t\\t\\tindexBuffer.push(indices[0]);\\n  \\t\\t\\tindexBuffer.push(indices[3]);\\n  \\t\\t\\tindexBuffer.push(indices[2]);\\n  \\t\\t} else {\\n\\n  \\t\\t\\tindexBuffer.push(indices[0]);\\n  \\t\\t\\tindexBuffer.push(indices[3]);\\n  \\t\\t\\tindexBuffer.push(indices[1]);\\n\\n  \\t\\t\\tindexBuffer.push(indices[0]);\\n  \\t\\t\\tindexBuffer.push(indices[2]);\\n  \\t\\t\\tindexBuffer.push(indices[3]);\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function contourEdgeProc(octants, dir, indexBuffer) {\\n\\n  \\tvar c = [0, 0, 0, 0];\\n\\n  \\tvar edgeOctants = void 0;\\n  \\tvar octant = void 0;\\n  \\tvar i = void 0,\\n  \\t    j = void 0;\\n\\n  \\tif (octants[0].voxel !== null && octants[1].voxel !== null && octants[2].voxel !== null && octants[3].voxel !== null) {\\n\\n  \\t\\tcontourProcessEdge(octants, dir, indexBuffer);\\n  \\t} else {\\n\\n  \\t\\tfor (i = 0; i < 2; ++i) {\\n\\n  \\t\\t\\tc[0] = edgeProcEdgeMask[dir][i][0];\\n  \\t\\t\\tc[1] = edgeProcEdgeMask[dir][i][1];\\n  \\t\\t\\tc[2] = edgeProcEdgeMask[dir][i][2];\\n  \\t\\t\\tc[3] = edgeProcEdgeMask[dir][i][3];\\n\\n  \\t\\t\\tedgeOctants = [];\\n\\n  \\t\\t\\tfor (j = 0; j < 4; ++j) {\\n\\n  \\t\\t\\t\\toctant = octants[j];\\n\\n  \\t\\t\\t\\tif (octant.voxel !== null) {\\n\\n  \\t\\t\\t\\t\\tedgeOctants[j] = octant;\\n  \\t\\t\\t\\t} else if (octant.children !== null) {\\n\\n  \\t\\t\\t\\t\\tedgeOctants[j] = octant.children[c[j]];\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (j === 4) {\\n\\n  \\t\\t\\t\\tcontourEdgeProc(edgeOctants, edgeProcEdgeMask[dir][i][4], indexBuffer);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function contourFaceProc(octants, dir, indexBuffer) {\\n\\n  \\tvar c = [0, 0, 0, 0];\\n\\n  \\tvar orders = [[0, 0, 1, 1], [0, 1, 0, 1]];\\n\\n  \\tvar faceOctants = void 0,\\n  \\t    edgeOctants = void 0;\\n  \\tvar order = void 0,\\n  \\t    octant = void 0;\\n  \\tvar i = void 0,\\n  \\t    j = void 0;\\n\\n  \\tif (octants[0].children !== null || octants[1].children !== null) {\\n\\n  \\t\\tfor (i = 0; i < 4; ++i) {\\n\\n  \\t\\t\\tc[0] = faceProcFaceMask[dir][i][0];\\n  \\t\\t\\tc[1] = faceProcFaceMask[dir][i][1];\\n\\n  \\t\\t\\tfaceOctants = [octants[0].children === null ? octants[0] : octants[0].children[c[0]], octants[1].children === null ? octants[1] : octants[1].children[c[1]]];\\n\\n  \\t\\t\\tcontourFaceProc(faceOctants, faceProcFaceMask[dir][i][2], indexBuffer);\\n  \\t\\t}\\n\\n  \\t\\tfor (i = 0; i < 4; ++i) {\\n\\n  \\t\\t\\tc[0] = faceProcEdgeMask[dir][i][1];\\n  \\t\\t\\tc[1] = faceProcEdgeMask[dir][i][2];\\n  \\t\\t\\tc[2] = faceProcEdgeMask[dir][i][3];\\n  \\t\\t\\tc[3] = faceProcEdgeMask[dir][i][4];\\n\\n  \\t\\t\\torder = orders[faceProcEdgeMask[dir][i][0]];\\n\\n  \\t\\t\\tedgeOctants = [];\\n\\n  \\t\\t\\tfor (j = 0; j < 4; ++j) {\\n\\n  \\t\\t\\t\\toctant = octants[order[j]];\\n\\n  \\t\\t\\t\\tif (octant.voxel !== null) {\\n\\n  \\t\\t\\t\\t\\tedgeOctants[j] = octant;\\n  \\t\\t\\t\\t} else if (octant.children !== null) {\\n\\n  \\t\\t\\t\\t\\tedgeOctants[j] = octant.children[c[j]];\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (j === 4) {\\n\\n  \\t\\t\\t\\tcontourEdgeProc(edgeOctants, faceProcEdgeMask[dir][i][5], indexBuffer);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function contourCellProc(octant, indexBuffer) {\\n\\n  \\tvar children = octant.children;\\n  \\tvar c = [0, 0, 0, 0];\\n\\n  \\tvar faceOctants = void 0,\\n  \\t    edgeOctants = void 0;\\n  \\tvar i = void 0;\\n\\n  \\tif (children !== null) {\\n\\n  \\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\tcontourCellProc(children[i], indexBuffer);\\n  \\t\\t}\\n\\n  \\t\\tfor (i = 0; i < 12; ++i) {\\n\\n  \\t\\t\\tc[0] = cellProcFaceMask[i][0];\\n  \\t\\t\\tc[1] = cellProcFaceMask[i][1];\\n\\n  \\t\\t\\tfaceOctants = [children[c[0]], children[c[1]]];\\n\\n  \\t\\t\\tcontourFaceProc(faceOctants, cellProcFaceMask[i][2], indexBuffer);\\n  \\t\\t}\\n\\n  \\t\\tfor (i = 0; i < 6; ++i) {\\n\\n  \\t\\t\\tc[0] = cellProcEdgeMask[i][0];\\n  \\t\\t\\tc[1] = cellProcEdgeMask[i][1];\\n  \\t\\t\\tc[2] = cellProcEdgeMask[i][2];\\n  \\t\\t\\tc[3] = cellProcEdgeMask[i][3];\\n\\n  \\t\\t\\tedgeOctants = [children[c[0]], children[c[1]], children[c[2]], children[c[3]]];\\n\\n  \\t\\t\\tcontourEdgeProc(edgeOctants, cellProcEdgeMask[i][4], indexBuffer);\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function generateVertexIndices(octant, positions, normals, index) {\\n\\n  \\tvar i = void 0,\\n  \\t    voxel = void 0;\\n\\n  \\tif (octant.children !== null) {\\n\\n  \\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\tindex = generateVertexIndices(octant.children[i], positions, normals, index);\\n  \\t\\t}\\n  \\t} else if (octant.voxel !== null) {\\n\\n  \\t\\tvoxel = octant.voxel;\\n  \\t\\tvoxel.index = index;\\n\\n  \\t\\tpositions[index * 3] = voxel.position.x;\\n  \\t\\tpositions[index * 3 + 1] = voxel.position.y;\\n  \\t\\tpositions[index * 3 + 2] = voxel.position.z;\\n\\n  \\t\\tnormals[index * 3] = voxel.normal.x;\\n  \\t\\tnormals[index * 3 + 1] = voxel.normal.y;\\n  \\t\\tnormals[index * 3 + 2] = voxel.normal.z;\\n\\n  \\t\\t++index;\\n  \\t}\\n\\n  \\treturn index;\\n  }\\n\\n  var DualContouring = function () {\\n  \\tfunction DualContouring() {\\n  \\t\\tclassCallCheck(this, DualContouring);\\n  \\t}\\n\\n  \\tcreateClass(DualContouring, null, [{\\n  \\t\\tkey: "run",\\n  \\t\\tvalue: function run(svo) {\\n\\n  \\t\\t\\tvar indexBuffer = [];\\n\\n  \\t\\t\\tvar vertexCount = svo.voxelCount;\\n\\n  \\t\\t\\tvar result = null;\\n  \\t\\t\\tvar positions = null;\\n  \\t\\t\\tvar normals = null;\\n  \\t\\t\\tvar uvs = null;\\n  \\t\\t\\tvar materials = null;\\n\\n  \\t\\t\\tif (vertexCount > MAX_VERTEX_COUNT) {\\n\\n  \\t\\t\\t\\tconsole.warn("Could not create geometry for cell at position", svo.min, "(vertex count of", vertexCount, "exceeds limit of ", MAX_VERTEX_COUNT, ")");\\n  \\t\\t\\t} else if (vertexCount > 0) {\\n\\n  \\t\\t\\t\\tpositions = new Float32Array(vertexCount * 3);\\n  \\t\\t\\t\\tnormals = new Float32Array(vertexCount * 3);\\n  \\t\\t\\t\\tuvs = new Float32Array(vertexCount * 2);\\n  \\t\\t\\t\\tmaterials = new Uint8Array(vertexCount);\\n\\n  \\t\\t\\t\\tgenerateVertexIndices(svo.root, positions, normals, 0);\\n  \\t\\t\\t\\tcontourCellProc(svo.root, indexBuffer);\\n\\n  \\t\\t\\t\\tresult = new Isosurface(new Uint16Array(indexBuffer), positions, normals, uvs, materials);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn DualContouring;\\n  }();\\n\\n  function getCell(cell, n, x, y, z) {\\n\\n  \\t\\tvar i = 0;\\n\\n  \\t\\tfor (n = n >> 1; n > 0; n >>= 1, i = 0) {\\n  \\t\\t\\t\\tif (x >= n) {\\n\\n  \\t\\t\\t\\t\\t\\ti += 4;x -= n;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (y >= n) {\\n\\n  \\t\\t\\t\\t\\t\\ti += 2;y -= n;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (z >= n) {\\n\\n  \\t\\t\\t\\t\\t\\ti += 1;z -= n;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (cell.children === null) {\\n\\n  \\t\\t\\t\\t\\t\\tcell.split();\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcell = cell.children[i];\\n  \\t\\t}\\n\\n  \\t\\treturn cell;\\n  }\\n\\n  function createVoxel(n, x, y, z, materialIndices) {\\n\\n  \\t\\tvar m = n + 1;\\n  \\t\\tvar mm = m * m;\\n\\n  \\t\\tvar voxel = new Voxel();\\n\\n  \\t\\tvar materials = void 0,\\n  \\t\\t    edgeCount = void 0;\\n  \\t\\tvar material = void 0,\\n  \\t\\t    offset = void 0,\\n  \\t\\t    index = void 0;\\n  \\t\\tvar c1 = void 0,\\n  \\t\\t    c2 = void 0,\\n  \\t\\t    m1 = void 0,\\n  \\t\\t    m2 = void 0;\\n\\n  \\t\\tvar i = void 0;\\n\\n  \\t\\tfor (materials = 0, i = 0; i < 8; ++i) {\\n  \\t\\t\\t\\toffset = pattern[i];\\n  \\t\\t\\t\\tindex = (z + offset[2]) * mm + (y + offset[1]) * m + (x + offset[0]);\\n\\n  \\t\\t\\t\\tmaterial = Math.min(materialIndices[index], Material.SOLID);\\n\\n  \\t\\t\\t\\tmaterials |= material << i;\\n  \\t\\t}\\n\\n  \\t\\tfor (edgeCount = 0, i = 0; i < 12; ++i) {\\n\\n  \\t\\t\\t\\tc1 = edges[i][0];\\n  \\t\\t\\t\\tc2 = edges[i][1];\\n\\n  \\t\\t\\t\\tm1 = materials >> c1 & 1;\\n  \\t\\t\\t\\tm2 = materials >> c2 & 1;\\n\\n  \\t\\t\\t\\tif (m1 !== m2) {\\n\\n  \\t\\t\\t\\t\\t\\t++edgeCount;\\n  \\t\\t\\t\\t}\\n  \\t\\t}\\n\\n  \\t\\tvoxel.materials = materials;\\n  \\t\\tvoxel.edgeCount = edgeCount;\\n  \\t\\tvoxel.qefData = new QEFData();\\n\\n  \\t\\treturn voxel;\\n  }\\n\\n  var SparseVoxelOctree = function (_Octree) {\\n  \\t\\tinherits(SparseVoxelOctree, _Octree);\\n\\n  \\t\\tfunction SparseVoxelOctree(data) {\\n  \\t\\t\\t\\tvar min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n  \\t\\t\\t\\tvar size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n  \\t\\t\\t\\tclassCallCheck(this, SparseVoxelOctree);\\n\\n  \\t\\t\\t\\tvar _this = possibleConstructorReturn(this, (SparseVoxelOctree.__proto__ || Object.getPrototypeOf(SparseVoxelOctree)).call(this));\\n\\n  \\t\\t\\t\\t_this.root = new VoxelCell(min, size);\\n\\n  \\t\\t\\t\\t_this.voxelCount = 0;\\n\\n  \\t\\t\\t\\tif (data !== null && data.edgeData !== null) {\\n\\n  \\t\\t\\t\\t\\t\\t_this.construct(data);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (VoxelCell.errorThreshold >= 0) {\\n\\n  \\t\\t\\t\\t\\t\\t_this.simplify();\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\treturn _this;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(SparseVoxelOctree, [{\\n  \\t\\t\\t\\tkey: "simplify",\\n  \\t\\t\\t\\tvalue: function simplify() {\\n\\n  \\t\\t\\t\\t\\t\\tthis.voxelCount -= this.root.collapse();\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "construct",\\n  \\t\\t\\t\\tvalue: function construct(data) {\\n\\n  \\t\\t\\t\\t\\t\\tvar n = HermiteData.resolution;\\n  \\t\\t\\t\\t\\t\\tvar edgeData = data.edgeData;\\n  \\t\\t\\t\\t\\t\\tvar materialIndices = data.materialIndices;\\n\\n  \\t\\t\\t\\t\\t\\tvar qefSolver = new QEFSolver();\\n  \\t\\t\\t\\t\\t\\tvar intersection = new Vector3();\\n\\n  \\t\\t\\t\\t\\t\\tvar edgeIterators = [edgeData.edgesX(this.min, this.root.size), edgeData.edgesY(this.min, this.root.size), edgeData.edgesZ(this.min, this.root.size)];\\n\\n  \\t\\t\\t\\t\\t\\tvar sequences = [new Uint8Array([0, 1, 2, 3]), new Uint8Array([0, 1, 4, 5]), new Uint8Array([0, 2, 4, 6])];\\n\\n  \\t\\t\\t\\t\\t\\tvar voxelCount = 0;\\n\\n  \\t\\t\\t\\t\\t\\tvar edges = void 0,\\n  \\t\\t\\t\\t\\t\\t    edge = void 0;\\n  \\t\\t\\t\\t\\t\\tvar sequence = void 0,\\n  \\t\\t\\t\\t\\t\\t    offset = void 0;\\n  \\t\\t\\t\\t\\t\\tvar cell = void 0,\\n  \\t\\t\\t\\t\\t\\t    voxel = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tvar x = void 0,\\n  \\t\\t\\t\\t\\t\\t    y = void 0,\\n  \\t\\t\\t\\t\\t\\t    z = void 0;\\n  \\t\\t\\t\\t\\t\\tvar d = void 0,\\n  \\t\\t\\t\\t\\t\\t    i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (d = 0; d < 3; ++d) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tsequence = sequences[d];\\n  \\t\\t\\t\\t\\t\\t\\t\\tedges = edgeIterators[d];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tvar _iteratorNormalCompletion = true;\\n  \\t\\t\\t\\t\\t\\t\\t\\tvar _didIteratorError = false;\\n  \\t\\t\\t\\t\\t\\t\\t\\tvar _iteratorError = undefined;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\ttry {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfor (var _iterator = edges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedge = _step.value;\\n\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedge.computeZeroCrossingPosition(intersection);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfor (i = 0; i < 4; ++i) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\toffset = pattern[sequence[i]];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tx = edge.coordinates.x - offset[0];\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ty = edge.coordinates.y - offset[1];\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tz = edge.coordinates.z - offset[2];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (x >= 0 && y >= 0 && z >= 0 && x < n && y < n && z < n) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcell = getCell(this.root, n, x, y, z);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (cell.voxel === null) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcell.voxel = createVoxel(n, x, y, z, materialIndices);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++voxelCount;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvoxel = cell.voxel;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvoxel.normal.add(edge.n);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvoxel.qefData.add(intersection, edge.n);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (voxel.qefData.numPoints === voxel.edgeCount) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tqefSolver.setData(voxel.qefData).solve(voxel.position);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (!cell.contains(voxel.position)) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvoxel.position.copy(qefSolver.massPoint);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvoxel.normal.normalize();\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t} catch (err) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t_didIteratorError = true;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t_iteratorError = err;\\n  \\t\\t\\t\\t\\t\\t\\t\\t} finally {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (!_iteratorNormalCompletion && _iterator.return) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t_iterator.return();\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} finally {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_didIteratorError) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthrow _iteratorError;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tthis.voxelCount = voxelCount;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn SparseVoxelOctree;\\n  }(Octree);\\n\\n  var Action = {\\n\\n    EXTRACT: "worker.extract",\\n    MODIFY: "worker.modify",\\n    CONFIGURE: "worker.config",\\n    CLOSE: "worker.close"\\n\\n  };\\n\\n  var DataMessage = function (_Message) {\\n  \\tinherits(DataMessage, _Message);\\n\\n  \\tfunction DataMessage() {\\n  \\t\\tvar action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\\n  \\t\\tclassCallCheck(this, DataMessage);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (DataMessage.__proto__ || Object.getPrototypeOf(DataMessage)).call(this, action));\\n\\n  \\t\\t_this.data = null;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\treturn DataMessage;\\n  }(Message);\\n\\n  var ExtractionResponse = function (_DataMessage) {\\n  \\tinherits(ExtractionResponse, _DataMessage);\\n\\n  \\tfunction ExtractionResponse() {\\n  \\t\\tclassCallCheck(this, ExtractionResponse);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (ExtractionResponse.__proto__ || Object.getPrototypeOf(ExtractionResponse)).call(this, Action.EXTRACT));\\n\\n  \\t\\t_this.isosurface = null;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\treturn ExtractionResponse;\\n  }(DataMessage);\\n\\n  var data = new HermiteData(false);\\n\\n  var DataProcessor = function () {\\n  \\tfunction DataProcessor() {\\n  \\t\\tclassCallCheck(this, DataProcessor);\\n\\n\\n  \\t\\tthis.data = null;\\n\\n  \\t\\tthis.response = null;\\n  \\t}\\n\\n  \\tcreateClass(DataProcessor, [{\\n  \\t\\tkey: "getData",\\n  \\t\\tvalue: function getData() {\\n\\n  \\t\\t\\treturn this.data;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "respond",\\n  \\t\\tvalue: function respond() {\\n\\n  \\t\\t\\tthis.response.data = this.data.serialize();\\n\\n  \\t\\t\\treturn this.response;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "createTransferList",\\n  \\t\\tvalue: function createTransferList() {\\n  \\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\tif (this.data !== null) {\\n\\n  \\t\\t\\t\\tthis.data.createTransferList(transferList);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn transferList;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "process",\\n  \\t\\tvalue: function process(request) {\\n\\n  \\t\\t\\tthis.data = data.deserialize(request.data);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn DataProcessor;\\n  }();\\n\\n  var SurfaceExtractor = function (_DataProcessor) {\\n  \\t\\tinherits(SurfaceExtractor, _DataProcessor);\\n\\n  \\t\\tfunction SurfaceExtractor() {\\n  \\t\\t\\t\\tclassCallCheck(this, SurfaceExtractor);\\n\\n  \\t\\t\\t\\tvar _this = possibleConstructorReturn(this, (SurfaceExtractor.__proto__ || Object.getPrototypeOf(SurfaceExtractor)).call(this));\\n\\n  \\t\\t\\t\\t_this.response = new ExtractionResponse();\\n\\n  \\t\\t\\t\\t_this.decompressionTarget = new HermiteData(false);\\n\\n  \\t\\t\\t\\t_this.isosurface = null;\\n\\n  \\t\\t\\t\\treturn _this;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(SurfaceExtractor, [{\\n  \\t\\t\\t\\tkey: "respond",\\n  \\t\\t\\t\\tvalue: function respond() {\\n\\n  \\t\\t\\t\\t\\t\\tvar response = get(SurfaceExtractor.prototype.__proto__ || Object.getPrototypeOf(SurfaceExtractor.prototype), "respond", this).call(this);\\n\\n  \\t\\t\\t\\t\\t\\tresponse.isosurface = this.isosurface !== null ? this.isosurface.serialise() : null;\\n\\n  \\t\\t\\t\\t\\t\\treturn response;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "createTransferList",\\n  \\t\\t\\t\\tvalue: function createTransferList() {\\n  \\t\\t\\t\\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\t\\t\\t\\tget(SurfaceExtractor.prototype.__proto__ || Object.getPrototypeOf(SurfaceExtractor.prototype), "createTransferList", this).call(this, transferList);\\n\\n  \\t\\t\\t\\t\\t\\treturn this.isosurface !== null ? this.isosurface.createTransferList(transferList) : transferList;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "process",\\n  \\t\\t\\t\\tvalue: function process(request) {\\n  \\t\\t\\t\\t\\t\\tvar data = get(SurfaceExtractor.prototype.__proto__ || Object.getPrototypeOf(SurfaceExtractor.prototype), "process", this).call(this, request).getData();\\n\\n  \\t\\t\\t\\t\\t\\tvar svo = new SparseVoxelOctree(data.decompress(this.decompressionTarget));\\n\\n  \\t\\t\\t\\t\\t\\tthis.isosurface = DualContouring.run(svo);\\n\\n  \\t\\t\\t\\t\\t\\tthis.decompressionTarget.clear();\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn SurfaceExtractor;\\n  }(DataProcessor);\\n\\n  var OperationType = {\\n\\n    UNION: "csg.union",\\n    DIFFERENCE: "csg.difference",\\n    INTERSECTION: "csg.intersection",\\n    DENSITY_FUNCTION: "csg.densityfunction"\\n\\n  };\\n\\n  var Operation = function () {\\n  \\t\\tfunction Operation(type) {\\n  \\t\\t\\t\\tclassCallCheck(this, Operation);\\n\\n\\n  \\t\\t\\t\\tthis.type = type;\\n\\n  \\t\\t\\t\\tfor (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n  \\t\\t\\t\\t\\t\\tchildren[_key - 1] = arguments[_key];\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tthis.children = children;\\n\\n  \\t\\t\\t\\tthis.boundingBox = null;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Operation, [{\\n  \\t\\t\\t\\tkey: "getBoundingBox",\\n  \\t\\t\\t\\tvalue: function getBoundingBox() {\\n\\n  \\t\\t\\t\\t\\t\\tif (this.boundingBox === null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.boundingBox = this.computeBoundingBox();\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this.boundingBox;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "computeBoundingBox",\\n  \\t\\t\\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\t\\t\\t\\tvar children = this.children;\\n  \\t\\t\\t\\t\\t\\tvar boundingBox = new Box3();\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tboundingBox.union(children[i].getBoundingBox());\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn boundingBox;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Operation;\\n  }();\\n\\n  var Union = function (_Operation) {\\n  \\tinherits(Union, _Operation);\\n\\n  \\tfunction Union() {\\n  \\t\\tvar _ref;\\n\\n  \\t\\tclassCallCheck(this, Union);\\n\\n  \\t\\tfor (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\\n  \\t\\t\\tchildren[_key] = arguments[_key];\\n  \\t\\t}\\n\\n  \\t\\treturn possibleConstructorReturn(this, (_ref = Union.__proto__ || Object.getPrototypeOf(Union)).call.apply(_ref, [this, OperationType.UNION].concat(children)));\\n  \\t}\\n\\n  \\tcreateClass(Union, [{\\n  \\t\\tkey: "updateMaterialIndex",\\n  \\t\\tvalue: function updateMaterialIndex(index, data0, data1) {\\n\\n  \\t\\t\\tvar materialIndex = data1.materialIndices[index];\\n\\n  \\t\\t\\tif (materialIndex !== Material.AIR) {\\n\\n  \\t\\t\\t\\tdata0.setMaterialIndex(index, materialIndex);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "selectEdge",\\n  \\t\\tvalue: function selectEdge(edge0, edge1, s) {\\n\\n  \\t\\t\\treturn s ? edge0.t > edge1.t ? edge0 : edge1 : edge0.t < edge1.t ? edge0 : edge1;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Union;\\n  }(Operation);\\n\\n  var Difference = function (_Operation) {\\n  \\tinherits(Difference, _Operation);\\n\\n  \\tfunction Difference() {\\n  \\t\\tvar _ref;\\n\\n  \\t\\tclassCallCheck(this, Difference);\\n\\n  \\t\\tfor (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\\n  \\t\\t\\tchildren[_key] = arguments[_key];\\n  \\t\\t}\\n\\n  \\t\\treturn possibleConstructorReturn(this, (_ref = Difference.__proto__ || Object.getPrototypeOf(Difference)).call.apply(_ref, [this, OperationType.DIFFERENCE].concat(children)));\\n  \\t}\\n\\n  \\tcreateClass(Difference, [{\\n  \\t\\tkey: "updateMaterialIndex",\\n  \\t\\tvalue: function updateMaterialIndex(index, data0, data1) {\\n\\n  \\t\\t\\tif (data1.materialIndices[index] !== Material.AIR) {\\n\\n  \\t\\t\\t\\tdata0.setMaterialIndex(index, Material.AIR);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "selectEdge",\\n  \\t\\tvalue: function selectEdge(edge0, edge1, s) {\\n\\n  \\t\\t\\treturn s ? edge0.t < edge1.t ? edge0 : edge1 : edge0.t > edge1.t ? edge0 : edge1;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Difference;\\n  }(Operation);\\n\\n  var Intersection = function (_Operation) {\\n  \\tinherits(Intersection, _Operation);\\n\\n  \\tfunction Intersection() {\\n  \\t\\tvar _ref;\\n\\n  \\t\\tclassCallCheck(this, Intersection);\\n\\n  \\t\\tfor (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\\n  \\t\\t\\tchildren[_key] = arguments[_key];\\n  \\t\\t}\\n\\n  \\t\\treturn possibleConstructorReturn(this, (_ref = Intersection.__proto__ || Object.getPrototypeOf(Intersection)).call.apply(_ref, [this, OperationType.INTERSECTION].concat(children)));\\n  \\t}\\n\\n  \\tcreateClass(Intersection, [{\\n  \\t\\tkey: "updateMaterialIndex",\\n  \\t\\tvalue: function updateMaterialIndex(index, data0, data1) {\\n\\n  \\t\\t\\tvar materialIndex = data1.materialIndices[index];\\n\\n  \\t\\t\\tdata0.setMaterialIndex(index, data0.materialIndices[index] !== Material.AIR && materialIndex !== Material.AIR ? materialIndex : Material.AIR);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "selectEdge",\\n  \\t\\tvalue: function selectEdge(edge0, edge1, s) {\\n\\n  \\t\\t\\treturn s ? edge0.t < edge1.t ? edge0 : edge1 : edge0.t > edge1.t ? edge0 : edge1;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Intersection;\\n  }(Operation);\\n\\n  var cellSize = 0;\\n\\n  var cellPosition = new Vector3();\\n\\n  function computeIndexBounds(operation) {\\n\\n  \\tvar s = cellSize;\\n  \\tvar n = HermiteData.resolution;\\n\\n  \\tvar min = new Vector3(0, 0, 0);\\n  \\tvar max = new Vector3(n, n, n);\\n\\n  \\tvar cellBounds = new Box3(cellPosition, cellPosition.clone().addScalar(cellSize));\\n  \\tvar operationBounds = operation.getBoundingBox();\\n\\n  \\tif (operation.type !== OperationType.INTERSECTION) {\\n\\n  \\t\\tif (operationBounds.intersectsBox(cellBounds)) {\\n\\n  \\t\\t\\tmin.copy(operationBounds.min).max(cellBounds.min).sub(cellBounds.min);\\n\\n  \\t\\t\\tmin.x = Math.ceil(min.x * n / s);\\n  \\t\\t\\tmin.y = Math.ceil(min.y * n / s);\\n  \\t\\t\\tmin.z = Math.ceil(min.z * n / s);\\n\\n  \\t\\t\\tmax.copy(operationBounds.max).min(cellBounds.max).sub(cellBounds.min);\\n\\n  \\t\\t\\tmax.x = Math.floor(max.x * n / s);\\n  \\t\\t\\tmax.y = Math.floor(max.y * n / s);\\n  \\t\\t\\tmax.z = Math.floor(max.z * n / s);\\n  \\t\\t} else {\\n  \\t\\t\\tmin.set(n, n, n);\\n  \\t\\t\\tmax.set(0, 0, 0);\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn new Box3(min, max);\\n  }\\n\\n  function combineMaterialIndices(operation, data0, data1, bounds) {\\n\\n  \\tvar n = HermiteData.resolution;\\n  \\tvar m = n + 1;\\n  \\tvar mm = m * m;\\n\\n  \\tvar X = bounds.max.x;\\n  \\tvar Y = bounds.max.y;\\n  \\tvar Z = bounds.max.z;\\n\\n  \\tvar x = void 0,\\n  \\t    y = void 0,\\n  \\t    z = void 0;\\n\\n  \\tfor (z = bounds.min.z; z <= Z; ++z) {\\n\\n  \\t\\tfor (y = bounds.min.y; y <= Y; ++y) {\\n\\n  \\t\\t\\tfor (x = bounds.min.x; x <= X; ++x) {\\n\\n  \\t\\t\\t\\toperation.updateMaterialIndex(z * mm + y * m + x, data0, data1);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function generateMaterialIndices(operation, data, bounds) {\\n\\n  \\tvar s = cellSize;\\n  \\tvar n = HermiteData.resolution;\\n  \\tvar m = n + 1;\\n  \\tvar mm = m * m;\\n\\n  \\tvar materialIndices = data.materialIndices;\\n\\n  \\tvar base = cellPosition;\\n  \\tvar offset = new Vector3();\\n  \\tvar position = new Vector3();\\n\\n  \\tvar X = bounds.max.x;\\n  \\tvar Y = bounds.max.y;\\n  \\tvar Z = bounds.max.z;\\n\\n  \\tvar materialIndex = void 0;\\n  \\tvar materials = 0;\\n\\n  \\tvar x = void 0,\\n  \\t    y = void 0,\\n  \\t    z = void 0;\\n\\n  \\tfor (z = bounds.min.z; z <= Z; ++z) {\\n\\n  \\t\\toffset.z = z * s / n;\\n\\n  \\t\\tfor (y = bounds.min.y; y <= Y; ++y) {\\n\\n  \\t\\t\\toffset.y = y * s / n;\\n\\n  \\t\\t\\tfor (x = bounds.min.x; x <= X; ++x) {\\n\\n  \\t\\t\\t\\toffset.x = x * s / n;\\n\\n  \\t\\t\\t\\tmaterialIndex = operation.generateMaterialIndex(position.addVectors(base, offset));\\n\\n  \\t\\t\\t\\tif (materialIndex !== Material.AIR) {\\n\\n  \\t\\t\\t\\t\\tmaterialIndices[z * mm + y * m + x] = materialIndex;\\n\\n  \\t\\t\\t\\t\\t++materials;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\tdata.materials = materials;\\n  }\\n\\n  function combineEdges(operation, data0, data1) {\\n\\n  \\tvar n = HermiteData.resolution;\\n  \\tvar m = n + 1;\\n  \\tvar mm = m * m;\\n\\n  \\tvar indexOffsets = new Uint32Array([1, m, mm]);\\n  \\tvar materialIndices = data0.materialIndices;\\n\\n  \\tvar edge1 = new Edge();\\n  \\tvar edge0 = new Edge();\\n\\n  \\tvar edgeData1 = data1.edgeData;\\n  \\tvar edgeData0 = data0.edgeData;\\n\\n  \\tvar lengths = new Uint32Array(3);\\n  \\tvar edgeCount = EdgeData.calculate1DEdgeCount(n);\\n\\n  \\tvar edgeData = new EdgeData(Math.min(edgeCount, edgeData0.indices[0].length + edgeData1.indices[0].length), Math.min(edgeCount, edgeData0.indices[1].length + edgeData1.indices[1].length), Math.min(edgeCount, edgeData0.indices[2].length + edgeData1.indices[2].length));\\n\\n  \\tvar edges1 = void 0,\\n  \\t    zeroCrossings1 = void 0,\\n  \\t    normals1 = void 0;\\n  \\tvar edges0 = void 0,\\n  \\t    zeroCrossings0 = void 0,\\n  \\t    normals0 = void 0;\\n  \\tvar edges = void 0,\\n  \\t    zeroCrossings = void 0,\\n  \\t    normals = void 0;\\n  \\tvar indexOffset = void 0;\\n\\n  \\tvar indexA1 = void 0,\\n  \\t    indexB1 = void 0;\\n  \\tvar indexA0 = void 0,\\n  \\t    indexB0 = void 0;\\n\\n  \\tvar m1 = void 0,\\n  \\t    m2 = void 0;\\n  \\tvar edge = void 0;\\n\\n  \\tvar c = void 0,\\n  \\t    d = void 0,\\n  \\t    i = void 0,\\n  \\t    j = void 0,\\n  \\t    il = void 0,\\n  \\t    jl = void 0;\\n\\n  \\tfor (c = 0, d = 0; d < 3; c = 0, ++d) {\\n\\n  \\t\\tedges1 = edgeData1.indices[d];\\n  \\t\\tedges0 = edgeData0.indices[d];\\n  \\t\\tedges = edgeData.indices[d];\\n\\n  \\t\\tzeroCrossings1 = edgeData1.zeroCrossings[d];\\n  \\t\\tzeroCrossings0 = edgeData0.zeroCrossings[d];\\n  \\t\\tzeroCrossings = edgeData.zeroCrossings[d];\\n\\n  \\t\\tnormals1 = edgeData1.normals[d];\\n  \\t\\tnormals0 = edgeData0.normals[d];\\n  \\t\\tnormals = edgeData.normals[d];\\n\\n  \\t\\tindexOffset = indexOffsets[d];\\n\\n  \\t\\til = edges1.length;\\n  \\t\\tjl = edges0.length;\\n\\n  \\t\\tfor (i = 0, j = 0; i < il; ++i) {\\n\\n  \\t\\t\\tindexA1 = edges1[i];\\n  \\t\\t\\tindexB1 = indexA1 + indexOffset;\\n\\n  \\t\\t\\tm1 = materialIndices[indexA1];\\n  \\t\\t\\tm2 = materialIndices[indexB1];\\n\\n  \\t\\t\\tif (m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\\n\\n  \\t\\t\\t\\tedge1.t = zeroCrossings1[i];\\n  \\t\\t\\t\\tedge1.n.x = normals1[i * 3];\\n  \\t\\t\\t\\tedge1.n.y = normals1[i * 3 + 1];\\n  \\t\\t\\t\\tedge1.n.z = normals1[i * 3 + 2];\\n\\n  \\t\\t\\t\\tif (operation.type === OperationType.DIFFERENCE) {\\n\\n  \\t\\t\\t\\t\\tedge1.n.negate();\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tedge = edge1;\\n\\n  \\t\\t\\t\\twhile (j < jl && edges0[j] <= indexA1) {\\n\\n  \\t\\t\\t\\t\\tindexA0 = edges0[j];\\n  \\t\\t\\t\\t\\tindexB0 = indexA0 + indexOffset;\\n\\n  \\t\\t\\t\\t\\tedge0.t = zeroCrossings0[j];\\n  \\t\\t\\t\\t\\tedge0.n.x = normals0[j * 3];\\n  \\t\\t\\t\\t\\tedge0.n.y = normals0[j * 3 + 1];\\n  \\t\\t\\t\\t\\tedge0.n.z = normals0[j * 3 + 2];\\n\\n  \\t\\t\\t\\t\\tm1 = materialIndices[indexA0];\\n\\n  \\t\\t\\t\\t\\tif (indexA0 < indexA1) {\\n\\n  \\t\\t\\t\\t\\t\\tm2 = materialIndices[indexB0];\\n\\n  \\t\\t\\t\\t\\t\\tif (m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\\n  \\t\\t\\t\\t\\t\\t\\tedges[c] = indexA0;\\n  \\t\\t\\t\\t\\t\\t\\tzeroCrossings[c] = edge0.t;\\n  \\t\\t\\t\\t\\t\\t\\tnormals[c * 3] = edge0.n.x;\\n  \\t\\t\\t\\t\\t\\t\\tnormals[c * 3 + 1] = edge0.n.y;\\n  \\t\\t\\t\\t\\t\\t\\tnormals[c * 3 + 2] = edge0.n.z;\\n\\n  \\t\\t\\t\\t\\t\\t\\t++c;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\tedge = operation.selectEdge(edge0, edge1, m1 === Material.SOLID);\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t++j;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tedges[c] = indexA1;\\n  \\t\\t\\t\\tzeroCrossings[c] = edge.t;\\n  \\t\\t\\t\\tnormals[c * 3] = edge.n.x;\\n  \\t\\t\\t\\tnormals[c * 3 + 1] = edge.n.y;\\n  \\t\\t\\t\\tnormals[c * 3 + 2] = edge.n.z;\\n\\n  \\t\\t\\t\\t++c;\\n  \\t\\t\\t}\\n  \\t\\t}\\n\\n  \\t\\twhile (j < jl) {\\n\\n  \\t\\t\\tindexA0 = edges0[j];\\n  \\t\\t\\tindexB0 = indexA0 + indexOffset;\\n\\n  \\t\\t\\tm1 = materialIndices[indexA0];\\n  \\t\\t\\tm2 = materialIndices[indexB0];\\n\\n  \\t\\t\\tif (m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\\n\\n  \\t\\t\\t\\tedges[c] = indexA0;\\n  \\t\\t\\t\\tzeroCrossings[c] = zeroCrossings0[j];\\n  \\t\\t\\t\\tnormals[c * 3] = normals0[j * 3];\\n  \\t\\t\\t\\tnormals[c * 3 + 1] = normals0[j * 3 + 1];\\n  \\t\\t\\t\\tnormals[c * 3 + 2] = normals0[j * 3 + 2];\\n\\n  \\t\\t\\t\\t++c;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\t++j;\\n  \\t\\t}\\n\\n  \\t\\tlengths[d] = c;\\n  \\t}\\n\\n  \\treturn { edgeData: edgeData, lengths: lengths };\\n  }\\n\\n  function generateEdges(operation, data, bounds) {\\n\\n  \\tvar s = cellSize;\\n  \\tvar n = HermiteData.resolution;\\n  \\tvar m = n + 1;\\n  \\tvar mm = m * m;\\n\\n  \\tvar indexOffsets = new Uint32Array([1, m, mm]);\\n  \\tvar materialIndices = data.materialIndices;\\n\\n  \\tvar base = cellPosition;\\n  \\tvar offsetA = new Vector3();\\n  \\tvar offsetB = new Vector3();\\n  \\tvar edge = new Edge();\\n\\n  \\tvar lengths = new Uint32Array(3);\\n  \\tvar edgeData = new EdgeData(EdgeData.calculate1DEdgeCount(n));\\n\\n  \\tvar edges = void 0,\\n  \\t    zeroCrossings = void 0,\\n  \\t    normals = void 0,\\n  \\t    indexOffset = void 0;\\n  \\tvar indexA = void 0,\\n  \\t    indexB = void 0;\\n\\n  \\tvar minX = void 0,\\n  \\t    minY = void 0,\\n  \\t    minZ = void 0;\\n  \\tvar maxX = void 0,\\n  \\t    maxY = void 0,\\n  \\t    maxZ = void 0;\\n\\n  \\tvar c = void 0,\\n  \\t    d = void 0,\\n  \\t    a = void 0,\\n  \\t    axis = void 0;\\n  \\tvar x = void 0,\\n  \\t    y = void 0,\\n  \\t    z = void 0;\\n\\n  \\tfor (a = 4, c = 0, d = 0; d < 3; a >>= 1, c = 0, ++d) {\\n  \\t\\taxis = pattern[a];\\n\\n  \\t\\tedges = edgeData.indices[d];\\n  \\t\\tzeroCrossings = edgeData.zeroCrossings[d];\\n  \\t\\tnormals = edgeData.normals[d];\\n  \\t\\tindexOffset = indexOffsets[d];\\n\\n  \\t\\tminX = bounds.min.x;maxX = bounds.max.x;\\n  \\t\\tminY = bounds.min.y;maxY = bounds.max.y;\\n  \\t\\tminZ = bounds.min.z;maxZ = bounds.max.z;\\n\\n  \\t\\tswitch (d) {\\n\\n  \\t\\t\\tcase 0:\\n  \\t\\t\\t\\tminX = Math.max(minX - 1, 0);\\n  \\t\\t\\t\\tmaxX = Math.min(maxX, n - 1);\\n  \\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\tcase 1:\\n  \\t\\t\\t\\tminY = Math.max(minY - 1, 0);\\n  \\t\\t\\t\\tmaxY = Math.min(maxY, n - 1);\\n  \\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\tcase 2:\\n  \\t\\t\\t\\tminZ = Math.max(minZ - 1, 0);\\n  \\t\\t\\t\\tmaxZ = Math.min(maxZ, n - 1);\\n  \\t\\t\\t\\tbreak;\\n\\n  \\t\\t}\\n\\n  \\t\\tfor (z = minZ; z <= maxZ; ++z) {\\n\\n  \\t\\t\\tfor (y = minY; y <= maxY; ++y) {\\n\\n  \\t\\t\\t\\tfor (x = minX; x <= maxX; ++x) {\\n\\n  \\t\\t\\t\\t\\tindexA = z * mm + y * m + x;\\n  \\t\\t\\t\\t\\tindexB = indexA + indexOffset;\\n\\n  \\t\\t\\t\\t\\tif (materialIndices[indexA] !== materialIndices[indexB]) {\\n\\n  \\t\\t\\t\\t\\t\\toffsetA.set(x * s / n, y * s / n, z * s / n);\\n\\n  \\t\\t\\t\\t\\t\\toffsetB.set((x + axis[0]) * s / n, (y + axis[1]) * s / n, (z + axis[2]) * s / n);\\n\\n  \\t\\t\\t\\t\\t\\tedge.a.addVectors(base, offsetA);\\n  \\t\\t\\t\\t\\t\\tedge.b.addVectors(base, offsetB);\\n\\n  \\t\\t\\t\\t\\t\\toperation.generateEdge(edge);\\n\\n  \\t\\t\\t\\t\\t\\tedges[c] = indexA;\\n  \\t\\t\\t\\t\\t\\tzeroCrossings[c] = edge.t;\\n  \\t\\t\\t\\t\\t\\tnormals[c * 3] = edge.n.x;\\n  \\t\\t\\t\\t\\t\\tnormals[c * 3 + 1] = edge.n.y;\\n  \\t\\t\\t\\t\\t\\tnormals[c * 3 + 2] = edge.n.z;\\n\\n  \\t\\t\\t\\t\\t\\t++c;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n\\n  \\t\\tlengths[d] = c;\\n  \\t}\\n\\n  \\treturn { edgeData: edgeData, lengths: lengths };\\n  }\\n\\n  function update(operation, data0, data1) {\\n\\n  \\tvar bounds = computeIndexBounds(operation);\\n\\n  \\tvar result = void 0,\\n  \\t    edgeData = void 0,\\n  \\t    lengths = void 0,\\n  \\t    d = void 0;\\n  \\tvar done = false;\\n\\n  \\tif (operation.type === OperationType.DENSITY_FUNCTION) {\\n\\n  \\t\\tgenerateMaterialIndices(operation, data0, bounds);\\n  \\t} else if (data0.empty) {\\n\\n  \\t\\tif (operation.type === OperationType.UNION) {\\n\\n  \\t\\t\\tdata0.set(data1);\\n  \\t\\t\\tdone = true;\\n  \\t\\t}\\n  \\t} else {\\n\\n  \\t\\tif (!(data0.full && operation.type === OperationType.UNION)) {\\n\\n  \\t\\t\\tcombineMaterialIndices(operation, data0, data1, bounds);\\n  \\t\\t}\\n  \\t}\\n\\n  \\tif (!done && !data0.empty && !data0.full) {\\n\\n  \\t\\tresult = operation.type === OperationType.DENSITY_FUNCTION ? generateEdges(operation, data0, bounds) : combineEdges(operation, data0, data1);\\n\\n  \\t\\tedgeData = result.edgeData;\\n  \\t\\tlengths = result.lengths;\\n\\n  \\t\\tfor (d = 0; d < 3; ++d) {\\n\\n  \\t\\t\\tedgeData.indices[d] = edgeData.indices[d].slice(0, lengths[d]);\\n  \\t\\t\\tedgeData.zeroCrossings[d] = edgeData.zeroCrossings[d].slice(0, lengths[d]);\\n  \\t\\t\\tedgeData.normals[d] = edgeData.normals[d].slice(0, lengths[d] * 3);\\n  \\t\\t}\\n\\n  \\t\\tdata0.edgeData = edgeData;\\n  \\t}\\n  }\\n\\n  function execute(operation) {\\n\\n  \\tvar children = operation.children;\\n\\n  \\tvar result = void 0,\\n  \\t    data = void 0;\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tif (operation.type === OperationType.DENSITY_FUNCTION) {\\n  \\t\\tresult = new HermiteData();\\n\\n  \\t\\tupdate(operation, result);\\n  \\t}\\n\\n  \\tfor (i = 0, l = children.length; i < l; ++i) {\\n  \\t\\tdata = execute(children[i]);\\n\\n  \\t\\tif (result === undefined) {\\n\\n  \\t\\t\\tresult = data;\\n  \\t\\t} else if (data !== null) {\\n\\n  \\t\\t\\tif (result === null) {\\n\\n  \\t\\t\\t\\tif (operation.type === OperationType.UNION) {\\n  \\t\\t\\t\\t\\tresult = data;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n  \\t\\t\\t\\tupdate(operation, result, data);\\n  \\t\\t\\t}\\n  \\t\\t} else if (operation.type === OperationType.INTERSECTION) {\\n  \\t\\t\\tresult = null;\\n  \\t\\t}\\n\\n  \\t\\tif (result === null && operation.type !== OperationType.UNION) {\\n  \\t\\t\\tbreak;\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result !== null && result.empty ? null : result;\\n  }\\n\\n  var ConstructiveSolidGeometry = function () {\\n  \\tfunction ConstructiveSolidGeometry() {\\n  \\t\\tclassCallCheck(this, ConstructiveSolidGeometry);\\n  \\t}\\n\\n  \\tcreateClass(ConstructiveSolidGeometry, null, [{\\n  \\t\\tkey: "run",\\n  \\t\\tvalue: function run(min, size, data, sdf) {\\n\\n  \\t\\t\\tcellPosition.fromArray(min);\\n  \\t\\t\\tcellSize = size;\\n\\n  \\t\\t\\tif (data === null) {\\n\\n  \\t\\t\\t\\tif (sdf.operation === OperationType.UNION) {\\n  \\t\\t\\t\\t\\tdata = new HermiteData(false);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tdata.decompress();\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tvar operation = sdf.toCSG();\\n\\n  \\t\\t\\tvar generatedData = data !== null ? execute(operation) : null;\\n\\n  \\t\\t\\tif (generatedData !== null) {\\n  \\t\\t\\t\\tswitch (sdf.operation) {\\n\\n  \\t\\t\\t\\t\\tcase OperationType.UNION:\\n  \\t\\t\\t\\t\\t\\toperation = new Union(operation);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase OperationType.DIFFERENCE:\\n  \\t\\t\\t\\t\\t\\toperation = new Difference(operation);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase OperationType.INTERSECTION:\\n  \\t\\t\\t\\t\\t\\toperation = new Intersection(operation);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tupdate(operation, data, generatedData);\\n\\n  \\t\\t\\t\\tdata.contoured = false;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn data !== null && data.empty ? null : data;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn ConstructiveSolidGeometry;\\n  }();\\n\\n  var ISOVALUE = 0.0;\\n\\n  var DensityFunction = function (_Operation) {\\n  \\tinherits(DensityFunction, _Operation);\\n\\n  \\tfunction DensityFunction(sdf) {\\n  \\t\\tclassCallCheck(this, DensityFunction);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (DensityFunction.__proto__ || Object.getPrototypeOf(DensityFunction)).call(this, OperationType.DENSITY_FUNCTION));\\n\\n  \\t\\t_this.sdf = sdf;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\tcreateClass(DensityFunction, [{\\n  \\t\\tkey: "computeBoundingBox",\\n  \\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\treturn this.sdf.getBoundingBox(true);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "generateMaterialIndex",\\n  \\t\\tvalue: function generateMaterialIndex(position) {\\n\\n  \\t\\t\\treturn this.sdf.sample(position) <= ISOVALUE ? this.sdf.material : Material.AIR;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "generateEdge",\\n  \\t\\tvalue: function generateEdge(edge) {\\n\\n  \\t\\t\\tedge.approximateZeroCrossing(this.sdf);\\n  \\t\\t\\tedge.computeSurfaceNormal(this.sdf);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn DensityFunction;\\n  }(Operation);\\n\\n  var m$2 = new Matrix4();\\n\\n  var SignedDistanceFunction = function () {\\n  \\t\\tfunction SignedDistanceFunction(type) {\\n  \\t\\t\\t\\tvar material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Material.SOLID;\\n  \\t\\t\\t\\tclassCallCheck(this, SignedDistanceFunction);\\n\\n\\n  \\t\\t\\t\\tthis.type = type;\\n\\n  \\t\\t\\t\\tthis.operation = null;\\n\\n  \\t\\t\\t\\tthis.material = Math.min(255, Math.max(Material.SOLID, Math.trunc(material)));\\n\\n  \\t\\t\\t\\tthis.boundingBox = null;\\n\\n  \\t\\t\\t\\tthis.position = new Vector3();\\n\\n  \\t\\t\\t\\tthis.quaternion = new Quaternion();\\n\\n  \\t\\t\\t\\tthis.scale = new Vector3(1, 1, 1);\\n\\n  \\t\\t\\t\\tthis.inverseTransformation = new Matrix4();\\n\\n  \\t\\t\\t\\tthis.updateInverseTransformation();\\n\\n  \\t\\t\\t\\tthis.children = [];\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(SignedDistanceFunction, [{\\n  \\t\\t\\t\\tkey: "getTransformation",\\n  \\t\\t\\t\\tvalue: function getTransformation() {\\n  \\t\\t\\t\\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix4();\\n\\n\\n  \\t\\t\\t\\t\\t\\treturn target.compose(this.position, this.quaternion, this.scale);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "getBoundingBox",\\n  \\t\\t\\t\\tvalue: function getBoundingBox() {\\n  \\t\\t\\t\\t\\t\\tvar recursive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar children = this.children;\\n\\n  \\t\\t\\t\\t\\t\\tvar boundingBox = this.boundingBox;\\n  \\t\\t\\t\\t\\t\\tvar i = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tif (boundingBox === null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tboundingBox = this.computeBoundingBox();\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.boundingBox = boundingBox;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tif (recursive) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tboundingBox = boundingBox.clone();\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tboundingBox.union(children[i].getBoundingBox(recursive));\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn boundingBox;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "setMaterial",\\n  \\t\\t\\t\\tvalue: function setMaterial(material) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.material = Math.min(255, Math.max(Material.SOLID, Math.trunc(material)));\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "setOperationType",\\n  \\t\\t\\t\\tvalue: function setOperationType(operation) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.operation = operation;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "updateInverseTransformation",\\n  \\t\\t\\t\\tvalue: function updateInverseTransformation() {\\n\\n  \\t\\t\\t\\t\\t\\tthis.inverseTransformation.getInverse(this.getTransformation(m$2));\\n  \\t\\t\\t\\t\\t\\tthis.boundingBox = null;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "union",\\n  \\t\\t\\t\\tvalue: function union(sdf) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.children.push(sdf.setOperationType(OperationType.UNION));\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "subtract",\\n  \\t\\t\\t\\tvalue: function subtract(sdf) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.children.push(sdf.setOperationType(OperationType.DIFFERENCE));\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "intersect",\\n  \\t\\t\\t\\tvalue: function intersect(sdf) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.children.push(sdf.setOperationType(OperationType.INTERSECTION));\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "toCSG",\\n  \\t\\t\\t\\tvalue: function toCSG() {\\n\\n  \\t\\t\\t\\t\\t\\tvar children = this.children;\\n\\n  \\t\\t\\t\\t\\t\\tvar operation = new DensityFunction(this);\\n  \\t\\t\\t\\t\\t\\tvar operationType = void 0;\\n  \\t\\t\\t\\t\\t\\tvar child = void 0;\\n  \\t\\t\\t\\t\\t\\tvar i = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tchild = children[i];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (operationType !== child.operation) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\toperationType = child.operation;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tswitch (operationType) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcase OperationType.UNION:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\toperation = new Union(operation);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcase OperationType.DIFFERENCE:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\toperation = new Difference(operation);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcase OperationType.INTERSECTION:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\toperation = new Intersection(operation);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\toperation.children.push(child.toCSG());\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn operation;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "serialize",\\n  \\t\\t\\t\\tvalue: function serialize() {\\n  \\t\\t\\t\\t\\t\\tvar deflate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar result = {\\n  \\t\\t\\t\\t\\t\\t\\t\\ttype: this.type,\\n  \\t\\t\\t\\t\\t\\t\\t\\toperation: this.operation,\\n  \\t\\t\\t\\t\\t\\t\\t\\tmaterial: this.material,\\n  \\t\\t\\t\\t\\t\\t\\t\\tposition: this.position.toArray(),\\n  \\t\\t\\t\\t\\t\\t\\t\\tquaternion: this.quaternion.toArray(),\\n  \\t\\t\\t\\t\\t\\t\\t\\tscale: this.scale.toArray(),\\n  \\t\\t\\t\\t\\t\\t\\t\\tparameters: null,\\n  \\t\\t\\t\\t\\t\\t\\t\\tchildren: []\\n  \\t\\t\\t\\t\\t\\t};\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0, l = this.children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tresult.children.push(this.children[i].serialize(deflate));\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "createTransferList",\\n  \\t\\t\\t\\tvalue: function createTransferList() {\\n  \\t\\t\\t\\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\t\\t\\t\\treturn transferList;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "toJSON",\\n  \\t\\t\\t\\tvalue: function toJSON() {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.serialize(true);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "computeBoundingBox",\\n  \\t\\t\\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\t\\t\\t\\tthrow new Error("SignedDistanceFunction#computeBoundingBox method not implemented!");\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "sample",\\n  \\t\\t\\t\\tvalue: function sample(position) {\\n\\n  \\t\\t\\t\\t\\t\\tthrow new Error("SignedDistanceFunction#sample method not implemented!");\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn SignedDistanceFunction;\\n  }();\\n\\n  var SDFType = {\\n\\n    HEIGHTFIELD: "sdf.heightfield",\\n    FRACTAL_NOISE: "sdf.fractalnoise",\\n    SUPER_PRIMITIVE: "sdf.superprimitive"\\n\\n  };\\n\\n  var FractalNoise = function (_SignedDistanceFuncti) {\\n  \\tinherits(FractalNoise, _SignedDistanceFuncti);\\n\\n  \\tfunction FractalNoise() {\\n  \\t\\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  \\t\\tvar material = arguments[1];\\n  \\t\\tclassCallCheck(this, FractalNoise);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (FractalNoise.__proto__ || Object.getPrototypeOf(FractalNoise)).call(this, SDFType.PERLIN_NOISE, material));\\n\\n  \\t\\t_this.min = new (Function.prototype.bind.apply(Vector3, [null].concat(toConsumableArray(parameters.min))))();\\n\\n  \\t\\t_this.max = new (Function.prototype.bind.apply(Vector3, [null].concat(toConsumableArray(parameters.max))))();\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\tcreateClass(FractalNoise, [{\\n  \\t\\tkey: "computeBoundingBox",\\n  \\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\tthis.bbox = new Box3(this.min, this.max);\\n\\n  \\t\\t\\treturn this.bbox;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "sample",\\n  \\t\\tvalue: function sample(position) {}\\n  \\t}, {\\n  \\t\\tkey: "serialize",\\n  \\t\\tvalue: function serialize() {\\n  \\t\\t\\tvar result = get(FractalNoise.prototype.__proto__ || Object.getPrototypeOf(FractalNoise.prototype), "serialize", this).call(this);\\n\\n  \\t\\t\\tresult.parameters = {\\n  \\t\\t\\t\\tmin: this.min.toArray(),\\n  \\t\\t\\t\\tmax: this.max.toArray()\\n  \\t\\t\\t};\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn FractalNoise;\\n  }(SignedDistanceFunction);\\n\\n  function readImageData(image) {\\n\\n  \\t\\tvar canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");\\n  \\t\\tvar context = canvas.getContext("2d");\\n\\n  \\t\\tcanvas.width = image.width;\\n  \\t\\tcanvas.height = image.height;\\n  \\t\\tcontext.drawImage(image, 0, 0);\\n\\n  \\t\\treturn context.getImageData(0, 0, image.width, image.height);\\n  }\\n\\n  var Heightfield = function (_SignedDistanceFuncti) {\\n  \\t\\tinherits(Heightfield, _SignedDistanceFuncti);\\n\\n  \\t\\tfunction Heightfield() {\\n  \\t\\t\\t\\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  \\t\\t\\t\\tvar material = arguments[1];\\n  \\t\\t\\t\\tclassCallCheck(this, Heightfield);\\n\\n  \\t\\t\\t\\tvar _this = possibleConstructorReturn(this, (Heightfield.__proto__ || Object.getPrototypeOf(Heightfield)).call(this, SDFType.HEIGHTFIELD, material));\\n\\n  \\t\\t\\t\\t_this.width = parameters.width !== undefined ? parameters.width : 1;\\n\\n  \\t\\t\\t\\t_this.height = parameters.height !== undefined ? parameters.height : 1;\\n\\n  \\t\\t\\t\\t_this.data = parameters.data !== undefined ? parameters.data : null;\\n\\n  \\t\\t\\t\\t_this.heightmap = null;\\n\\n  \\t\\t\\t\\tif (parameters.image !== undefined) {\\n\\n  \\t\\t\\t\\t\\t\\t_this.fromImage(parameters.image);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\treturn _this;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Heightfield, [{\\n  \\t\\t\\t\\tkey: "fromImage",\\n  \\t\\t\\t\\tvalue: function fromImage(image) {\\n\\n  \\t\\t\\t\\t\\t\\tvar imageData = typeof document === "undefined" ? null : readImageData(image);\\n\\n  \\t\\t\\t\\t\\t\\tvar result = null;\\n  \\t\\t\\t\\t\\t\\tvar data = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0,\\n  \\t\\t\\t\\t\\t\\t    j = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tif (imageData !== null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tdata = imageData.data;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tresult = new Uint8ClampedArray(data.length / 4);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tfor (i = 0, j = 0, l = result.length; i < l; ++i, j += 4) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresult[i] = data[j];\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.heightmap = image;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.width = imageData.width;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.height = imageData.height;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.data = result;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "computeBoundingBox",\\n  \\t\\t\\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\t\\t\\t\\tvar boundingBox = new Box3();\\n\\n  \\t\\t\\t\\t\\t\\tvar w = Math.min(this.width / this.height, 1.0);\\n  \\t\\t\\t\\t\\t\\tvar h = Math.min(this.height / this.width, 1.0);\\n\\n  \\t\\t\\t\\t\\t\\tboundingBox.min.set(0, 0, 0);\\n  \\t\\t\\t\\t\\t\\tboundingBox.max.set(w, 1, h);\\n  \\t\\t\\t\\t\\t\\tboundingBox.applyMatrix4(this.getTransformation());\\n\\n  \\t\\t\\t\\t\\t\\treturn boundingBox;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "sample",\\n  \\t\\t\\t\\tvalue: function sample(position) {\\n\\n  \\t\\t\\t\\t\\t\\tvar boundingBox = this.boundingBox;\\n\\n  \\t\\t\\t\\t\\t\\tvar d = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tif (boundingBox.containsPoint(position)) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tposition.applyMatrix4(this.inverseTransformation);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tvar w = this.width;\\n  \\t\\t\\t\\t\\t\\t\\t\\tvar h = this.height;\\n  \\t\\t\\t\\t\\t\\t\\t\\tvar x = Math.max(Math.min(Math.trunc(position.x * w), w), 0);\\n  \\t\\t\\t\\t\\t\\t\\t\\tvar z = Math.max(Math.min(Math.trunc(position.z * h), h), 0);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tvar height = this.data[z * w + x] / 255;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\td = position.y - height;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\td = boundingBox.distanceToPoint(position);\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn d;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "serialize",\\n  \\t\\t\\t\\tvalue: function serialize() {\\n  \\t\\t\\t\\t\\t\\tvar deflate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar result = get(Heightfield.prototype.__proto__ || Object.getPrototypeOf(Heightfield.prototype), "serialize", this).call(this);\\n\\n  \\t\\t\\t\\t\\t\\tresult.parameters = {\\n  \\t\\t\\t\\t\\t\\t\\t\\twidth: this.width,\\n  \\t\\t\\t\\t\\t\\t\\t\\theight: this.height,\\n  \\t\\t\\t\\t\\t\\t\\t\\tdata: deflate ? null : this.data,\\n  \\t\\t\\t\\t\\t\\t\\t\\tdataUrl: deflate && this.heightmap !== null ? this.heightmap.toDataUrl() : null,\\n  \\t\\t\\t\\t\\t\\t\\t\\timage: null\\n  \\t\\t\\t\\t\\t\\t};\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "createTransferList",\\n  \\t\\t\\t\\tvalue: function createTransferList() {\\n  \\t\\t\\t\\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.data.buffer);\\n\\n  \\t\\t\\t\\t\\t\\treturn transferList;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Heightfield;\\n  }(SignedDistanceFunction);\\n\\n  var SuperPrimitive = function (_SignedDistanceFuncti) {\\n  \\tinherits(SuperPrimitive, _SignedDistanceFuncti);\\n\\n  \\tfunction SuperPrimitive() {\\n  \\t\\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  \\t\\tvar material = arguments[1];\\n  \\t\\tclassCallCheck(this, SuperPrimitive);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (SuperPrimitive.__proto__ || Object.getPrototypeOf(SuperPrimitive)).call(this, SDFType.SUPER_PRIMITIVE, material));\\n\\n  \\t\\t_this.s0 = new (Function.prototype.bind.apply(Vector4, [null].concat(toConsumableArray(parameters.s))))();\\n\\n  \\t\\t_this.r0 = new (Function.prototype.bind.apply(Vector3, [null].concat(toConsumableArray(parameters.r))))();\\n\\n  \\t\\t_this.s = new Vector4();\\n\\n  \\t\\t_this.r = new Vector3();\\n\\n  \\t\\t_this.ba = new Vector2();\\n\\n  \\t\\t_this.offset = 0;\\n\\n  \\t\\t_this.precompute();\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\tcreateClass(SuperPrimitive, [{\\n  \\t\\tkey: "setSize",\\n  \\t\\tvalue: function setSize(x, y, z, w) {\\n\\n  \\t\\t\\tthis.s0.set(x, y, z, w);\\n\\n  \\t\\t\\treturn this.precompute();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "setRadii",\\n  \\t\\tvalue: function setRadii(x, y, z) {\\n\\n  \\t\\t\\tthis.r0.set(x, y, z);\\n\\n  \\t\\t\\treturn this.precompute();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "precompute",\\n  \\t\\tvalue: function precompute() {\\n\\n  \\t\\t\\tvar s = this.s.copy(this.s0);\\n  \\t\\t\\tvar r = this.r.copy(this.r0);\\n  \\t\\t\\tvar ba = this.ba;\\n\\n  \\t\\t\\ts.x -= r.x;\\n  \\t\\t\\ts.y -= r.x;\\n\\n  \\t\\t\\tr.x -= s.w;\\n  \\t\\t\\ts.w -= r.y;\\n\\n  \\t\\t\\ts.z -= r.y;\\n\\n  \\t\\t\\tthis.offset = -2.0 * s.z;\\n\\n  \\t\\t\\tba.set(r.z, this.offset);\\n  \\t\\t\\tvar divisor = ba.dot(ba);\\n\\n  \\t\\t\\tif (divisor === 0.0) {\\n  \\t\\t\\t\\tba.set(0.0, -1.0);\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tba.divideScalar(divisor);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "computeBoundingBox",\\n  \\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\tvar s = this.s0;\\n  \\t\\t\\tvar boundingBox = new Box3();\\n\\n  \\t\\t\\tboundingBox.min.x = Math.min(-s.x, -1.0);\\n  \\t\\t\\tboundingBox.min.y = Math.min(-s.y, -1.0);\\n  \\t\\t\\tboundingBox.min.z = Math.min(-s.z, -1.0);\\n\\n  \\t\\t\\tboundingBox.max.x = Math.max(s.x, 1.0);\\n  \\t\\t\\tboundingBox.max.y = Math.max(s.y, 1.0);\\n  \\t\\t\\tboundingBox.max.z = Math.max(s.z, 1.0);\\n\\n  \\t\\t\\tboundingBox.applyMatrix4(this.getTransformation());\\n\\n  \\t\\t\\treturn boundingBox;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "sample",\\n  \\t\\tvalue: function sample(position) {\\n\\n  \\t\\t\\tposition.applyMatrix4(this.inverseTransformation);\\n\\n  \\t\\t\\tvar s = this.s;\\n  \\t\\t\\tvar r = this.r;\\n  \\t\\t\\tvar ba = this.ba;\\n\\n  \\t\\t\\tvar dx = Math.abs(position.x) - s.x;\\n  \\t\\t\\tvar dy = Math.abs(position.y) - s.y;\\n  \\t\\t\\tvar dz = Math.abs(position.z) - s.z;\\n\\n  \\t\\t\\tvar mx0 = Math.max(dx, 0.0);\\n  \\t\\t\\tvar my0 = Math.max(dy, 0.0);\\n  \\t\\t\\tvar l0 = Math.sqrt(mx0 * mx0 + my0 * my0);\\n\\n  \\t\\t\\tvar p = position.z - s.z;\\n  \\t\\t\\tvar q = Math.abs(l0 + Math.min(0.0, Math.max(dx, dy)) - r.x) - s.w;\\n\\n  \\t\\t\\tvar c = Math.min(Math.max(q * ba.x + p * ba.y, 0.0), 1.0);\\n  \\t\\t\\tvar diagX = q - r.z * c;\\n  \\t\\t\\tvar diagY = p - this.offset * c;\\n\\n  \\t\\t\\tvar hx0 = Math.max(q - r.z, 0.0);\\n  \\t\\t\\tvar hy0 = position.z + s.z;\\n  \\t\\t\\tvar hx1 = Math.max(q, 0.0);\\n\\n\\n  \\t\\t\\tvar diagSq = diagX * diagX + diagY * diagY;\\n  \\t\\t\\tvar h0Sq = hx0 * hx0 + hy0 * hy0;\\n  \\t\\t\\tvar h1Sq = hx1 * hx1 + p * p;\\n  \\t\\t\\tvar paBa = q * -ba.y + p * ba.x;\\n\\n  \\t\\t\\tvar l1 = Math.sqrt(Math.min(diagSq, Math.min(h0Sq, h1Sq)));\\n\\n  \\t\\t\\treturn l1 * Math.sign(Math.max(paBa, dz)) - r.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: "serialize",\\n  \\t\\tvalue: function serialize() {\\n  \\t\\t\\tvar result = get(SuperPrimitive.prototype.__proto__ || Object.getPrototypeOf(SuperPrimitive.prototype), "serialize", this).call(this);\\n\\n  \\t\\t\\tresult.parameters = {\\n  \\t\\t\\t\\ts: this.s0.toArray(),\\n  \\t\\t\\t\\tr: this.r0.toArray()\\n  \\t\\t\\t};\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: "create",\\n  \\t\\tvalue: function create(preset) {\\n\\n  \\t\\t\\tvar parameters = superPrimitivePresets[preset];\\n\\n  \\t\\t\\treturn new SuperPrimitive({\\n  \\t\\t\\t\\ts: parameters[0],\\n  \\t\\t\\t\\tr: parameters[1]\\n  \\t\\t\\t});\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn SuperPrimitive;\\n  }(SignedDistanceFunction);\\n\\n  var superPrimitivePresets = [[new Float32Array([1.0, 1.0, 1.0, 1.0]), new Float32Array([0.0, 0.0, 0.0])], [new Float32Array([1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 0.0, 0.0])], [new Float32Array([0.0, 0.0, 1.0, 1.0]), new Float32Array([0.0, 0.0, 1.0])], [new Float32Array([1.0, 1.0, 2.0, 1.0]), new Float32Array([1.0, 1.0, 0.0])], [new Float32Array([1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 0.0])], [new Float32Array([1.0, 1.0, 0.25, 1.0]), new Float32Array([1.0, 0.25, 0.0])], [new Float32Array([1.0, 1.0, 0.25, 0.25]), new Float32Array([1.0, 0.25, 0.0])], [new Float32Array([1.0, 1.0, 1.0, 0.25]), new Float32Array([1.0, 0.1, 0.0])], [new Float32Array([1.0, 1.0, 1.0, 0.25]), new Float32Array([0.1, 0.1, 0.0])]];\\n\\n  var SDFReviver = function () {\\n  \\t\\tfunction SDFReviver() {\\n  \\t\\t\\t\\tclassCallCheck(this, SDFReviver);\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(SDFReviver, [{\\n  \\t\\t\\t\\tkey: "revive",\\n  \\t\\t\\t\\tvalue: function revive(description) {\\n\\n  \\t\\t\\t\\t\\t\\tvar sdf = void 0,\\n  \\t\\t\\t\\t\\t\\t    i = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tswitch (description.type) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase SDFType.FRACTAL_NOISE:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tsdf = new FractalNoise(description.parameters, description.material);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase SDFType.HEIGHTFIELD:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tsdf = new Heightfield(description.parameters, description.material);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase SDFType.SUPER_PRIMITIVE:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tsdf = new SuperPrimitive(description.parameters, description.material);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tsdf.operation = description.operation;\\n  \\t\\t\\t\\t\\t\\tsdf.position.fromArray(description.position);\\n  \\t\\t\\t\\t\\t\\tsdf.quaternion.fromArray(description.quaternion);\\n  \\t\\t\\t\\t\\t\\tsdf.scale.fromArray(description.scale);\\n  \\t\\t\\t\\t\\t\\tsdf.updateInverseTransformation();\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0, l = description.children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tsdf.children.push(this.revive(description.children[i]));\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn sdf;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn SDFReviver;\\n  }();\\n\\n  var ModificationResponse = function (_DataMessage) {\\n  \\tinherits(ModificationResponse, _DataMessage);\\n\\n  \\tfunction ModificationResponse() {\\n  \\t\\tclassCallCheck(this, ModificationResponse);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (ModificationResponse.__proto__ || Object.getPrototypeOf(ModificationResponse)).call(this, Action.MODIFY));\\n\\n  \\t\\t_this.sdf = null;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\treturn ModificationResponse;\\n  }(DataMessage);\\n\\n  var VolumeModifier = function (_DataProcessor) {\\n  \\t\\tinherits(VolumeModifier, _DataProcessor);\\n\\n  \\t\\tfunction VolumeModifier() {\\n  \\t\\t\\t\\tclassCallCheck(this, VolumeModifier);\\n\\n  \\t\\t\\t\\tvar _this = possibleConstructorReturn(this, (VolumeModifier.__proto__ || Object.getPrototypeOf(VolumeModifier)).call(this));\\n\\n  \\t\\t\\t\\t_this.response = new ModificationResponse();\\n\\n  \\t\\t\\t\\t_this.sdf = null;\\n\\n  \\t\\t\\t\\treturn _this;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(VolumeModifier, [{\\n  \\t\\t\\t\\tkey: "respond",\\n  \\t\\t\\t\\tvalue: function respond() {\\n  \\t\\t\\t\\t\\t\\tvar response = get(VolumeModifier.prototype.__proto__ || Object.getPrototypeOf(VolumeModifier.prototype), "respond", this).call(this);\\n\\n  \\t\\t\\t\\t\\t\\tresponse.sdf = this.sdf !== null ? this.sdf.serialize() : null;\\n\\n  \\t\\t\\t\\t\\t\\treturn response;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "createTransferList",\\n  \\t\\t\\t\\tvalue: function createTransferList() {\\n  \\t\\t\\t\\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\t\\t\\t\\tget(VolumeModifier.prototype.__proto__ || Object.getPrototypeOf(VolumeModifier.prototype), "createTransferList", this).call(this, transferList);\\n\\n  \\t\\t\\t\\t\\t\\treturn this.sdf !== null ? this.sdf.createTransferList(transferList) : transferList;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: "process",\\n  \\t\\t\\t\\tvalue: function process(request) {\\n  \\t\\t\\t\\t\\t\\tvar data = get(VolumeModifier.prototype.__proto__ || Object.getPrototypeOf(VolumeModifier.prototype), "process", this).call(this, request).getData();\\n\\n  \\t\\t\\t\\t\\t\\tvar sdf = this.sdf = SDFReviver.revive(request.sdf);\\n\\n  \\t\\t\\t\\t\\t\\tvar result = ConstructiveSolidGeometry.run(request.cellPosition, request.cellSize, data, sdf);\\n\\n  \\t\\t\\t\\t\\t\\tset(VolumeModifier.prototype.__proto__ || Object.getPrototypeOf(VolumeModifier.prototype), "data", result !== null ? result.compress() : null, this);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn VolumeModifier;\\n  }(DataProcessor);\\n\\n  var volumeModifier = new VolumeModifier();\\n\\n  var surfaceExtractor = new SurfaceExtractor();\\n\\n  var action = null;\\n\\n  self.addEventListener("message", function onMessage(event) {\\n  \\tvar request = event.data;\\n  \\taction = request.action;\\n\\n  \\tswitch (action) {\\n\\n  \\t\\tcase Action.MODIFY:\\n  \\t\\t\\tpostMessage(volumeModifier.process(request).respond(), volumeModifier.createTransferList());\\n  \\t\\t\\tbreak;\\n\\n  \\t\\tcase Action.EXTRACT:\\n  \\t\\t\\tpostMessage(surfaceExtractor.process(request).respond(), surfaceExtractor.createTransferList());\\n  \\t\\t\\tbreak;\\n\\n  \\t\\tcase Action.CONFIGURE:\\n  \\t\\t\\tHermiteData.resolution = request.resolution;\\n  \\t\\t\\tVoxelCell.errorThreshold = request.errorThreshold;\\n  \\t\\t\\tbreak;\\n\\n  \\t\\tcase Action.CLOSE:\\n  \\t\\tdefault:\\n  \\t\\t\\tclose();\\n\\n  \\t}\\n  });\\n\\n  self.addEventListener("error", function onError(event) {\\n\\n  \\tvar processor = action === Action.MODIFY ? volumeModifier : action === Action.EXTRACT ? surfaceExtractor : null;\\n\\n  \\tvar response = void 0;\\n\\n  \\tif (processor !== null) {\\n  \\t\\tresponse = processor.respond();\\n\\n  \\t\\tresponse.action = Action.CLOSE;\\n  \\t\\tresponse.error = event;\\n\\n  \\t\\tpostMessage(response, processor.createTransferList());\\n  \\t} else {\\n  \\t\\tresponse = new Message(Action.CLOSE);\\n  \\t\\tresponse.error = event;\\n\\n  \\t\\tpostMessage(response);\\n  \\t}\\n\\n  \\tclose();\\n  });\\n\\n}());\\n\',Ln=function(e){i(r,u);function r(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:navigator.hardwareConcurrency;t(this,r);var e=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));return e.workerURL=URL.createObjectURL(new Blob([Un],{type:"text/javascript"})),e.maxWorkers=Math.min(navigator.hardwareConcurrency,Math.max(n,1)),e.workers=[],e.busyWorkers=new WeakSet,e.configurationMessage=new Vn,e}return n(r,[{key:"handleEvent",value:function(t){switch(t.type){case"message":this.busyWorkers.delete(t.target),Rn.worker=t.target,Rn.response=t.data,this.dispatchEvent(Rn),this.workers.length>this.maxWorkers&&this.closeWorker(t.target);break;case"error":console.error("Encountered an unexpected error",t)}}},{key:"closeWorker",value:function(t){var n=this.workers.indexOf(t);this.busyWorkers.has(t)?(this.busyWorkers.delete(t),t.terminate()):t.postMessage(new qn(In.CLOSE)),t.removeEventListener("message",this),t.removeEventListener("error",this),n>=0&&this.workers.splice(n,1)}},{key:"createWorker",value:function(){var t=new Worker(this.workerURL);return this.workers.push(t),t.addEventListener("message",this),t.addEventListener("error",this),t.postMessage(this.configurationMessage),t}},{key:"getWorker",value:function(){var t=null,n=void 0,e=void 0;for(n=0,e=this.workers.length;n<e;++n)if(!this.busyWorkers.has(this.workers[n])){t=this.workers[n],this.busyWorkers.add(t);break}return null===t&&this.workers.length<this.maxWorkers&&null!==this.workerURL&&(t=this.createWorker(),this.busyWorkers.add(t)),t}},{key:"clear",value:function(){for(;this.workers.length>0;)this.closeWorker(this.workers.pop())}},{key:"dispose",value:function(){this.clear(),URL.revokeObjectURL(this.workerURL),this.workerURL=null}}]),r}(),$n=function(n){i(e,o);function e(n){t(this,e);var i=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n));return i.octant=null,i.octantId=null,i.error=null,i}return e}(),Nn=(new $n("modificationstart"),new $n("modificationend"),new $n("extractionstart"),new $n("extractionend"),new $n("load")),jn=(new $n("error"),function(e){i(r,u);function r(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};t(this,r);var e=void 0!==n.world?n.world:{};Wt.resolution=void 0!==n.resolution?n.resolution:32;var i=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));return i.object=null,i.world=new On(e.cellSize,e.levels,e.keyDesign),i.clipmap=new Tn(i.world),i.clipmap.addEventListener("shellupdate",i),i.threadPool=new Ln(n.workers),i.threadPool.addEventListener("message",i),i.tasks=new WeakMap,i.sdfLoader=new ht,i.sdfLoader.addEventListener("load",i),i.history=[],i.dtSq=i.world.getCellSize(),i}n(r,[{key:"handleEvent",value:function(t){switch(t.type){case"shellupdate":case"message":break;case"load":this.revive(t.descriptions),this.dispatchEvent(Nn)}}},{key:"applyCSG",value:function(t){this.world.applyCSG(t),this.history.push(t)}},{key:"union",value:function(t){this.applyCSG(t.setOperationType(l.UNION))}},{key:"subtract",value:function(t){this.applyCSG(t.setOperationType(l.DIFFERENCE))}},{key:"intersect",value:function(t){this.applyCSG(t.setOperationType(l.INTERSECTION))}},{key:"update",value:function(t){this.clipmap.position.distanceToSquared(t)>=this.dtSq&&this.clipmap.update(t)}},{key:"raycast",value:function(t){return this.world.raycast(t)}},{key:"clear",value:function(){this.world.clear(),this.clipmap.clear(),this.threadPool.clear(),this.sdfLoader.clear(),this.tasks=new WeakMap,this.history=[]}},{key:"dispose",value:function(){this.threadPool.dispose()}},{key:"revive",value:function(t){var n=void 0,e=void 0;for(n=0,e=t.length;n<e;++n)this.applyCSG(ut.revive(t[n]))}},{key:"save",value:function(){return 0===this.history.length?null:URL.createObjectURL(new Blob([JSON.stringify(this.history)],{type:"text/json"}))}},{key:"load",value:function(t){var n=JSON.parse(t);this.clear(),this.sdfLoader.load(n)}}])}(),function(){function e(n,i,a,r,s){t(this,e),this.indices=n,this.positions=i,this.normals=a,this.uvs=r,this.materials=s}return n(e,[{key:"serialize",value:function(){return{indices:this.indices,positions:this.positions,normals:this.normals,uvs:this.uvs,materials:this.materials}}},{key:"deserialize",value:function(t){var n=this;return null!==t?(this.indices=t.indices,this.positions=t.positions,this.normals=t.normals,this.uvs=t.uvs,this.materials=t.materials):n=null,n}},{key:"createTransferList",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return t.push(this.indices.buffer),t.push(this.positions.buffer),t.push(this.normals.buffer),t.push(this.uvs.buffer),t.push(this.materials.buffer),t}}]),e}()),Xn=[new Uint8Array([0,4,0]),new Uint8Array([1,5,0]),new Uint8Array([2,6,0]),new Uint8Array([3,7,0]),new Uint8Array([0,2,1]),new Uint8Array([4,6,1]),new Uint8Array([1,3,1]),new Uint8Array([5,7,1]),new Uint8Array([0,1,2]),new Uint8Array([2,3,2]),new Uint8Array([4,5,2]),new Uint8Array([6,7,2])],Yn=[new Uint8Array([0,1,2,3,0]),new Uint8Array([4,5,6,7,0]),new Uint8Array([0,4,1,5,1]),new Uint8Array([2,6,3,7,1]),new Uint8Array([0,2,4,6,2]),new Uint8Array([1,3,5,7,2])],Hn=[[new Uint8Array([4,0,0]),new Uint8Array([5,1,0]),new Uint8Array([6,2,0]),new Uint8Array([7,3,0])],[new Uint8Array([2,0,1]),new Uint8Array([6,4,1]),new Uint8Array([3,1,1]),new Uint8Array([7,5,1])],[new Uint8Array([1,0,2]),new Uint8Array([3,2,2]),new Uint8Array([5,4,2]),new Uint8Array([7,6,2])]],Zn=[[new Uint8Array([1,4,0,5,1,1]),new Uint8Array([1,6,2,7,3,1]),new Uint8Array([0,4,6,0,2,2]),new Uint8Array([0,5,7,1,3,2])],[new Uint8Array([0,2,3,0,1,0]),new Uint8Array([0,6,7,4,5,0]),new Uint8Array([1,2,0,6,4,2]),new Uint8Array([1,3,1,7,5,2])],[new Uint8Array([1,1,0,3,2,0]),new Uint8Array([1,5,4,7,6,0]),new Uint8Array([0,1,5,0,4,1]),new Uint8Array([0,3,7,2,6,1])]],Qn=[[new Uint8Array([3,2,1,0,0]),new Uint8Array([7,6,5,4,0])],[new Uint8Array([5,1,4,0,1]),new Uint8Array([7,3,6,2,1])],[new Uint8Array([6,4,2,0,2]),new Uint8Array([7,5,3,1,2])]],Gn=[new Uint8Array([3,2,1,0]),new Uint8Array([7,5,6,4]),new Uint8Array([11,10,9,8])],Kn=Math.pow(2,16)-1;function Wn(t,n,e){var i=[0,0,0,0],a=void 0,r=void 0,s=void 0,o=void 0;if(null!==t[0].voxel&&null!==t[1].voxel&&null!==t[2].voxel&&null!==t[3].voxel)!function(t,n,e){var i=[-1,-1,-1,-1],a=[!1,!1,!1,!1],r=1/0,s=0,o=!1,u=void 0,l=void 0,h=void 0,c=void 0,d=void 0,v=void 0,m=void 0;for(m=0;m<4;++m)d=t[m],v=Gn[n][m],u=ft[v][0],l=ft[v][1],h=d.voxel.materials>>u&1,c=d.voxel.materials>>l&1,d.size<r&&(r=d.size,s=m,o=h!==H.AIR),i[m]=d.voxel.index,a[m]=h!==c;a[s]&&(o?(e.push(i[0]),e.push(i[3]),e.push(i[1]),e.push(i[0]),e.push(i[2]),e.push(i[3])):(e.push(i[0]),e.push(i[1]),e.push(i[3]),e.push(i[0]),e.push(i[3]),e.push(i[2])))}(t,n,e);else for(s=0;s<2;++s){for(i[0]=Qn[n][s][0],i[1]=Qn[n][s][1],i[2]=Qn[n][s][2],i[3]=Qn[n][s][3],a=[],o=0;o<4;++o)if(null!==(r=t[o]).voxel)a[o]=r;else{if(null===r.children)break;a[o]=r.children[i[o]]}4===o&&Wn(a,Qn[n][s][4],e)}}function Jn(t,n,e){var i=[0,0,0,0],a=[[0,0,1,1],[0,1,0,1]],r=void 0,s=void 0,o=void 0,u=void 0,l=void 0;if(null!==t[0].children||null!==t[1].children){for(u=0;u<4;++u)i[0]=Hn[n][u][0],i[1]=Hn[n][u][1],Jn([null===t[0].children?t[0]:t[0].children[i[0]],null===t[1].children?t[1]:t[1].children[i[1]]],Hn[n][u][2],e);for(u=0;u<4;++u){for(i[0]=Zn[n][u][1],i[1]=Zn[n][u][2],i[2]=Zn[n][u][3],i[3]=Zn[n][u][4],s=a[Zn[n][u][0]],r=[],l=0;l<4;++l)if(null!==(o=t[s[l]]).voxel)r[l]=o;else{if(null===o.children)break;r[l]=o.children[i[l]]}4===l&&Wn(r,Zn[n][u][5],e)}}}var te=function(){function e(){t(this,e)}return n(e,null,[{key:"run",value:function(t){var n=[],e=t.voxelCount,i=null,a=null,r=null,s=null,o=null;return e>Kn?console.warn("Could not create geometry for cell at position",t.min,"(vertex count of",e,"exceeds limit of ",Kn,")"):e>0&&(a=new Float32Array(3*e),r=new Float32Array(3*e),s=new Float32Array(2*e),o=new Uint8Array(e),function t(n,e,i,a){var r=void 0,s=void 0;if(null!==n.children)for(r=0;r<8;++r)a=t(n.children[r],e,i,a);else null!==n.voxel&&((s=n.voxel).index=a,e[3*a]=s.position.x,e[3*a+1]=s.position.y,e[3*a+2]=s.position.z,i[3*a]=s.normal.x,i[3*a+1]=s.normal.y,i[3*a+2]=s.normal.z,++a);return a}(t.root,a,r,0),function t(n,e){var i=n.children,a=[0,0,0,0],r=void 0;if(null!==i){for(r=0;r<8;++r)t(i[r],e);for(r=0;r<12;++r)a[0]=Xn[r][0],a[1]=Xn[r][1],Jn([i[a[0]],i[a[1]]],Xn[r][2],e);for(r=0;r<6;++r)a[0]=Yn[r][0],a[1]=Yn[r][1],a[2]=Yn[r][2],a[3]=Yn[r][3],Wn([i[a[0]],i[a[1]],i[a[2]],i[a[3]]],Yn[r][4],e)}}(t.root,n),i=new jn(new Uint16Array(n),a,r,s,o)),i}}]),e}(),ne=new f,ee=function(){function e(){t(this,e)}return n(e,null,[{key:"calculateCoefficients",value:function(t,n,e){var i=void 0,a=void 0,r=void 0;return 0===n?(ne.x=1,ne.y=0):(i=(e-t)/(2*n),a=Math.sqrt(1+i*i),r=1/(i>=0?i+a:i-a),ne.x=1/Math.sqrt(1+r*r),ne.y=r*ne.x),ne}}]),e}(),ie=function(){function e(){t(this,e)}return n(e,null,[{key:"rotateXY",value:function(t,n){var e=n.x,i=n.y,a=t.x,r=t.y;t.set(e*a-i*r,i*a+e*r)}},{key:"rotateQXY",value:function(t,n,e){var i=e.x,a=e.y,r=i*i,s=a*a,o=2*i*a*n,u=t.x,l=t.y;t.set(r*u-o+s*l,s*u+o+r*l)}}]),e}(),ae=.1,re=5,se=new X,oe=new p,ue=new f,le=new h;function he(t,n){var e=t.elements,i=n.elements,a=void 0;0!==e[1]&&(a=ee.calculateCoefficients(e[0],e[1],e[3]),ie.rotateQXY(ue.set(e[0],e[3]),e[1],a),e[0]=ue.x,e[3]=ue.y,ie.rotateXY(ue.set(e[2],e[4]),a),e[2]=ue.x,e[4]=ue.y,e[1]=0,ie.rotateXY(ue.set(i[0],i[3]),a),i[0]=ue.x,i[3]=ue.y,ie.rotateXY(ue.set(i[1],i[4]),a),i[1]=ue.x,i[4]=ue.y,ie.rotateXY(ue.set(i[2],i[5]),a),i[2]=ue.x,i[5]=ue.y)}function ce(t,n){var e=t.elements,i=n.elements,a=void 0;0!==e[2]&&(a=ee.calculateCoefficients(e[0],e[2],e[5]),ie.rotateQXY(ue.set(e[0],e[5]),e[2],a),e[0]=ue.x,e[5]=ue.y,ie.rotateXY(ue.set(e[1],e[4]),a),e[1]=ue.x,e[4]=ue.y,e[2]=0,ie.rotateXY(ue.set(i[0],i[6]),a),i[0]=ue.x,i[6]=ue.y,ie.rotateXY(ue.set(i[1],i[7]),a),i[1]=ue.x,i[7]=ue.y,ie.rotateXY(ue.set(i[2],i[8]),a),i[2]=ue.x,i[8]=ue.y)}function de(t,n){var e=t.elements,i=n.elements,a=void 0;0!==e[4]&&(a=ee.calculateCoefficients(e[3],e[4],e[5]),ie.rotateQXY(ue.set(e[3],e[5]),e[4],a),e[3]=ue.x,e[5]=ue.y,ie.rotateXY(ue.set(e[1],e[2]),a),e[1]=ue.x,e[2]=ue.y,e[4]=0,ie.rotateXY(ue.set(i[3],i[6]),a),i[3]=ue.x,i[6]=ue.y,ie.rotateXY(ue.set(i[4],i[7]),a),i[4]=ue.x,i[7]=ue.y,ie.rotateXY(ue.set(i[5],i[8]),a),i[5]=ue.x,i[8]=ue.y)}function ve(t){var n=Math.abs(t)<ae?0:1/t;return Math.abs(n)<ae?0:n}var me=function(){function e(){t(this,e)}return n(e,null,[{key:"solve",value:function(t,n,e){var i=function(t,n){var e=t.elements,i=void 0;for(i=0;i<re;++i)he(t,n),ce(t,n),de(t,n);return le.set(e[0],e[3],e[5])}(se.copy(t),oe.identity()),a=function(t,n){var e=t.elements,i=e[0],a=e[3],r=e[6],s=e[1],o=e[4],u=e[7],l=e[2],h=e[5],c=e[8],d=ve(n.x),v=ve(n.y),m=ve(n.z);return t.set(i*d*i+a*v*a+r*m*r,i*d*s+a*v*o+r*m*u,i*d*l+a*v*h+r*m*c,s*d*i+o*v*a+u*m*r,s*d*s+o*v*o+u*m*u,s*d*l+o*v*h+u*m*c,l*d*i+h*v*a+c*m*r,l*d*s+h*v*o+c*m*u,l*d*l+h*v*h+c*m*c)}(oe,i);e.copy(n).applyMatrix3(a)}}]),e}(),ye=new h;var fe=function(){function e(){t(this,e),this.data=null,this.ata=new X,this.atb=new h,this.massPoint=new h,this.hasSolution=!1}return n(e,[{key:"setData",value:function(t){return this.data=t,this.hasSolution=!1,this}},{key:"solve",value:function(t){var n=this.data,e=this.massPoint,i=this.ata.copy(n.ata),a=this.atb.copy(n.atb),r=1/0;!this.hasSolution&&null!==n&&n.numPoints>0&&(ye.copy(n.massPointSum).divideScalar(n.numPoints),e.copy(ye),i.applyToVector3(ye),a.sub(ye),me.solve(i,a,t),s=a,o=t,i.applyToVector3(ye.copy(o)),ye.subVectors(s,ye),r=ye.dot(ye),t.add(e),this.hasSolution=!0);var s,o;return r}}]),e}(),xe=function(){function e(){t(this,e),this.ata=new X,this.ata.set(0,0,0,0,0,0),this.atb=new h,this.massPointSum=new h,this.numPoints=0}return n(e,[{key:"set",value:function(t,n,e,i){return this.ata.copy(t),this.atb.copy(n),this.massPointSum.copy(e),this.numPoints=i,this}},{key:"copy",value:function(t){return this.set(t.ata,t.atb,t.massPointSum,t.numPoints)}},{key:"add",value:function(t,n){var e=n.x,i=n.y,a=n.z,r=t.dot(n),s=this.ata.elements,o=this.atb;s[0]+=e*e,s[1]+=e*i,s[3]+=i*i,s[2]+=e*a,s[4]+=i*a,s[5]+=a*a,o.x+=r*e,o.y+=r*i,o.z+=r*a,this.massPointSum.add(t),++this.numPoints}},{key:"addData",value:function(t){this.ata.add(t.ata),this.atb.add(t.atb),this.massPointSum.add(t.massPointSum),this.numPoints+=t.numPoints}},{key:"clear",value:function(){this.ata.set(0,0,0,0,0,0),this.atb.set(0,0,0),this.massPointSum.set(0,0,0),this.numPoints=0}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),e}(),pe=function n(){t(this,n),this.materials=0,this.edgeCount=0,this.index=-1,this.position=new h,this.normal=new h,this.qefData=null},ge=new fe,ke=-1,ze=function(e){i(r,pt);function r(n,e){t(this,r);var i=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,n,e));return i.voxel=null,i}return n(r,[{key:"contains",value:function(t){var n=this.min,e=this.size;return t.x>=n.x-.1&&t.y>=n.y-.1&&t.z>=n.z-.1&&t.x<=n.x+e+.1&&t.y<=n.y+e+.1&&t.z<=n.z+e+.1}},{key:"collapse",value:function(){var t=this.children,n=[-1,-1,-1,-1,-1,-1,-1,-1],e=new h,i=-1,a=null!==t,r=0,s=void 0,o=void 0,u=void 0,l=void 0,c=void 0,d=void 0;if(a){for(l=new xe,c=0,d=0;d<8;++d)r+=(s=t[d]).collapse(),u=s.voxel,null!==s.children?a=!1:null!==u&&(l.addData(u.qefData),i=u.materials>>7-d&1,n[d]=u.materials>>d&1,++c);if(a&&ge.setData(l).solve(e)<=ke){for((u=new pe).position.copy(this.contains(e)?e:ge.massPoint),d=0;d<8;++d)o=n[d],s=t[d],-1===o?u.materials|=i<<d:(u.materials|=o<<d,u.normal.add(s.voxel.normal));u.normal.normalize(),u.qefData=l,this.voxel=u,this.children=null,r+=c-1}}return r}}],[{key:"errorThreshold",get:function(){return ke},set:function(t){ke=t}}]),r}();function we(t,n,e,i,a){var r=0;for(n>>=1;n>0;n>>=1,r=0)e>=n&&(r+=4,e-=n),i>=n&&(r+=2,i-=n),a>=n&&(r+=1,a-=n),null===t.children&&t.split(),t=t.children[r];return t}function be(t,n,e,i,a){var r=t+1,s=r*r,o=new pe,u=void 0,l=void 0,h=void 0,c=void 0,d=void 0;for(u=0,d=0;d<8;++d)c=(i+(h=yt[d])[2])*s+(e+h[1])*r+(n+h[0]),u|=Math.min(a[c],H.SOLID)<<d;for(l=0,d=0;d<12;++d)(u>>ft[d][0]&1)!==(u>>ft[d][1]&1)&&++l;return o.materials=u,o.edgeCount=l,o.qefData=new xe,o}var Me=function(e){i(r,Pt);function r(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t(this,r);var s=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));return s.root=new ze(e,i),s.voxelCount=0,null!==n&&null!==n.edgeData&&s.construct(n),ze.errorThreshold>=0&&s.simplify(),s}return n(r,[{key:"simplify",value:function(){this.voxelCount-=this.root.collapse()}},{key:"construct",value:function(t){var n=Wt.resolution,e=t.edgeData,i=t.materialIndices,a=new fe,r=new h,s=[e.edgesX(this.min,this.root.size),e.edgesY(this.min,this.root.size),e.edgesZ(this.min,this.root.size)],o=[new Uint8Array([0,1,2,3]),new Uint8Array([0,1,4,5]),new Uint8Array([0,2,4,6])],u=0,l=void 0,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,x=void 0,p=void 0,g=void 0,k=void 0;for(g=0;g<3;++g){d=o[g],l=s[g];var z=!0,w=!1,b=void 0;try{for(var M,S=l[Symbol.iterator]();!(z=(M=S.next()).done);z=!0)for((c=M.value).computeZeroCrossingPosition(r),k=0;k<4;++k)v=yt[d[k]],f=c.coordinates.x-v[0],x=c.coordinates.y-v[1],p=c.coordinates.z-v[2],f>=0&&x>=0&&p>=0&&f<n&&x<n&&p<n&&(null===(m=we(this.root,n,f,x,p)).voxel&&(m.voxel=be(n,f,x,p,i),++u),(y=m.voxel).normal.add(c.n),y.qefData.add(r,c.n),y.qefData.numPoints===y.edgeCount&&(a.setData(y.qefData).solve(y.position),m.contains(y.position)||y.position.copy(a.massPoint),y.normal.normalize()))}catch(t){w=!0,b=t}finally{try{!z&&S.return&&S.return()}finally{if(w)throw b}}}this.voxelCount=u}}]),r}(),Se=0,Ce=new h;function Oe(t,n,e){var i=function(t){var n=Se,e=Wt.resolution,i=new h(0,0,0),a=new h(e,e,e),r=new v(Ce,Ce.clone().addScalar(Se)),s=t.getBoundingBox();return t.type!==l.INTERSECTION&&(s.intersectsBox(r)?(i.copy(s.min).max(r.min).sub(r.min),i.x=Math.ceil(i.x*e/n),i.y=Math.ceil(i.y*e/n),i.z=Math.ceil(i.z*e/n),a.copy(s.max).min(r.max).sub(r.min),a.x=Math.floor(a.x*e/n),a.y=Math.floor(a.y*e/n),a.z=Math.floor(a.z*e/n)):(i.set(e,e,e),a.set(0,0,0))),new v(i,a)}(t),a=void 0,r=void 0,s=void 0,o=void 0,u=!1;if(t.type===l.DENSITY_FUNCTION?function(t,n,e){var i=Se,a=Wt.resolution,r=a+1,s=r*r,o=n.materialIndices,u=Ce,l=new h,c=new h,d=e.max.x,v=e.max.y,m=e.max.z,y=void 0,f=0,x=void 0,p=void 0,g=void 0;for(g=e.min.z;g<=m;++g)for(l.z=g*i/a,p=e.min.y;p<=v;++p)for(l.y=p*i/a,x=e.min.x;x<=d;++x)l.x=x*i/a,(y=t.generateMaterialIndex(c.addVectors(u,l)))!==H.AIR&&(o[g*s+p*r+x]=y,++f);n.materials=f}(t,n,i):n.empty?t.type===l.UNION&&(n.set(e),u=!0):n.full&&t.type===l.UNION||function(t,n,e,i){var a=Wt.resolution+1,r=a*a,s=i.max.x,o=i.max.y,u=i.max.z,l=void 0,h=void 0,c=void 0;for(c=i.min.z;c<=u;++c)for(h=i.min.y;h<=o;++h)for(l=i.min.x;l<=s;++l)t.updateMaterialIndex(c*r+h*a+l,n,e)}(t,n,e,i),!u&&!n.empty&&!n.full){for(r=(a=t.type===l.DENSITY_FUNCTION?function(t,n,e){var i=Se,a=Wt.resolution,r=a+1,s=r*r,o=new Uint32Array([1,r,s]),u=n.materialIndices,l=Ce,c=new h,d=new h,v=new jt,m=new Uint32Array(3),y=new Qt(Qt.calculate1DEdgeCount(a)),f=void 0,x=void 0,p=void 0,g=void 0,k=void 0,z=void 0,w=void 0,b=void 0,M=void 0,S=void 0,C=void 0,O=void 0,D=void 0,P=void 0,A=void 0,_=void 0,T=void 0,I=void 0,q=void 0;for(A=4,D=0,P=0;P<3;A>>=1,D=0,++P){switch(_=yt[A],f=y.indices[P],x=y.zeroCrossings[P],p=y.normals[P],g=o[P],w=e.min.x,S=e.max.x,b=e.min.y,C=e.max.y,M=e.min.z,O=e.max.z,P){case 0:w=Math.max(w-1,0),S=Math.min(S,a-1);break;case 1:b=Math.max(b-1,0),C=Math.min(C,a-1);break;case 2:M=Math.max(M-1,0),O=Math.min(O,a-1)}for(q=M;q<=O;++q)for(I=b;I<=C;++I)for(T=w;T<=S;++T)z=(k=q*s+I*r+T)+g,u[k]!==u[z]&&(c.set(T*i/a,I*i/a,q*i/a),d.set((T+_[0])*i/a,(I+_[1])*i/a,(q+_[2])*i/a),v.a.addVectors(l,c),v.b.addVectors(l,d),t.generateEdge(v),f[D]=k,x[D]=v.t,p[3*D]=v.n.x,p[3*D+1]=v.n.y,p[3*D+2]=v.n.z,++D);m[P]=D}return{edgeData:y,lengths:m}}(t,n,i):function(t,n,e){var i=Wt.resolution,a=i+1,r=new Uint32Array([1,a,a*a]),s=n.materialIndices,o=new jt,u=new jt,h=e.edgeData,c=n.edgeData,d=new Uint32Array(3),v=Qt.calculate1DEdgeCount(i),m=new Qt(Math.min(v,c.indices[0].length+h.indices[0].length),Math.min(v,c.indices[1].length+h.indices[1].length),Math.min(v,c.indices[2].length+h.indices[2].length)),y=void 0,f=void 0,x=void 0,p=void 0,g=void 0,k=void 0,z=void 0,w=void 0,b=void 0,M=void 0,S=void 0,C=void 0,O=void 0,D=void 0,P=void 0,A=void 0,_=void 0,T=void 0,I=void 0,q=void 0,E=void 0,V=void 0,F=void 0;for(T=0,I=0;I<3;T=0,++I){for(y=h.indices[I],p=c.indices[I],z=m.indices[I],f=h.zeroCrossings[I],g=c.zeroCrossings[I],w=m.zeroCrossings[I],x=h.normals[I],k=c.normals[I],b=m.normals[I],M=r[I],V=y.length,F=p.length,q=0,E=0;q<V;++q)if(C=(S=y[q])+M,(P=s[S])!==(A=s[C])&&(P===H.AIR||A===H.AIR)){for(o.t=f[q],o.n.x=x[3*q],o.n.y=x[3*q+1],o.n.z=x[3*q+2],t.type===l.DIFFERENCE&&o.n.negate(),_=o;E<F&&p[E]<=S;)D=(O=p[E])+M,u.t=g[E],u.n.x=k[3*E],u.n.y=k[3*E+1],u.n.z=k[3*E+2],P=s[O],O<S?P===(A=s[D])||P!==H.AIR&&A!==H.AIR||(z[T]=O,w[T]=u.t,b[3*T]=u.n.x,b[3*T+1]=u.n.y,b[3*T+2]=u.n.z,++T):_=t.selectEdge(u,o,P===H.SOLID),++E;z[T]=S,w[T]=_.t,b[3*T]=_.n.x,b[3*T+1]=_.n.y,b[3*T+2]=_.n.z,++T}for(;E<F;)D=(O=p[E])+M,(P=s[O])===(A=s[D])||P!==H.AIR&&A!==H.AIR||(z[T]=O,w[T]=g[E],b[3*T]=k[3*E],b[3*T+1]=k[3*E+1],b[3*T+2]=k[3*E+2],++T),++E;d[I]=T}return{edgeData:m,lengths:d}}(t,n,e)).edgeData,s=a.lengths,o=0;o<3;++o)r.indices[o]=r.indices[o].slice(0,s[o]),r.zeroCrossings[o]=r.zeroCrossings[o].slice(0,s[o]),r.normals[o]=r.normals[o].slice(0,3*s[o]);n.edgeData=r}}var De=function(){function e(){t(this,e)}return n(e,null,[{key:"run",value:function(t,n,e,i){Ce.fromArray(t),Se=n,null===e?i.operation===l.UNION&&(e=new Wt(!1)):e.decompress();var a=i.toCSG(),r=null!==e?function t(n){var e=n.children,i=void 0,a=void 0,r=void 0,s=void 0;for(n.type===l.DENSITY_FUNCTION&&Oe(n,i=new Wt),r=0,s=e.length;r<s&&(a=t(e[r]),void 0===i?i=a:null!==a?null===i?n.type===l.UNION&&(i=a):Oe(n,i,a):n.type===l.INTERSECTION&&(i=null),null!==i||n.type===l.UNION);++r);return null!==i&&i.empty?null:i}(a):null;if(null!==r){switch(i.operation){case l.UNION:a=new Q(a);break;case l.DIFFERENCE:a=new G(a);break;case l.INTERSECTION:a=new K(a)}Oe(a,e,r),e.contoured=!1}return null!==e&&e.empty?null:e}}]),e}(),Pe=new Wt(!1),Ae=function(){function e(){t(this,e),this.data=null,this.response=null}return n(e,[{key:"getData",value:function(){return this.data}},{key:"respond",value:function(){return this.response.data=this.data.serialize(),this.response}},{key:"createTransferList",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return null!==this.data&&this.data.createTransferList(t),t}},{key:"process",value:function(t){return this.data=Pe.deserialize(t.data),this}}]),e}(),_e=(function(r){i(s,Ae);function s(){t(this,s);var n=a(this,(s.__proto__||Object.getPrototypeOf(s)).call(this));return n.response=new Fn,n.decompressionTarget=new Wt(!1),n.isosurface=null,n}n(s,[{key:"respond",value:function(){var t=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),"respond",this).call(this);return t.isosurface=null!==this.isosurface?this.isosurface.serialise():null,t}},{key:"createTransferList",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),"createTransferList",this).call(this,t),null!==this.isosurface?this.isosurface.createTransferList(t):t}},{key:"process",value:function(t){var n=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),"process",this).call(this,t).getData(),i=new Me(n.decompress(this.decompressionTarget));return this.isosurface=te.run(i),this.decompressionTarget.clear(),this}}])}(),function(r){i(s,Ae);function s(){t(this,s);var n=a(this,(s.__proto__||Object.getPrototypeOf(s)).call(this));return n.response=new Bn,n.sdf=null,n}n(s,[{key:"respond",value:function(){var t=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),"respond",this).call(this);return t.sdf=null!==this.sdf?this.sdf.serialize():null,t}},{key:"createTransferList",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),"createTransferList",this).call(this,t),null!==this.sdf?this.sdf.createTransferList(t):t}},{key:"process",value:function(t){var n=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),"process",this).call(this,t).getData(),i=this.sdf=ut.revive(t.sdf),a=De.run(t.cellPosition,t.cellSize,n,i);return function t(n,e,i,a){var r=Object.getOwnPropertyDescriptor(n,e);if(void 0===r){var s=Object.getPrototypeOf(n);null!==s&&t(s,e,i,a)}else if("value"in r&&r.writable)r.value=i;else{var o=r.set;void 0!==o&&o.call(a,i)}return i}(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),"data",null!==a?a.compress():null,this),this}}])}(),function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Report";t(this,e),this.name=n,this.lines=[],this.data=[]}return n(e,[{key:"clear",value:function(){this.data=[]}},{key:"addLine",value:function(t){this.lines.push(t)}},{key:"addValue",value:function(t){this.data.push(t)}},{key:"toString",value:function(){var t=this.lines,n=this.data,e=this.name+"\\n\\n",i=void 0,a=void 0;for(i=0,a=t.length;i<a;++i)e+=t[i]+"\\n";for(e+="\\nValues:\\n",e+="i, ms\\n",i=0,a=n.length;i<a;++i)e+=i+1+", "+n[i]+"\\n";return e}}]),e}()),Te=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;t(this,e),this.name=n}return n(e,[{key:"initialize",value:function(){throw new Error("Test#initialize method not implemented!")}},{key:"clear",value:function(){throw new Error("Test#clear method not implemented!")}},{key:"run",value:function(){throw new Error("Test#run method not implemented!")}}]),e}(),Ie=function(e){i(r,Te);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,"Compression Test"));return n.data=null,n.targetContainer=new Wt(!1),n}return n(r,[{key:"initialize",value:function(){var t=[-.5,-.5,-.5],n=at.create(ot);return n.scale.set(.475,.475,.475),n.updateInverseTransformation(),this.data=De.run(t,1,null,n.setOperationType(l.UNION)),this}},{key:"clear",value:function(){return this.data=null,this.targetContainer.clear(),this}},{key:"run",value:function(){var t=new _e("Compression Report"),n=this.targetContainer,e=this.data,i=Wt.resolution,a=Math.pow(i+1,3),r=3*Math.pow(i+1,2)*i,s=void 0,o=void 0,u=void 0,l=void 0,h=void 0,c=void 0,d=void 0;for(t.addLine("Performing 200 compression tasks"),d=0;d<200;++d)c=performance.now(),e.compress(n),t.addValue(performance.now()-c);return o=n.materials,u=n.materialIndices.length,l=n.runLengths.length,h=(s=e.edgeData).indices[0].length+s.indices[1].length+s.indices[2].length,t.addLine("Material Statistics"),t.addLine("Total Materials: "+a+" ("+o+" solid)"),t.addLine("Compressed Materials: "+u+" (+ "+l+" run-lengths)"),t.addLine("Compression Ratio: "+(a/(u+4*l)).toFixed(2)),t.addLine("Space Savings: "+(100*(1-(u+4*l)/a)).toFixed(2)+"%"),t.addLine("Maximum Memory Usage: "+(8*a/8/1024).toFixed(2)+" KB"),t.addLine("Estimated Memory Usage: "+((8*u+32*l)/8/1024).toFixed(2)+" KB\\n"),t.addLine("Edge Data Statistics"),t.addLine("Total Edges: "+h+" ("+r+" max)"),t.addLine("Compression Ratio: "+(r/h).toFixed(2)),t.addLine("Space Savings: "+(100*(1-h/r)).toFixed(2)+"%"),t.addLine("Maximum Memory Usage: "+((32*r+32*r+3*r*32)/8/1024/1024).toFixed(2)+" MB"),t.addLine("Estimated Memory Usage: "+((32*h+32*h+3*h*32)/8/1024).toFixed(2)+" KB"),console.log("Compressed data",n),t}}]),r}(),qe=function(e){i(r,Te);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,"Decompression Test"));return n.data=null,n.targetContainer=new Wt(!1),n}return n(r,[{key:"initialize",value:function(){var t=[-.5,-.5,-.5],n=at.create(ot);return n.scale.set(.475,.475,.475),n.updateInverseTransformation(),this.data=De.run(t,1,null,n.setOperationType(l.UNION)),this.data.compress(),this}},{key:"clear",value:function(){return this.data=null,this.targetContainer.clear(),this}},{key:"run",value:function(){var t=new _e("Decompression Report"),n=this.targetContainer,e=this.data,i=void 0,a=void 0;for(t.addLine("Performing 200 decompression tasks"),a=0;a<200;++a)i=performance.now(),e.decompress(n),t.addValue(performance.now()-i);return console.log("Decompressed data",n),t}}]),r}(),Ee=function(e){i(r,Te);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,"CSG Test"));return n.data=null,n.cellSize=1,n.cellPosition=[-.5,-.5,-.5],n.sdf=null,n}return n(r,[{key:"initialize",value:function(){var t=at.create(st).setOperationType(l.UNION),n=at.create(ot).setOperationType(l.UNION);return t.scale.set(.475,.475,.475),t.updateInverseTransformation(),n.scale.set(.475,.475,.475),n.updateInverseTransformation(),this.data=De.run(this.cellPosition,this.cellSize,null,t),this.sdf=n,this}},{key:"clear",value:function(){return this.data=null,this.sdf=null,this}},{key:"run",value:function(){var t=new _e("CSG Report"),n=this.cellPosition,e=this.cellSize,i=this.data,a=this.sdf,r=void 0,s=void 0,o=void 0;for(t.addLine("Executing 200 CSG Union operations on existing data"),t.addLine("Initial material count: "+i.materials),t.addLine("Initial edge count: "+(i.edgeData.indices[0].length+i.edgeData.indices[1].length+i.edgeData.indices[2].length)),o=0;o<200;++o)s=performance.now(),r=De.run(n,e,i,a),t.addValue(performance.now()-s);return t.addLine("Final material count: "+r.materials),t.addLine("Final edge count: "+(r.edgeData.indices[0].length+r.edgeData.indices[1].length+r.edgeData.indices[2].length)),console.log("Generated data",r),t}}]),r}(),Ve=function(e){i(r,Te);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,"SVO Test"));return n.data=null,n.cellSize=1,n.cellPosition=new h(-.5,-.5,-.5),n}return n(r,[{key:"initialize",value:function(){var t=at.create(ot);return t.scale.set(.475,.475,.475),t.updateInverseTransformation(),ze.errorThreshold=.01,this.data=De.run(this.cellPosition.toArray(),this.cellSize,null,t.setOperationType(l.UNION)),this}},{key:"clear",value:function(){return this.data=null,this}},{key:"run",value:function(){var t=new _e("SVO Report"),n=this.cellPosition,e=this.cellSize,i=this.data,a=void 0,r=void 0,s=void 0;for(t.addLine("Building 200 sparse voxel octrees"),t.addLine("Material count: "+i.materials),t.addLine("Edge count: "+(i.edgeData.indices[0].length+i.edgeData.indices[1].length+i.edgeData.indices[2].length)),s=0;s<200;++s)r=performance.now(),a=new Me(i,n,e),t.addValue(performance.now()-r);return t.addLine("Final voxel count: "+a.voxelCount),console.log("Sparse voxel octree",a),t}}]),r}(),Fe=function(e){i(r,Te);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,"Contouring Test"));return n.svo=null,n}return n(r,[{key:"initialize",value:function(){var t=new h(-.5,-.5,-.5),n=at.create(ot);return n.scale.set(.475,.475,.475),n.updateInverseTransformation(),ze.errorThreshold=.01,this.svo=new Me(De.run(t.toArray(),1,null,n.setOperationType(l.UNION)),t,1),this}},{key:"clear",value:function(){return this.svo=null,this}},{key:"run",value:function(){var t=new _e("Contouring Report"),n=this.svo,e=void 0,i=void 0,a=void 0;for(t.addLine("Performing 200 contouring tasks"),t.addLine("Voxel count: "+n.voxelCount),a=0;a<200;++a)i=performance.now(),e=te.run(n),t.addValue(performance.now()-i);return t.addLine("Generated vertices: "+e.positions.length/3),t.addLine("Generated triangle indices: "+e.indices.length),console.log("Extracted isosurface",e),t}}]),r}(),Be="worker.config",Re="worker.test",Ue=new Map([["Compression",new Ie],["Decompression",new qe],["Contouring",new Fe],["CSG",new Ee],["SVO",new Ve]]);self.addEventListener("message",function(t){var n=t.data,e=void 0,i=void 0;switch(n.action){case Be:Wt.resolution=n.resolution,console.log("Setting Hermite data resolution to",n.resolution);break;case Re:i=(e=Ue.get(n.id).initialize()).run(),e.clear(),postMessage({reportName:i.name,reportURL:URL.createObjectURL(new Blob([i.toString()],{type:"text/plain"}))})}})}();'],{type:"text/javascript"})),e=null,i=["Compression","Decompression","Contouring","CSG","SVO"];function a(n){e.postMessage({action:t.CONFIGURE,resolution:Number.parseInt(n.target.value)})}function r(n){var i=n.target.id,a=document.createElement("h3");a.appendChild(document.createTextNode("Running "+i+" Test…")),document.getElementById("aside").appendChild(a),document.getElementById("mask").removeAttribute("class"),e.postMessage({action:t.TEST,id:i})}function s(t){switch(t.type){case"message":!function(t){var n=t.data,e=document.createElement("div"),i=document.createElement("span"),a=document.createElement("a");a.href=n.reportURL,a.setAttribute("download",n.reportName+".log"),a.setAttribute("class","report"),a.appendChild(document.createTextNode("Report ⭳")),i.appendChild(document.createTextNode("Test complete")),i.setAttribute("class","status"),i.appendChild(a),e.setAttribute("class","result"),e.appendChild(i),e.appendChild(a),document.getElementById("aside").appendChild(e),document.getElementById("mask").setAttribute("class","hidden")}(t);break;case"error":console.error("Encountered an unexpected error",t)}}window.addEventListener("load",function o(u){window.removeEventListener("load",o),document.getElementById("resolution").addEventListener("change",a),(e=new Worker(n)).addEventListener("message",s),e.addEventListener("error",s),e.postMessage({action:t.CONFIGURE,resolution:64}),function(){var t=document.getElementById("main"),n=document.createElement("ul"),e=void 0,a=void 0,s=void 0,o=!0,u=!1,l=void 0;try{for(var h,c=i[Symbol.iterator]();!(o=(h=c.next()).done);o=!0)e=h.value,a=document.createElement("li"),(s=document.createElement("a")).appendChild(document.createTextNode(e)),s.setAttribute("href","#"+e),s.setAttribute("id",e),s.addEventListener("click",r),a.appendChild(s),n.appendChild(a)}catch(t){u=!0,l=t}finally{try{!o&&c.return&&c.return()}finally{if(u)throw l}}t.appendChild(n)}()})}();